interface IArray {
  rep type T
  
  func loc(a: T, i: Int) returns (r: Ref)
  func len(a: T) returns (l: Int)
  func first(r: Ref) returns (a: T)
  func second(r: Ref) returns (i: Int)
  
  lemma all_diff(a: T, i: Int)
    ensures first(loc(a, i)) == a && second(loc(a, i)) == i
    
  lemma len_nonneg(a: T)
    ensures len(a) >= 0
}

module DutchFlag/*[Arr: IArray]*/ {
    field value: Int;
    
    pred ordered(m: Map[Int, Int], len: Int) {
        forall i: Int, j: Int :: 0 <= i && i < j && j < len ==> m[i] <= m[j]
    }

    pred access(a: IArray, implicit ghost m: Map[Int, Int]) {
        forall i: Int :: 0 <= i && i < IArray.len(a) ==> own(IArray.loc(a,i), value, m[i], 1)
    }

    proc dutchFlag(a: IArray, implicit ghost m: Map[Int, Int]) 
        requires access(a,m)
        requires forall i: Int :: 0 <= i && i < IArray.len(a) ==> m[i] == 0 || m[i] == 1 || m[i] == 2
        ensures exists m2 :: access(a,m2) && ordered(m2, IArray.len(a))
    {
        var unsorted : Int := 0;
        var white : Int := 0;
        var blue : Int := IArray.len(a);

        while (unsorted < blue)
            invariant access(a, m)
            invariant 0 <= white && white <= unsorted && unsorted <= blue && blue <= IArray.len(a)
            invariant forall i: Int :: 0 <= i && i < IArray.len(a) ==> m[i] == 0 || m[i] == 1 || m[i] == 2
            invariant forall i : Int :: 0 <= i && i < white ==> m[i] == 0
            invariant forall i : Int :: white <= i && i < unsorted ==> m[i] == 1
            invariant forall i : Int :: blue <= i && i < IArray.len(a) ==> m[i] == 2
        {
            unfold access(a, m);

            var tmp : Int := IArray.loc(a,unsorted).value;
            if (tmp == 1) {
                unsorted := unsorted + 1;
            } else if (tmp == 0) {
                var tmp1 : Int = IArray.loc(a,white).value;
                IArray.loc(a,unsorted).value := tmp1;
                var tmp2 : Int = IArray.loc(a,white).value;
                // m[unsorted] := tmp2;

                IArray.loc(a,white).value := tmp;
                // m[white] := tmp;

                white := white + 1;
                unsorted := unsorted + 1;
            } else {
                var tmp1 : Int = IArray.loc(a,blue - 1).value;
                IArray.loc(a,unsorted).value := tmp1;

                var tmp2 : Int = IArray.loc(a,blue - 1).value;
                // m[unsorted] := tmp2;

                blue := blue - 1;
                IArray.loc(a,blue).value := tmp;
                // m[blue] := tmp;
            }

            fold access(a, m);
        }

        fold ordered(m, IArray.len(a));
    }

    proc test1(x: Ref, y: Ref)
        requires own(x, value, 5, 3/4)
        requires own(y, value, 5, 3/4)
        ensures (x != y)
        { }

    proc test2(l: Ref)
        requires own(l, value, 5, 1/2)
        requires own(l, value, 5, 1/2)
        ensures own(l, value, 5, 1)
        { }

}

