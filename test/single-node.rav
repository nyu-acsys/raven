module Lock {
  rep type Rep = struct {
    var bit: Bool
  }
  
  pred lockR(l: Rep, b: Bool) {
    own(l.bit, b)
  }

  proc create()
    returns (l: Rep)
    ensures lockR(l, false)
  {
    l := new(bit(false))
  }

  proc acquire(l: Rep, implicit ghost b: Bool)
    atomic require lockR(l, b)
    atomic ensures lockR(l, true)
  {
    {# 
    	val phi, b = openAU
    	unfold lockR(l, b) 
    #}
    
    val res := cas(l.bit, false, true)

    {#
    	fold lockR(l, l.bit) 
      if (res) {
      	commitAU(phi);
      } else { 
      	abortAU(phi);
      }	
    #}
    
    if (!res) {
    	acquire(l)
    }	
  }

	(* automatic linearization for programs with a single physical step? *)
  proc release(l: Lock)
    atomic require lockR(l, true)
    atomic ensures lockR(l, false)
  {
    l.bit := false
  }
}


interface Keyspace {
  rep type T

  val KS: Set[T]
}

module IntKeyspace : Keyspace {
  rep type T = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type Op = data { case searchOp ; case insertOp ; case deleteOp }

  pred opSpec(op: Op, k: K, C: Set[K], C': Set[K], res: Bool) {
    match(op) {
     case searchOp => C' == C && res == (k in C)
     case insertOp => C' == C ++ {|k|} && res == (k !in C)
     case insertOp => C' == C -- {|k|} && res == (k in C)
    }
  }
}

interface NodeImpl[K: Keyspace] {

  import K.KS
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type T

  pred nodeR(n: T, C: Set[K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Op, n: T, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS &*& node(n, C)
    ensures nodeR(n, C') &*& opSpec(dop, k, C, C', res)
}

interface SearchStructure[K: Keyspace] {
  import K.KS
  module Spec = SearchStructureSpec[K]
  import Spec

  type CSS

  pred cssR(r: CSS, C: Set[K])

  pred cssInv(r: CSS)

  proc create()
    returns (r: CSS)
    ensures inv(cssI, cssInv(r)) && cssR(r, {||})

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS &*& inv("ccsI", cssInv(r))
    atomic requires cssR(r, C)
    atomic ensures cssR(r, C') && opSpec(dop, k, C, C', res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] : SearchStructure[K] {
  import K.KS
  import Node

  module FracSK = Frac[Set[K]]
  (* module AuthSK = Auth[Excl[Set[K]]] *)

  type CSS = struct {
    var lock: Lock
    var node: Node
    ghost cont_lock: FracSK
    ghost cont_spec: FracSK
  }
  
  pred nodePred(r: CSS) {
    exists C: Set[K] :: nodeR(r.node, C) &*& own(r.cont_lock, frac(1/2, C))
  }

  pred cssAuth(r: CSS, C: Set[K]) {
    own(r.cont_spec, frac(1/2, C))
  }

  pred cssR(r: CSS, C: Set[K]) {
    own(r.cont_spec, frac(1/2, C))
  }

  pred cssInv(r: CSS) {
    exists b: Bool, C: Set[K] ::
      cssAuth(r, C)
      &*& own(r.cont_lock, frac(1/2, C))
      &*& Lock.lockR(r.lock, b) &*& (b ? true : nodePred(r))
  }

  proc create()
    returns (r: CSS)
  {
    Lock l := Lock.create()
    Node n := Node.create()
    CSS r := new(lock(l), node(n), cont_lock(frac(1, {||})), cont_spec(frac(1, {||}))
    
    {# 
    	createInv cssI cssInv(r, false, {||}) with
    	{ 
    		(* check how dafny does it *)
    		exists: false, {||}
    	 	 
    	 	updateRes cont_lock (frac(1, {||})) (frac(1/2, {||}) &*& frac(1/2, {||}))
    	 	updateRes cont_spec (frac(1, {||})) (frac(1/2, {||}) &*& frac(1/2, {||}))
    	 	 
    		fold(cssAuth(r, {||}))
    		fold(cssInv(r))
    	}
    	fold cssR(r, {||})	 
    #} 
  }

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
  {
    {# 
    	C0 = openAU
    	openInv "cssI"
    	unfold cssInv(r)
    #}
    
    acquire(r.lock) 
    
    {#
    	closeInv "cssI"
    #} 
    
    res := decisiveOp(dop, r, k)
    release(r.lock) with {!
      commit(phi)
      use(css(r, C))
      use(inv(cssInv(r)))
      use(cssAuth(r, C))
      use(nodePred(r))
      ## TODO: What about ghost updates?
    !}
  }
}
