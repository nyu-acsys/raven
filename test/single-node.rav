module Lock {
  rep type T = struct {
    var bit: Bool
  }
  
  pred lockR(l: Lock, b: Bool) {
    own(l.bit, b)
  }

  proc create()
    returns (l: Lock)
    ensures lockR(l, false)
  {
    l := new(bit(false))
  }

  proc acquire(l: Lock, implicit ghost b)
    atomic require lockR(l, b)
    atomic ensures lockR(l, true)
  {
    ghost val phi = openAtom()

    val res := cas(l.bit, false, true)

    if (res) commit(phi)
    
    if (!res) acquire(l)
  }

  proc release(l: Lock)
    atomic require lockR(l, true)
    atomic ensures lockR(l, false)
  {
    l.bit := false
  }
}


interface Keyspace {
  rep type T

  val KS: Set[T]
}

module IntKeyspace : Keyspace {
  rep type T = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec[module K: Keyspace] {

  type Op = searchOp | insertOp | deleteOp

  pred opSpec(op: Op, C: Set[K], C': Set[K], res: Bool) {
    match(op) {
     | searchOp -> C' == C && res == (k in C)
     | insertOp -> C' == C ++ {|k|} && res == (k !in C)
     | insertOp -> C' == C -- {|k|} && res == (k in C)
    }
  }
}

interface NodeImpl[module K: Keyspace] {

  import K.KS
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type T

  pred nodeR(n: T, C: Set[K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Op, n: T, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS && node(n, C)
    ensures nodeR(n, C') && opSpec(dop, k, C, C', res)
}

interface SearchStructure[module K: Keyspace] {
  import K.KS
  module Spec = SearchStructureSpec[K]
  import Spec

  type CSS

  pred cssR(r: CSS, C: Set[K])

  pred cssInv(r: CSS)

  proc create()
    returns (r: CSS)
    ensures cssInv(r) && cssR(r, {||})

  proc decisiveOp(dop: Op, r: CSS, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    atomic requires k in KS
    atomic requires inv(cssInv(r)) && cssR(r, C)
    atomic ensures cssR(r, C') && opSpec(dop, k, C, C', res)
}

module SingleNodeTemplate[module K: Keyspace, module Node: NodeImpl[K]] : SearchStructure[K] {
  import K.KS
  import Node

  module FracSK = Frac[Set[K]]
  module AuthSK = Auth[Excl[Set[K]]]

  type CSS = struct {
    var lock: Lock
    var node: Node
    ghost cont_lock: FracSK
    ghost cont_spec: AuthSK
  }
  
  pred nodePred(r: CSS) {
    exists C: Set[K] :: nodeR(r.node, C) && own(r.cont_lock, frac(1/2, C))
  }

  pred cssAuth(r: CSS, C: Set[K]) {
    own(r.cont_spec, authAuth(excl(C)))
  }

  pred cssR(r: CSS, C: Set[K]) {
    own(r.cont_spec, authFrag(excl(C)))
  }

  pred cssInv(r: CSS) {
    exists b: Bool, C: Set[K] ::
      cssAuth(r, C)
      && own(r.cont_lock, frac(1/2, C))
      && Lock::lockR(r.lock, b) && (b ? true : nodePred(r))
  }

  proc create()
    returns (r: CSS)
  {
    val l := Lock::create()
    val n := NI::create()
    r := new(lock(l), node(n), cont_lock(frac(1, {||})), cont_spec(authAuth(excl({||}))))
    fold(cssR(r, {||}))
    fold(cssAuth(r, {||}))
    fold(cssInv(r))
  }

  proc decisiveOp(dop: Op, r: CSS, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
  {
    ghost val phi := openAtom()
    acquire(r.lock) using inv(cssInv(r))
    res := decisiveOp(dop, r, k)
    release(r.lock) with {
      commit(phi)
      use(css(r, C))
      use(inv(cssInv(r)))
      use(cssAuth(r, C))
      use(nodePred(r))
      // TODO: What about ghost updates?
    }
  }
}
