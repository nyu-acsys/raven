module Lock {
  field bit: Bool

  pred lockR(l: Ref, b: Bool) {
    own(l.bit, b)
  }

  atom create()
    returns (l: Ref)
    ensures lockR(l, false)
  {
    l := new(bit(false))
  }

  atom acquire(l: Ref, implicit ghost b)
    require lockR(l, b)
    ensures lockR(l, true)
  {
    ghost val phi = openAtom()

    val res := cas(l.bit, false, true)

    if (res) commit(phi)
    
    if (!res) acquire(l)
  }

  atom release(l: Ref)
    require lockR(l, true)
    ensures lockR(l, false)
  {
    l.bit := false
  }
}


interface Keyspace {
  rep type T

  val KS: Set[T]
}

module IntKeyspace : Keyspace where type T = Int {
  rep type T = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec[module K: Keyspace] {

  data Op = searchOp | insertOp | deleteOp

  pred opSpec(op: Op, C: Set[K], C': Set[K], res: Bool) {
    match(op) {
     | searchOp -> C' == C && res == (k in C)
     | insertOp -> C' == C ++ {|k|} && res == (k !in C)
     | insertOp -> C' == C -- {|k|} && res == (k in C)
    }
  }
}

interface NodeImpl[module K: Keyspace] {
  import K::KS
  import SearchStructureSpec[K]

  pred nodeR(n: Ref, C: Set[K])

  proc create()
    returns (n: Ref)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Op, n: Ref, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS && node(n, C)
    ensures nodeR(n, C') && opSpec(dop, k, C, C', res)
}

interface SearchStructure[module K: Keyspace] {
  import K::KS
  import SearchStructureSpec[K]

  pred cssR(r: Ref, C: Set[K])

  pred cssInv(r: Ref)

  atom create()
    returns (r: Ref)
    ensures cssInv(r) && cssR(r, {||})

  atom decisiveOp(dop: Op, r: Ref, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS
    requires inv(cssInv(r)) && cssR(r, C)
    ensures cssR(r, C') && opSpec(dop, k, C, C', res)
}

module SingleNodeTemplate[module K: Keyspace, module NI: NodeImpl] : SearchStructure[K] {
  import K::KS
  import NI[K]

  field lock: Ref
  field node: Ref
  ghost field cont_lock: Frac[Set[K]]
  ghost field cont_spec: Auth[Excl[Set[K]]]
  
  pred nodePred(r: Ref) {
    exists C: Set[K] :: nodeR(r.node, C) && own(r.cont_lock, frac(1/2, C))
  }

  pred cssAuth(r: Ref, C: Set[K]) {
    own(r.cont_spec, authAuth(excl(C)))
  }

  pred cssR(r: Ref, C: Set[K]) {
    own(r.cont_spec, authFrag(excl(C)))
  }

  pred cssInv(r: Ref) {
    exists b: Bool, C: Set[K] ::
      cssAuth(r, C)
      && own(r.cont_lock, frac(1/2, C))
      && Lock::lockR(r.lock, b) && (b ? true : nodePred(r))
  }

  atom create()
    returns (r: Ref)
  {
    val l := Lock::create()
    val n := NI::create()
    r := new(lock(l), node(n), cont_lock(frac(1, {||})), cont_spec(authAuth(excl({||}))))
    fold(cssR(r, {||}))
    fold(cssAuth(r, {||}))
    fold(cssInv(r))
  }

  atom decisiveOp(dop: Op, r: Ref, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
  {
    ghost val phi := openAtom()
    acquire(r.lock) using inv(cssInv(r))
    res := decisiveOp(dop, r, k) using inv(cssInv(r))
    release(r.lock) with {
      commit(phi)
      use(css(r, C))
      use(inv(cssInv(r)))
      use(cssAuth(r, C))
      use(nodePred(r))
      // TODO: What about ghost updates?
    }
  }
}
