module Lock {
  /* rep type Rep = struct {
    var bit: Bool
  } */

  field bit: Bool
  
  pred lock(l: Ref, b: Bool) {
    own(l.bit, b) 
  }

  proc create()
    returns (l: Ref)
    ensures lock(l, false)
  {
    l := new bit(false);
    
    {! 
      unfold lock(l, false);
    !}
  }

  proc acquire(l: Ref, implicit ghost b: Bool)
    atomic requires lock(l, b)
    atomic ensures lock(l, true) && b == false
  {
    val phi: Perm;
    {!
      phi := bindAU();
      val b: Bool;
      b := openAU(phi);

      unfold lock(l, b); 
    !}
    
    /* val res = cas(l.bit, false, true); */

    val res: Bool;

    if (l.bit) {
      res := false;
    } else {
      res := true;
    }

    {!
      if (res) {
        fold lock(l, true);
        commitAU(phi);
      } else {
        fold lock(l, false); 
        abortAU(phi);
      }	
    !}
    
    if (!res) {
      acquire(l);
    }	
  }

  proc release(l: Ref)
    atomic requires lock(l, true)
    atomic ensures lock(l, false)
  {
    val phi: Perm;
    {! 
      phi := bindAU();
      openAU(phi);
      unfold lock(l, true);
    !}
 
    l.(Lock.bit) := false;
    
    {!
      fold lock(l, true);
      commitAU(phi);
    !}
  }
}


interface Keyspace {
  rep type t

  val ks: Set[t]
}

module IntKeyspace : Keyspace {
  rep type t = Int

  val ks = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type op = data { case searchOp ; case insertOp ; case deleteOp }

  /*pred opSpec(op: op, k: K, c: Set[K], c': Set[K], res: Bool) {
    match(op) {
     case searchOp => C' == C && res == (k in C)
     case insertOp => C' == C ++ {|k|} && res == (k !in C)
     case insertOp => C' == C -- {|k|} && res == (k in C)
    }
  }*/
}

interface NodeImpl[K: Keyspace] {

  /*import K.KS*/
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type t

  pred nodeR(n: T, c: Set[K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: op, n: T, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
    requires k in ks && node(n, c)
    ensures nodeR(n, c') && opSpec(dop, k, c, c', res)
}

interface SearchStructure[K: Keyspace] {
  /*import K.KS*/
  module Spec = SearchStructureSpec[K]
  import Spec

  type css

  pred cssR(r: css, c: Set[K])

  pred cssInv(r: css)

  proc create()
    returns (r: css)
    ensures cssInv(cssI, cssInv(r)) && cssR(r, {||})

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
    requires k in ks && cssInv(ccsI, cssInv(r))
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c') && opSpec(dop, k, c, c', res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] : SearchStructure[K] {
  /*import K.KS*/
  import Node

  module FracSK = Frac[Set[K]]

  field lock: Ref;
  field node: Ref;
  field cont_lock: FracSK;
  field cont_spec: FracSK;

  /*type css = struct {
    var lock: lock
    var node: Node
    ghost cont_lock: FracSK
    ghost cont_spec: FracSK
  }*/
  
  pred nodePred(r: css) {
    exists c: Set[K] :: nodeR(r.node, c) && own(r.cont_lock, frac(1/2, c))
  }

  pred cssAuth(r: css, c: Set[K]) {
    own(r.cont_spec, frac(1/2, c))
  }

  pred cssR(r: css, c: Set[K]) {
    own(r.cont_spec, frac(1/2, c))
  }

  pred cssInv(r: css) {
    exists b: Bool, c: Set[K] ::
      cssAuth(r, c)
      && own(r.cont_lock, frac(1/2, c))
      && Lock.lock(r.lock, b) && (b ? true : nodePred(r))
  }

  proc create()
    returns (r: css)
  {
    val l: Ref = Lock.create();
    val n: Node = Node.create();
    
    val r: css; 
   
    /* = new(lock(l), node(n), cont_lock(frac(1, {||})), cont_spec(frac(1, {||})) */

    r.lock := l;
    r.node := n;
    r.cont_lock := frac(1, {||});
    r.cont_spec := frac(1, {||});

    
    {!
      /* check how dafny does it: uses assert */
      /* exists: false, {||} */

      /* Not sure how symbolic execution is supposed to figure out where to apply this */
      assert frac(1, {||}) == frac(1/2, {||}) && frac(1/2, {||}); 
          
      fold(cssAuth(r, {||}));   	

      assert cssAuth(r, c)
              && own(r.cont_lock, frac(1/2, c))
              && Lock.lock(r.lock, b) && (b ? true : nodePred(r));
      fold(cssInv(r));
      /* createInv cssI cssInv(r); */

      fold cssR(r, {||});
    !} 
  }

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
  {
    {!
      unfold cssI;
      /* unfold (b0, c0) :| cssInv(r); */
      unfold cssInv(r);
      fold Lock.lock(r.lock, b0);
    !}
    
    acquire(r.lock);
    
    {!
      assert b0 == false;
      assert nodePred(r);
      unfold Lock.lock(r.lock, true);
      /* fold (true, C0)cssInv(r); */
      fold cssInv(r);
      fold cssI;
      /* unfold (c0')nodePred(r); */
      unfold nodePred(r);
    !} 
    
    res, c1 := decisiveOp(dop, r, k);

    {!
      unfold cssI;
      /* unfold (b1, C1')cssInv(r); */
      unfold cssInv(r);

      /* lemma below asserts C0' = C1' 

      lemma frac_eq(l: loc, )

      */
      frac_eq((r.cont_lock), 1/2, 1/2, c0', c1');

      /* lemma below sums up fractional resources */
      frac_sum((r.cont_lock), 1/2, 1/2, c0');
      
      /* lemma frac_update l C C' : 
            own(l, frac(1, C)) ~~> own(l, frac(1, C')) */
      frac_update((r.cont_lock), c0', c1);

      /* fold (C1)nodePred(r) */
      fold nodePred(r);
      
      phi, c1'' := openAU;
      
      unfold cssAuth(r, c0');
      unfold cssR(r, c1'');
      frac_eq((r.cont_spec), 1/2, 1/2, c0', c1'');
      frac_sum((r.cont_spec), 1/2, 1/2, c0');
      frac_update((r.cont_spec), c0', c1);
      
      fold cssAuth(r, c1);
      fold cssR(r, c1);
      commit(phi);

      assert b1 == true;
      fold Lock.lock(r, true);
    !}

    release(r.lock);
    
    {!
      unfold Lock.lock(r, false);
      /* fold (false, C1)cssInv(r); */
      fold cssInv(r); 
      fold cssI;
    !}    
  }
}
  