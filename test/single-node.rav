module Lock {
  field bit: Bool

  pred lockR(l: Ref, b: Bool) {
    own(l.bit, b)
  }

  atom acquire(l: Ref, implicit ghost b)
    require lockR(l, b)
    ensures lockR(l, true)
  {
    val b := l.bit
    if (!cas(b, false, true)) acquire(l)
  }

  atom release(l: Ref)
    require lockR(l, true)
    ensures lockR(l, false)
  {
    l.bit := false
  }
}


interface Keyspace {
  type K

  val KS: Set[K]
}

module IntKeyspace : Keyspace {
  type K = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec(module Keys: Keyspace) {
  import Keyspace
  
  data Op = searchOp | insertOp | deleteOp

  pred opSpec(op: Op, C: Set[K], C': Set[K], res: Bool) {
    match(op) {
     | searchOp -> C' == C && res == (k in C)
     | insertOp -> C' == C ++ {k} && res == (k !in C)
     | insertOp -> C' == C -- {k} && res == (k in C)
    }
  }
}

interface NodeImpl(module Keys: Keyspace) {
  import Keyspace
  import SearchStructureSpec(Keys)

  pred node(n: Ref, C: Set[K])

  pred decisiveOpSpec(dop: Op, k: K, C, C1, res)

  proc decisiveOp(dop: Op, r: Ref, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS && node(n, C)
    ensures node(n, C') && opSpec(dop, k, C, C', res)
}

interface SearchStructure(module Keys: Keyspace) {
  import Keys
  import SearchStructureSpec(Keys)

  pred css(n: Ref, C: Set[K])

  pred css_inv(r: Ref)
  
  atom decisiveOp(dop: Op, r: Ref, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS
    requires inv(css_inv(r)) && css(r, C)
    ensures css(r, C') && opSpec(dop, k, C, C', res)
}

module SingleNodeTemplate(module Keys: Keyspace, module NI: NodeImpl) : SearchStructure(Keys) {
  import Keyspace
  import NI(Keyspace)

  field lock: Ref
  ghost field cont_lock: Frac[Set[K]]
  ghost field cont_spec: Auth[Excl[Set[K]]]
  
  pred nodePred(n: Ref) {
    exists C: Set[K] :: node(n, C) && own(n.cont_lock, frac(1/2, C))
  }

  pred css_auth(n: Ref, C: Set[K]) {
    own(n.cont_spec, authAuth(excl(C)))
  }

  pred css(n: Ref, C: Set[K]) {
    own(n.cont_spec, authFrag(excl(C)))
  }

  pred css_inv(r: Ref) {
    exists b: Bool, C: Set[K] ::
      css_auth(r, C)
      && own(r.cont_lock, frac(1/2, C))
      && lockR(r.lock, b) && (b ? true : nodePred(n))
  }

  atom decisiveOp(dop: Op, r: Ref, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
  {
    ghost val phi := openAtom()
    acquire(r.lock) using inv(css_inv(r))
    res := decisiveOp(dop, r, k) using inv(css_inv(r))
    release(r.lock) with {
      commit(phi)
      use(css(n, C))
      use(inv(css_inv(r))
      use(css_auth(n, C))
      use(nodePred(n))
    }
  }
}
