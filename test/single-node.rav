module Lock {
  rep type Rep = struct {
    var bit: Bool
  }
  
  pred lock(l: Rep, b: Bool) {
    own(l.bit, b) 
  }

  proc create()
    returns (l: Rep)
    ensures lock(l, false)
  {
    l := new(bit(false));
    
    {# 
    	unfold lock(l, false) 
    #}
  }

  proc acquire(l: Rep, implicit ghost b: Bool)
    atomic require lock(l, b)
    atomic ensures lock(l, true) &*& b = false
  {
    {# 
    	val phi, b = openAU;
    	unfold lock(l, b); 
    #}
    
    val res := cas(l.bit, false, true);

    {#
      if (res) {
      	fold lock(l, true);
      	commitAU(phi);
      } else {
      	fold lock(l, false); 
      	abortAU(phi);
      }	
    #}
    
    if (!res) {
    	acquire(l)
    }	
  }

  proc release(l: Lock)
    atomic require lock(l, true)
    atomic ensures lock(l, false)
  {
  	{# 
  		val phi = openAU;
  		unfold lock(l, true);
  	#}
 
    l.bit := false;
    
    {#
    	fold lock(l, true);
    	commitAU(phi);
    #}
  }
}


interface Keyspace {
  rep type T

  val KS: Set[T]
}

module IntKeyspace : Keyspace {
  rep type T = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type Op = data { case searchOp ; case insertOp ; case deleteOp }

  pred opSpec(op: Op, k: K, C: Set[K], C': Set[K], res: Bool) {
    match(op) {
     case searchOp => C' == C && res == (k in C)
     case insertOp => C' == C ++ {|k|} && res == (k !in C)
     case insertOp => C' == C -- {|k|} && res == (k in C)
    }
  }
}

interface NodeImpl[K: Keyspace] {

  import K.KS
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type T

  pred nodeR(n: T, C: Set[K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Op, n: T, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS &*& node(n, C)
    ensures nodeR(n, C') &*& opSpec(dop, k, C, C', res)
}

interface SearchStructure[K: Keyspace] {
  import K.KS
  module Spec = SearchStructureSpec[K]
  import Spec

  type CSS

  pred cssR(r: CSS, C: Set[K])

  pred cssInv(r: CSS)

  proc create()
    returns (r: CSS)
    ensures inv(cssI, cssInv(r)) && cssR(r, {||})

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
    requires k in KS &*& inv(ccsI, cssInv(r))
    atomic requires cssR(r, C)
    atomic ensures cssR(r, C') && opSpec(dop, k, C, C', res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] : SearchStructure[K] {
  import K.KS
  import Node

  module FracSK = Frac[Set[K]]

  type CSS = struct {
    var lock: Lock
    var node: Node
    ghost cont_lock: FracSK
    ghost cont_spec: FracSK
  }
  
  pred nodePred(r: CSS) {
    exists C: Set[K] :: nodeR(r.node, C) &*& own(r.cont_lock, frac(1/2, C))
  }

  pred cssAuth(r: CSS, C: Set[K]) {
    own(r.cont_spec, frac(1/2, C))
  }

  pred cssR(r: CSS, C: Set[K]) {
    own(r.cont_spec, frac(1/2, C))
  }

  pred cssInv(r: CSS) {
    exists b: Bool, C: Set[K] ::
      cssAuth(r, C)
      &*& own(r.cont_lock, frac(1/2, C))
      &*& Lock.lock(r.lock, b) &*& (b ? true : nodePred(r))
  }

  proc create()
    returns (r: CSS)
  {
    Lock l := Lock.create()
    Node n := Node.create()
    
    CSS r := new(lock(l), node(n), cont_lock(frac(1, {||})), cont_spec(frac(1, {||}))
    
    {# 
    	(* check how dafny does it: uses assert *)
    	(* exists: false, {||} *)

			(* Not sure how symbolic eexecution is supposed to figure out where to apply this *)
			assert frac(1, {||}) = frac(1/2, {||}) * frac(1/2, {||})    	 	 
    	 	 
    	fold(cssAuth(r, {||}))    	

    	assert cssAuth(r, C)
      				&*& own(r.cont_lock, frac(1/2, C))
      				&*& Lock.lock(r.lock, b) &*& (b ? true : nodePred(r))
    	fold(cssInv(r))
      createInv cssI cssInv(r)

    	fold cssR(r, {||})	 
    #} 
  }

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost C: Set[K])
    returns (res: Bool, implicit ghost C': Set[K])
  {
    {# 
    	openInv cssI
    	unfold (b0, C0)cssInv(r)
    	fold Lock.lock(r.lock, b0)
    #}
    
    acquire(r.lock)
    
    {#
    	assert b0 = false
    	assert nodePred(r)
    	unfold Lock.lock(r.lock, true)
    	fold (true, C0)cssInv(r)
    	closeInv cssI
    	unfold (C0')nodePred(r)
    #} 
    
    res, C1 := decisiveOp(dop, r, k)

		{#
			openInv cssI
			unfold (b1, C1')cssInv(r)

			(* lemma below asserts C0' = C1' 

      lemma frac_eq(l: loc, )

      *)
			frac_eq	(r.cont_lock) 1/2 1/2 C0' C1'

			(* lemma below sums up fractional resources *)
			frac_sum (r.cont_lock) 1/2 1/2 C0'
			
			(* lemma frac_update l C C' : 
						own(l, frac(1, C)) ~~> own(l, frac(1, C')) *)
			frac_update (r.cont_lock) C0' C1

			fold (C1)nodePred(r)
			
			val phi, C1'' = openAU
			
			unfold cssAuth(r, C0')
			unfold cssR(r, C1'')
			frac_eq	(r.cont_spec) 1/2 1/2 C0' C1''
			frac_sum (r.cont_spec) 1/2 1/2 C0'
			frac_update (r.cont_spec) C0' C1
			
			fold cssAuth(r, C1)
			fold cssR(r, C1)
			commit(phi)

			assert b1 = true
			fold Lock.lock(r, true)						
		#}

    release(r.lock)
    
    {#
    	unfold Lock.lock(r, false)
    	fold (false, C1)cssInv(r) 
    	closeInv cssI
    #}    
  }
}
