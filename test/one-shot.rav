module OneShotIntRA : Lib.ResourceAlgebra {
    rep type T = data {
        case zero;
        case pending;
        case done(i: Int);
        case top
    }

    val id: T = zero();

    func valid(n: T)
        returns (ret: Bool)
    {
        (n == top() ? false : true)
    }

    func comp(a:T, b:T)
        returns (ret:T)
    {
        a == zero() ? b :
            (b == zero() ? a :
        (a == done(a.i) && b == done(a.i) ? 
            done(a.i) :
            top()
        ))
    }

    func frame(a:T, b:T) returns (ret:T) 
    {
        b == zero() ? a :
        (a == pending() && b == pending() ?
            zero() :
            (a == done(a.i) && b == done(a.i) ?
                done(a.i) :
                top()
            ))
    }

    func fpuAllowed(a: T, b:T) returns (ret:Bool)
    {
        a == b ? true :
        (a == pending() && b == done(b.i) ?
            true : false
        )
        
    }
}

module Main {
    field f: Int
    field ghost_state: OneShotIntRA

    proc main() {
        var x: Ref;
        x := new(f:0, ghost_state: OneShotIntRA.pending());

        one_time_update(x, 5);
        // one_time_update(x, 6);
    }

    proc one_time_update(x: Ref, k: Int)
        requires exists n: Int :: own(x, f, n, 1.0)
        requires own(x, ghost_state, OneShotIntRA.pending())
        ensures own(x, f, k, 1.0)
        ensures own(x, ghost_state, OneShotIntRA.done(k))
    {
        x.f := k;

        fpu(x, ghost_state, OneShotIntRA.done(x.f));
    }

}