field c: Int

pred counter(x: Ref; v: Int) {
  own(x, c, v, 0.5)
}

inv counterInv(x: Ref) { 
  exists v: Int :: own(x, c, v, 0.5)
}

proc incr(x: Ref, implicit ghost v) 
  requires counterInv(x)
  atomic requires counter(x, v)
  ensures counterInv(x)
  atomic ensures counter(x, v + 1)
{
  var phi: AtomicToken := bindAU();

  var v1: Int;
  unfold counterInv(x);
  v1 := x.c;
  fold counterInv(x);
  var new_v1 : Int := v1 + 1;

  var v2: Int := openAU(phi);
  unfold counter(x,v2);
  unfold counterInv(x);

  var res: Bool := CAS(x.c, v1, new_v1);
  
  {! 
    fold counterInv(x);

    if (CAS(x.c, v1, new_v1)) {
      fold counter(x, new_v1);
      commitAU(phi, new_v1);
    } else {
      fold counter(x, v2);
      abortAU(phi);
    }
  !}

  if (!res) incr();
}

proc read(x: Ref)
  requires counterInv(x)
  ensures counterInv(x)
{
  unfold counterInv(x);
  var v: Int := x.c;
  fold counterInv(x);

  return v;
}