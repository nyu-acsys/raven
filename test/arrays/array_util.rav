interface Array {
  rep type T
  type E

  func loc(a: T, i: Int) returns (r: Ref)
  func length(a: T) returns (l: Int)
  func first(r: Ref) returns (a: T)
  func second(r: Ref) returns (i: Int)
  
  auto axiom all_diff()
    ensures forall a:T, i: Int :: {loc(a, i)} first(loc(a, i)) == a && second(loc(a, i)) == i
    
  auto axiom len_nonneg()
    ensures forall a:T :: {length(a)} length(a) >= 0
}

interface OrderedType : Library.Type {
  // An ordered type
  rep type T
    
  func lt(x: T, y: T) returns (res: Bool)

  func le(x: T, y: T) returns (res: Bool) {
    lt(x, y) || x == y
  }

  func compare(x: T, y: T) returns (res: Int)
  {
    x == y ? 0 : (lt(x, y) ? -1 : 1)
  }

  val bot: T
  val top: T

  auto axiom bot_smallest()
    ensures forall a: T :: {lt(a, bot)} !lt(a, bot)
  auto axiom top_largest()
    ensures forall a: T :: {lt(top, a)} !lt(top, a)
  auto axiom nontrivial()
    ensures bot != top

  auto axiom lt_irreflexive()
    ensures forall a: T :: {lt(a, a)} !lt(a, a)
  auto axiom lt_antisymmetric()
    ensures forall a: T, b: T :: {lt(a, b)} {lt(b, a)} !lt(a, b) || !lt(b, a)
  auto axiom lt_total()
    ensures forall a: T, b: T :: {lt(a, b)} {lt(b, a)} lt(a, b) || lt(b, a) || a == b
  auto axiom lt_transitive()
    ensures forall a: T, b: T, c: T :: {lt(a, b), lt(b, c)} lt(a, b) && lt(b, c) ==> lt(a, c)

}

interface ArrayUtil[K: OrderedType] {
  import K.lt

  interface A : Array {
    type E = K
  }

  field value: K

  pred arr(a: A, m: Map[Int, K]) {
    forall j: Int :: 0 <= j < A.length(a) ==> own(A.loc(a, j), value, m[j], 1.0)
  }

  // project map segment m[i..j] to set of its elements
  func set_of_map(m: Map[Int, K], i: Int, j: Int)
    returns (res: Set[K])
    requires i <= j
  {
    i < j ? {| m[i] |} ++ set_of_map(m, i + 1, j) : {||}
  }

  lemma extend_right(m: Map[Int, K], i: Int, j: Int)
    requires i <= j
    ensures set_of_map(m, i, j) ++ {| m[j] |} == set_of_map(m, i, j + 1)
  {
    if (i < j) {
      extend_right(m, i + 1, j);
    }
  }

  lemma in_set_of_map(m: Map[Int, K], i: Int, j: Int)
    requires i <= j
    ensures forall k: Int :: {m[k]} i <= k < j ==> m[k] in set_of_map(m, i, j)
  {
    if (i < j) {
      in_set_of_map(m, i + 1, j);
    }
  }

  lemma set_of_map_split(m: Map[Int, K], i: Int, j: Int, k: Int)
    requires i <= j <= k
    ensures set_of_map(m, i, k) == set_of_map(m, i, j) ++ set_of_map(m, j, k)
  {
    if (j < k) {
      extend_right(m, i, j);
      set_of_map_split(m, i, j + 1, k);
    }
  }

  lemma set_of_map_equal(m1: Map[Int, K], m2: Map[Int, K], i1: Int, i2: Int, len: Int)
    requires forall j: Int :: {m1[j]} i1 <= j < i1 + len ==> m1[j] == m2[j + (i2 - i1)]
    ensures set_of_map(m1, i1, i1 + len) == set_of_map(m2, i2, i2 + len)
  {
    if (0 < len) {
      set_of_map_equal(m1, m2, i1 + 1, i2 + 1, len - 1);
    }
  }

  lemma frame_set_of_map(m: Map[Int, K], i: Int, j: Int)
    requires i <= j
    ensures forall i1: Int, k: K :: {set_of_map(m[i1 := k], i, j)} 
      i1 < i || j <= i1 ==> set_of_map(m, i, j) == set_of_map(m[i1 := k], i, j)
  {
    if (i < j) {
      frame_set_of_map(m, i + 1, j);
    }
  }

  func sorted_map_seg(m: Map[Int, K], i: Int, j: Int) returns (res: Bool)
  {
    forall i1: Int, i2: Int :: {m[i1], m[i2]} i <= i1 && i1 < i2 && i2 < j ==> lt(m[i1], m[i2])
  }


  lemma not_in_sorted_seg(m: Map[Int, K], i: Int, j: Int, k: K, implicit ghost c: Set[K])
    requires sorted_map_seg(m, i, j) && c == set_of_map(m, i, j)
    ensures i >= j || lt(k, m[i]) || lt(m[j-1], k) ==> k !in c
  {
    if (i >= j) return;
  
    if (lt(m[j - 1], k)) {
      extend_right(m, i, j - 1);
      not_in_sorted_seg(m, i, j - 1, k);
      return;
    }

    if (lt(k, m[i])) {
      not_in_sorted_seg(m, i + 1, j, k);    
      return;
    }
  
  }

  func map_find(m: Map[Int, K], i: Int, j: Int, k: K) returns (idx: Int)
    /*ensures 
      i <= j && sorted_map_seg(m, i, j) ==>
        i <= idx <= j &&
        (m[idx] == k || idx == j || lt(k, m[idx])) &&
        (i < idx ==> lt(m[idx - 1], k))*/
  {
    i < j && lt(m[i], k) ? map_find(m, i + 1, j, k) : i  
  }

  lemma map_find_spec(m: Map[Int, K], i: Int, j: Int, k: K)
    ensures i <= j && sorted_map_seg(m, i, j) ==>
        i <= map_find(m, i, j, k) && map_find(m, i, j, k) <= j &&
        (m[map_find(m, i, j, k)] == k || map_find(m, i, j, k) == j || lt(k, m[map_find(m, i, j, k)])) &&
        (i < map_find(m, i, j, k) ==> lt(m[map_find(m, i, j, k) - 1], k))
  {
    if (i < j && sorted_map_seg(m, i, j)) {
      map_find_spec(m, i+1, j, k);
    }
  }

  auto lemma map_find_spec_auto()
    ensures forall m: Map[Int, K], i: Int, j: Int, k: K :: i <= j && sorted_map_seg(m, i, j) ==>
        i <= map_find(m, i, j, k) && map_find(m, i, j, k) <= j &&
        (m[map_find(m, i, j, k)] == k || map_find(m, i, j, k) == j || lt(k, m[map_find(m, i, j, k)])) &&
        (i < map_find(m, i, j, k) ==> lt(m[map_find(m, i, j, k) - 1], k))
  {
    assert forall m: Map[Int, K], i: Int, j: Int, k: K :: i <= j && sorted_map_seg(m, i, j) ==>
        i <= map_find(m, i, j, k) && map_find(m, i, j, k) <= j &&
        (m[map_find(m, i, j, k)] == k || map_find(m, i, j, k) == j || lt(k, m[map_find(m, i, j, k)])) &&
        (i < map_find(m, i, j, k) ==> lt(m[map_find(m, i, j, k) - 1], k)) with {
      map_find_spec(m, i, j, k);
    }
  }


  lemma map_find_in_set(m: Map[Int, K], i: Int, j: Int, k: K)
    requires i <= j
    requires sorted_map_seg(m, i, j)
    ensures k in set_of_map(m, i, j) ==> map_find(m, i, j, k) < j && m[map_find(m, i, j, k)] == k
    ensures k !in set_of_map(m, i, j) ==> map_find(m, i, j, k) == j || lt(k, m[map_find(m, i, j, k)])
  {
    val idx: Int := map_find(m, i, j, k);
    map_find_content_set(m, i, j, idx, k);
    set_of_map_split(m, i, idx, j);
  }

  lemma map_find_content_set(m: Map[Int, K], i: Int, j: Int, idx: Int, k: K)
    requires i <= j
    requires sorted_map_seg(m, i, j)
    requires idx == map_find(m, i, j, k)
    ensures k !in set_of_map(m, i, idx)
    ensures k !in set_of_map(m, idx + 1, j)
  {
    // prove k !in set_of_map(a, 0, idx)
    not_in_sorted_seg(m, i, idx, k);
    // prove: k !in set_of_map(a, idx + 1, len)
    not_in_sorted_seg(m, idx + 1, j, k);
  }


  func map_shift(m: Map[Int, K], src: Int, dst: Int, len: Int)
    returns (res: Map[Int, K])
    ensures forall i: Int :: {res[i]} res[i] == (i < dst || dst + len <= i ? m[i] : m[src + (i - dst)])
  //{
  //  {| i: Int :: {res[i]} i < dst || dst + len <= i ? m[i] : m[src + (i - dst)] |}
  //}

  func map_copy(m1: Map[Int, K], m2: Map[Int, K], src: Int, dst: Int, len: Int)
    returns (res: Map[Int, K])
    ensures forall i: Int :: {res[i]} res[i] == (dst <= i < dst + len ? m2[src + (i - dst)] : m1[i])
  //{
  //  {| i: Int :: {res[i]} dst <= i < dst + len ? m2[src + (i - dst)] : m1[i] |}
  //}

  lemma map_insert_content_set(m: Map[Int, K], m1: Map[Int, K], idx: Int, k: K, len: Int, new_len: Int)
    requires sorted_map_seg(m, 0, len)
    requires idx == map_find(m, 0, len, k)
    requires 0 <= idx <= len
    requires k in set_of_map(m, 0, len) ==> new_len == len && m1 == m
    requires k !in set_of_map(m, 0, len) ==> new_len == len + 1 && m1 == map_shift(m, idx, idx + 1, len - idx)[idx := k]
    ensures set_of_map(m1, 0, new_len) == set_of_map(m, 0, len) ++ {| k |}
  {
    if (m[idx] == k && idx < len) {
      in_set_of_map(m, 0, len);
      return;
    }
  
    var ms: Map[Int, K] := map_shift(m, idx, idx + 1, len - idx);

    // prove set_of_map(m, 0, len) == set_of_map(ms, 0, idx) ++ set_of_array(ms, idx + 1, len + 1);
    
    set_of_map_split(m, 0, idx, len);
    set_of_map_equal(m, ms, 0, 0, idx);
    set_of_map_equal(m, ms, idx, idx + 1, len - idx);

    // prove set_of_map(m1, 0, new_len) == set_of_array(ms, 0, idx) ++ {k} ++ set_of_map(ms, idx + 1, len + 1)
    frame_set_of_map(ms, 0, idx);
    frame_set_of_map(ms, idx + 1, len + 1);  
    set_of_map_split(m1, 0, idx, len + 1);
  }

  lemma map_delete_content_set(m: Map[Int, K], m1: Map[Int, K], len: Int, new_len: Int, idx: Int, k: K)
    requires sorted_map_seg(m, 0, len)
    requires idx == map_find(m, 0, len, k)
    requires 0 <= idx <= len
    requires k !in set_of_map(m, 0, len) ==> new_len == len && m1 == m
    requires k in set_of_map(m, 0, len) ==> new_len == len - 1 && m1 == map_shift(m, idx + 1, idx, len - (idx + 1))
    ensures set_of_map(m1, 0, new_len) == set_of_map(m, 0, len) -- {|k|}
  {
    map_find_content_set(m, 0, len, idx, k);
    set_of_map_split(m, 0, idx, len);
    
    if (idx == len || m[idx] != k) {
      return;
    }

    // prove: set_of_map(m, 0, len) -- {k} == set_of_map(m1, 0, idx - 1) ++ set_of_map(m1, idx - 1, len - 1)
    set_of_map_equal(m, m1, 0, 0, idx);
    set_of_map_equal(m, m1, idx + 1, idx, len - (idx + 1));

    not_in_sorted_seg(m, 0, idx - 1, k);
    not_in_sorted_seg(m, idx + 1, len, k);
  
    set_of_map_split(m1, 0, idx, len - 1);
  }

  // Shift a[src..src+len] to a[dst..dst+len]
  proc arr_shift(a: A, src: Int, dst: Int, len: Int, implicit ghost amap: Map[Int, K])
    requires arr(a, amap)
    requires 0 <= src <= src + len <= A.length(a) && 0 <= dst <= dst + len <= A.length(a)
    ensures arr(a, map_shift(amap, src, dst, len))
  {
    if (src < dst) {
      var i: Int := len - 1;
      
      while (i >= 0) 
        invariant arr(a, map_shift(amap, src + i + 1, dst + i + 1, len - i - 1))
        invariant src < dst
        invariant 0 <= src <= src + len <= A.length(a)
        invariant 0 <= dst <= dst + len <= A.length(a)
        invariant -1 <= i < len
      {
        //ghost var m1 := a.map;
        unfold arr(a, map_shift(amap, src + i + 1, dst + i + 1, len - i - 1));
        var tmp: K := A.loc(a, src + i).value;
        A.loc(a, dst + i).value := tmp;
        //pure assert a.map == m1[dst + i := tmp];
        i := i - 1;
        fold arr(a, map_shift(amap, src + i + 1, dst + i + 1, len - i - 1));
      }
    } else if (src > dst) {
      var i: Int := 0;
      while (i < len)
        invariant arr(a, map_shift(amap, src, dst, i))
        invariant src > dst
        invariant 0 <= src <= src + len <= A.length(a)
        invariant 0 <= dst <= dst + len <= A.length(a)
        invariant 0 <= i <= len 
      {
        //ghost var m1 := a.map;
        unfold arr(a, map_shift(amap, src, dst, i));
        var tmp: K := A.loc(a, src + i).value;
        A.loc(a, dst + i).value := tmp;
        //pure assert a.map == m1[dst + i := tmp];
        i := i + 1;
        fold arr(a, map_shift(amap, src, dst, i));
      }
    }
  }


  // Copy a[src..src+len] to b[dst..dst+len]
  proc arr_copy(a: A, b: A, src: Int, dst: Int, len: Int, implicit ghost amap: Map[Int, K], implicit ghost bmap: Map[Int, K] )
    requires arr(a, amap) && arr(b, bmap)
    requires 0 <= src <= src + len <= A.length(a)
    requires 0 <= dst <= dst + len <= A.length(b)
    ensures arr(a, amap) && arr(b, map_copy(bmap, amap, src, dst, len))
  {
    var i: Int := 0;
  
    while (i < len)
      invariant arr(a, amap) && arr(b, map_copy(bmap, amap, src, dst, i))
      invariant 0 <= i <= len
      invariant 0 <= src <= src + len <= A.length(a)
      invariant 0 <= dst <= dst + len <= A.length(b)
    {
      unfold arr(a, amap);
      var tmp: K := A.loc(a, src + i).value;
      fold arr(a, amap);
      unfold arr(b, map_copy(bmap, amap, src, dst, i));
      A.loc(b, dst + i).value := tmp;
      i := i + 1;
      fold arr(b, map_copy(bmap, amap, src, dst, i));
    }
  }

  pred sorted_array_with_content(a: A, len: Int, m: Map[Int, K])
  {
    0 <= len <= A.length(a) && arr(a, m) && sorted_map_seg(m, 0, len)
  }

  // Find key `k` in sorted array segment `a[0..len]` using binary search
  proc arr_find(a: A, len: Int, k: K, implicit ghost m: Map[Int, K])
    returns (found: Bool, idx: Int)
    requires sorted_array_with_content(a, len, m)
    requires 0 <= len <= A.length(a)
    ensures sorted_array_with_content(a, len, m)
    // what we actually care about
    ensures idx == map_find(m, 0, len, k)
    ensures found == (k in set_of_map(m, 0, len))
  {
    var lo: Int := 0;
    var hi: Int := len;
    
    while (hi != lo)
      invariant sorted_array_with_content(a, len, m)
      // what we actually care about
      invariant 0 <= lo <= hi <= len <= A.length(a)
      invariant hi == len || m[lo] == k || lt(k, m[hi])
      invariant 0 < lo ==> lt(m[lo - 1], k)
      invariant hi < len - 1 ==> lt(k, m[hi + 1])
    {
      unfold sorted_array_with_content(a, len, m);
      unfold arr(a, m);
      var mid: Int := (hi + lo) / 2;
      var amid: K := A.loc(a, mid).value;
      var cmp: Int := K.compare(k, amid);
      if (cmp < 0) {
        hi := mid;      // look in first half
      } else if (cmp > 0) {
        lo := mid + 1;    // look in second half
      } else {
        // found it
        hi := mid;
        lo := mid;
      }
      fold arr(a, m);
      fold sorted_array_with_content(a, len, m);
    }
    
    idx := lo;
    
    if (idx == len) {
      found := false;
    } else {
      unfold sorted_array_with_content(a, len, m);
      assume false;
      unfold arr(a, m);
      var alo: K := A.loc(a, lo).value;
      found := !lt(k, alo);
      fold arr(a, m);
      fold sorted_array_with_content(a, len, m);
    }

    unfold sorted_array_with_content(a, len, m);
    map_find_in_set(m, 0, len, k);
    fold sorted_array_with_content(a, len, m);
  }

  // Given a sorted array segment `a[0..len]`,
  // insert `k` into `a[0..len+1]` while preserving sortedness.
  // If `k` is already contained in `a[0..len]`, then do not modify `a`.
  proc arr_insert(a: A, k: K, len: Int, implicit ghost m: Map[Int, K])
    returns (idx: Int, new_len: Int, implicit ghost m1: Map[Int, K])
    requires sorted_array_with_content(a, len, m)
    requires 0 <= len < A.length(a)
    ensures sorted_array_with_content(a, new_len, m1)
    ensures idx == map_find(m, 0, len, k)
    ensures k in set_of_map(m, 0, len) ==> new_len == len && m1 == m
    ensures k !in set_of_map(m, 0, len) ==> new_len == len + 1 && m1 == map_shift(m, idx, idx + 1, len - idx)[idx := k]
  {
    // find position for insertion
    var i: Int;
    var found: Bool;
    found, i := arr_find(a, len, k, m);

    unfold sorted_array_with_content(a, len, m);
    map_find_in_set(m, 0, len, k);
    fold sorted_array_with_content(a, len, m);
    
    // k already in C?
    if (found) return i, len, m;
    
    unfold sorted_array_with_content(a, len, m);
    arr_shift(a, i, i + 1, len - i, m);

    assume false;
    unfold arr(a, map_shift(m, i, i + 1, len - i));
    A.loc(a, i).value := k;
    m1 := map_shift(m, i, i + 1, len - i)[i := k];
    fold arr(a, m1);
    //pure assert a.map == ms[i := k];
    fold sorted_array_with_content(a, len + 1, m1);

    return i, len + 1, m1;
  }

  // Given a sorted array segment `a[0..len]`,
  // delete `k` from the segment while preserving sortedness.
  // If `k` is already contained in `a[0..len]`, then do not modify `a`.
  proc arr_delete(a: A, k: K, len: Int, implicit ghost m: Map[Int, K])
    returns (new_len: Int, idx: Int, implicit ghost m1: Map[Int, K])
    requires 0 <= len <= A.length(a)
    requires sorted_array_with_content(a, len, m)
    ensures sorted_array_with_content(a, new_len, m1)
    ensures idx == map_find(m, 0, len, k)
    ensures k !in set_of_map(m, 0, len) ==> new_len == len && m1 == m
    ensures k in set_of_map(m, 0, len) ==> new_len == len - 1 && m1 == map_shift(m, idx + 1, idx, len - (idx + 1))
  {
    // find position for insertion
    var found: Bool;
    found, idx := arr_find(a, len, k, m);

    unfold sorted_array_with_content(a, len, m);
    map_find_in_set(m, 0, len, k);
    fold sorted_array_with_content(a, len, m);
    
    // k !in C?
    if (!found) {
      return len, idx, m;
    }
    
    // shift array entries a[i+1..len] by 1 entry to the left 
    unfold sorted_array_with_content(a, len, m);
    arr_shift(a, idx + 1, idx, len - (idx + 1), m);
    m1 := map_shift(m, idx + 1, idx, len - (idx + 1));
    fold sorted_array_with_content(a, len - 1, m1);
    return len - 1, idx, m1;
  }

}