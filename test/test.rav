module Lock {
  field bit: Bool

  rep type T = Bool

  module Key {
    var l = true
  }

  pred lockR(l: Ref, b: Bool) {
    own(l.bit, b)
  }

  var l = true

  proc create()
    returns (l: Ref)
    ensures lockR(l, false)
  {
    var xx : Ref = create();
    l := new Ref;
    l.bit := false;
    var x : Bool = true;
    var y : Int = true;
    var z : Bool = x;
    x := 1;


    if (x == true) {
      var y = true;
    }

  }

  /* How to prove following spec? Lob induction? */ 
  
  proc acquire(l: Ref, implicit ghost b: Bool)
    atomic requires lockR(l, b)
    atomic ensures lockR(l, true)
  {
    var res: Bool = true;

    create();

    var ref = create();
    
    if (l.bit) {
        res := false;
     }
    
    else {
        res := true;
    }
    
    /*
    {!
      if (res) commit(phi);
      else abort(phi);
    !} */

    /* Have to formalize the ghost code language. */

    if (!res) acquire(l, true);
  }

  proc release(l: Ref)
    atomic requires lockR(l, true)
    atomic ensures lockR(l, false)
  {
    l.bit := false;

    /* Presumably the atomic open etc can be automatically inferred for such a simple case? */
  }
}

  module Trial[K: Lock] {
    import Lock

    proc trial(l: Ref) {
      l.(Lock.bit) := true;
      var ref : Ref = Lock.create();
      var myBool : Bool = Lock.l;

      acquire(l, true);
    }
  }

