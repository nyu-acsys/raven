module Lock {
  rep type t = struct {
    var bit: Bool
  }

  pred lockR(l: t, b: Bool) {
    own(l.bit, b)
  }

  proc create()
    returns (l: t)
    ensures lockR(l, false)
  {
    l := new t;
    l.bit := false;
  }

  /* How to prove following spec? Lob induction? */ 
  
  proc acquire(l: t, implicit ghost b: Bool)
    atomic requires lockR(l, b)
    atomic ensures lockR(l, true)
  {
    var phi: AtomicToken;
    phi := bindAU();
    var b: Bool; 
    b := openAU(phi);
    unfold lockR(l, b);
    var res = true;

    if (l.bit) { /* can use l.bit OR b*/
        res := false;
     }
    
    else {
        res := true;
    }

    {!
      if (res) commitAU(phi);
      else abortAU(phi);
    !}
    
    /* should we have to provide an implicit argument while calling?*/
    if (!res) acquire(l, true); 
  }

  proc release(l: t)
    atomic requires lockR(l, true)
    atomic ensures lockR(l, false)
  {
    l.bit := false;

    /* Presumably the atomic open etc can be automatically inferred for such a simple case? */
  }
}


