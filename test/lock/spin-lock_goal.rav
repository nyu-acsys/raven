module Lock {
  rep type T = Ref

  field bit: Bool

  pred lockR(l: T, b: Bool) {
    own(l, bit, b, 1.0)
  }

  proc create()
    returns (l: T)
    ensures lockR(l, false)
  {
    l := new(bit:false);
    fold lockR(l, false);
  }

  proc acquire(l: T, implicit ghost b: Bool)
    atomic requires lockR(l, b)
    atomic ensures lockR(l, true) && b == false
  {
    var phi: AtomicToken = bindAU();

    var res: Bool;

    openAU(phi);
    unfold lockR(l, b);

    res := cas(l.bit, false, true);

    fold lockR(l, true);

    {!
      if (res) commitAU(phi);
      else abortAU(phi);
    !}

    if (!res) {
      openAU(phi);
      acquire(l);
      commitAU(phi);
    }
  }

  proc release(l: Lock)
    atomic requires lockR(l, true)
    atomic ensures lockR(l, false)
  {
    val phi = bindAU();
    openAU(phi);
    unfold lockR(l, true);
    l.bit := false;
    fold lockR(l, false);
    commitAU(phi);
  }
}


