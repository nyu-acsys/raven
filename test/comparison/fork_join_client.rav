include "fork_join.rav"

module ForkJoinClient {

    field f: Int

    module ClientResource : ForkJoinResource {
        rep type T = Ref

        pred resource(r: T) {
            own(r.f, 1)
        }
    }

    module FJ = ForkJoin[ClientResource]

    // algorithms

    proc client_thread(l: Ref, fj: Ref, implicit ghost w: Int)
        requires FJ.is_join(fj) && own(l.f, w)
        ensures true
    {
        l.f := 1;
        fold ClientResource.resource(l);
        FJ.set(fj, l);
    }

    // adding exists fj: Ref :: FJ.is_join(fj)
    // to the postcondition because call to make_join
    // requires FJ.is_join() in the mask
    proc client()
        returns (res: Int)
        requires true
        ensures exists fj: Ref :: FJ.is_join(fj)
        ensures res == 1
    {
        var l: Ref;
        l := new(f: 0);
        var fj: Ref := FJ.make_join();
        spawn client_thread(l, fj);
        l := FJ.wait(fj);
        unfold ClientResource.resource(l);
        res := l.f;

        // assert to supply witness for the 
        // existential in the post-condition
        assert FJ.is_join(fj);
    }
}