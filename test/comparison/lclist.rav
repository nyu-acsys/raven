include "../concurrent/lock/lock.rav"

module LCList {

    field next: Ref
    field lock: Bool
    field value: Int

    pred is_list(x: Ref, v: Int) {
            (exists nx: Ref, b: Bool, vx: Int ::
                (x == null ? true : 
                (own(x.lock, b, 1.0) &&
                (b ? true : own(x.next, nx, 1.0) && own(x.value, vx, 1.0) 
                            && (v <= vx) && is_list(nx, vx))))) 
    }

    lemma is_list_null()
        ensures is_list(null, 0)
    {
        assume false;
    }

    proc create() 
        returns (hd: Ref)
        ensures is_list(hd, 0)
    {
        hd := new(next: null, lock: false, value: 0);
        is_list_null();
        fold is_list(hd, 0)[nx := null, b := false, vx := 0];
    }

    proc acquire(x: Ref, implicit ghost b: Bool)
        atomic requires own(x.lock, b, 1.0)
        atomic ensures own(x.lock, true, 1.0) && b == false
    {
        ghost val phi: AtomicToken := bindAU();
        b := openAU(phi);
        
        val res: Bool := cas(x.lock, false, true);

        {!
            if (res) {
                commitAU(phi);
            } else {
                abortAU(phi);
            }
        !}

        if (res) {
            return;
        } else {
            b := openAU(phi);
            acquire(x);
            commitAU(phi);
        }
    }

    proc release(x: Ref)
        atomic requires own(x.lock, true, 1.0)
        atomic ensures own(x.lock, false, 1.0)
    {
        ghost val phi: AtomicToken := bindAU();
        openAU(phi);
        x.lock := false;
        commitAU(phi);
        return;
    }

    proc traverse(p: Ref, c: Ref, k: Int, implicit ghost vp: Int)
        returns (n1: Ref, n2: Ref, implicit ghost vn1: Int, 
            implicit ghost vn2: Int, implicit ghost n3: Ref)
        requires own(p.lock, true, 1.0)
        requires own(p.next, c, 1.0) && own(p.value, vp, 1.0) 
        requires is_list(c, vp) && c != null
        ensures own(n1.lock, true, 1.0) 
        ensures own(n1.next, n2, 1.0) && own(n1.value, vn1, 1.0)
        ensures n2 != null ==> own(n2.lock, true, 1.0) 
        ensures n2 != null ==> own(n2.next, n3, 1.0) && own(n2.value, vn2, 1.0)
        ensures n2 != null ==> is_list(n3, vn2)
        ensures n2 != null ==> k <= vn2
    {
        unfold is_list(c, vp);
        acquire(c);
        var vc: Int := c.value;
        var n: Ref = c.next;
        if (k <= vc) {
            return (p, c, vp, vc, n);
        } else {
            release(p);
            if (n == null) {
                return (c, n, vc, 0, null);
            } else {
                var n1: Ref; var n2: Ref; 
                ghost var vn1: Int; ghost var vn2: Int; ghost var n3: Ref;
                n1, n2, vn1, vn2, n3 := traverse(c, n, k);
                return (n1, n2, vn1, vn2, n3);
            }
            
        }
    }

    proc find(hd: Ref, k: Int)
        returns (n1: Ref, n2: Ref, implicit ghost vn1: Int, 
            implicit ghost vn2: Int, implicit ghost n3: Ref)
        requires is_list(hd, 0) && hd != null
        ensures own(n1.lock, true, 1.0) 
        ensures own(n1.next, n2, 1.0) && own(n1.value, vn1, 1.0)
        ensures n2 != null ==> own(n2.lock, true, 1.0) 
        ensures n2 != null ==> own(n2.next, n3, 1.0) && own(n2.value, vn2, 1.0)
        ensures n2 != null ==> is_list(n3, vn2)
        ensures n2 != null ==> k <= vn2
    {
        unfold is_list(hd, 0);
        acquire(hd);
        var n: Ref := hd.next;

        if (n == null) {
            // assume false;
            ghost var vhd: Int := hd.value;
            assert own(hd.next, n, 1.0) && own(hd.value, vhd, 1.0);
            return (hd, n, vhd, 0, n);
        } else {
            var n1: Ref; var n2: Ref; 
            ghost var vn1: Int; ghost var vn2: Int; ghost var n3: Ref;
            n1, n2, vn1, vn2, n3 := traverse(hd, n, k);
            return n1, n2, vn1, vn2, n3;
        }
    }

    proc search(hd: Ref, k: Int)
        returns (res: Bool)
        requires is_list(hd, 0) && hd != null
        ensures true
    {
        var p: Ref; var c: Ref; 
        ghost var vp: Int; ghost var vc: Int; ghost var n: Ref;
        p, c, vp, vc, n := find(hd, k);

        if (c == null) {
            return false;
        } else {
            var v: Int := c.value;
            return (v == k);
        }
    }

    proc insert(hd: Ref, k: Int)
        returns (res: Bool)
        requires is_list(hd, 0) && hd != null
        ensures true
    {
        var p: Ref; var c: Ref; 
        ghost var vp: Int; ghost var vc: Int; ghost var n: Ref;
        p, c, vp, vc, n := find(hd, k);

        if (c == null) {
            var new_node: Ref;
            new_node := new(next: null, value: k, lock: false);
            p.next := new_node;
            return true;
        } else {
            var v: Int := c.value;
            if (v == k) {
                return false;
            } else {
                var new_node: Ref;
                new_node := new(next: c, value: k, lock: false);
                p.next := new_node;
                return true;
            }
        }
    }

    proc delete(hd: Ref, k: Int)
        returns (res: Bool)
        requires is_list(hd, 0) && hd != null
        ensures true
    {
        var p: Ref; var c: Ref; 
        ghost var vp: Int; ghost var vc: Int; ghost var n: Ref;
        p, c, vp, vc, n := find(hd, k);

        if (c == null) {
            return false;
        } else {
            var v: Int := c.value;
            if (v != k) {
                return false;
            } else {
                var cn: Ref := c.next;
                p.next := cn;
                return true;
            }
        }
    }    

}

