/* Encoding of arrays */

interface IArray {
  rep type T
  
  func loc(a: T, i: Int) returns (r: Ref)
  func len(a: T) returns (l: Int)
  func first(r: Ref) returns (a: T)
  func second(r: Ref) returns (i: Int)
  
  lemma all_diff(a: T, i: Int)
    ensures first(loc(a, i)) == a && second(loc(a, i)) == i
    
  lemma len_nonneg(a: T)
    ensures len(a) >= 0
}

module ArrayMax[Arr: IArray] {
  field val: Int

  define arr(a: Arr, m: Map<Int, Int>) {
    forall j: Int :: 0 <= j < len(a) ==> own(loc(a, j).val, (1, m[i]))
  }
  
  // old keyword?
  //define untouched(a: Arr) {
  //  forall j: Int :: 0 <= j < len(a) ==> loc(a, j).val == old(loc(a, j).val)
  //}
  
  define is_max(i: Int, m: Map<Int, Int>, u: Int) {
    forall j: Int :: 0 <= j && j < u ==> m[j] <= m[i]
  }
  
  proc max(a: Arr, implicit ghost m: Map<Int, Int>) 
    returns (x: Int)
    requires arr(a, m)
    ensures  arr(a, m)
    ensures  len(a) == 0 ? x == -1 : (0 <= x && x < len(a))
    ensures  is_max(x, m, len(a))
  {
    if (len(a) == 0) {
      x := -1
    } else {
      var y: Int
      x := 0;
      y := len(a) - 1;

      while (x != y)
        invariant arr(a, m)
        invariant 0 <= x && x <= y && y < len(a)
        invariant    (forall i: Int ::
                            ((0 <= i && i < x) || (y < i && i < len(a)))
                        ==> m[i] < m[x])
                  || (forall i: Int ::
                            ((0 <= i && i < x) || (y < i && i < len(a)))
                        ==> m[i] <= m[y])
      {
        if (loc(a, x).val <= loc(a, y).val) {
          x := x + 1
        } else {
          y := y - 1
        }
      }
    }
  }




(*
method client() {
  var a: IArray
  inhale len(a) == 3
  inhale access(a)
  inhale forall i: Int :: 0 <= i && i < len(a) ==> loc(a, i).val == i

  var x: Int
  x := max(a)

  assert loc(a, 0).val <= x

  assert x == loc(a, len(a) - 1).val
    /* Necessary to prove the final assertion (due to triggering) */

  assert x == 2

  assert loc(a, 1).val < x
}
*)


