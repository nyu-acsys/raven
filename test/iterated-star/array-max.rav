/* Encoding of arrays */

interface IArray {
  rep type T
  
  func loc(a: T, i: Int) returns (r: Ref)
  func len(a: T) returns (l: Int)
  func first(r: Ref) returns (a: T)
  func second(r: Ref) returns (i: Int)
  
  lemma all_diff(a: T, i: Int)
    ensures first(loc(a, i)) == a && second(loc(a, i)) == i
    
  lemma len_nonneg(a: T)
    ensures len(a) >= 0
}

module ArrayMax {
  field value: Int

  pred arr(a: IArray, m: Map[Int, Int]) {
    forall j: Int :: 0 <= j < IArray.len(a) ==> own(IArray.loc(a, j), value, m[j], 1)
  }
  
  var x: Int := 4

  // old keyword?
  //define untouched(a: Arr) {
  //  forall j: Int :: 0 <= j < len(a) ==> loc(a, j).value == old(loc(a, j).value)
  //}
  
  pred is_max(i: Int, m: Map[Int, Int], u: Int) {
    forall j: Int :: 0 <= j && j < u ==> m[j] <= m[i]
  }
  
  proc max(a: IArray, implicit ghost m: Map[Int, Int]) 
    returns (x: Int)
    requires arr(a, m)
    ensures  arr(a, m)
    ensures  IArray.len(a) == 0 ? x == -1 : (0 <= x && x < IArray.len(a))
    ensures  is_max(x, m, IArray.len(a))
  {
    if (IArray.len(a) == 0) {
      x := -1;
    } else {
      var y: Int;
      x := 0;
      y := IArray.len(a) - 1;

      while (x != y)
        invariant arr(a, m)
        invariant 0 <= x && x <= y && y < IArray.len(a)
        invariant    (forall i: Int ::
                            ((0 <= i && i < x) || (y < i && i < IArray.len(a)))
                        ==> m[i] < m[x])
                  || (forall i: Int ::
                            ((0 <= i && i < x) || (y < i && i < IArray.len(a)))
                        ==> m[i] <= m[y])
      {
        unfold arr(a,m);
        if (IArray.loc(a, x).value <= IArray.loc(a, y).value) {
          x := x + 1;
        } else {
          y := y - 1;
        }
        fold arr(a,m);
      }
    }
  }




/*
method client() {
  var a: IArray
  inhale len(a) == 3
  inhale access(a)
  inhale forall i: Int :: 0 <= i && i < len(a) ==> loc(a, i).value == i

  var x: Int
  x := max(a)

  assert loc(a, 0).value <= x

  assert x == loc(a, len(a) - 1).value
    /* Necessary to prove the final assertion (due to triggering) */

  assert x == 2

  assert loc(a, 1).value < x
}
*/
}


