/* Encoding of arrays */

interface IArray {
  rep type T
  
  func loc(a: T, i: Int) returns (r: Ref)
  func len(a: T) returns (l: Int)
  
  lemma all_diff()
    ensures forall a1:T, a2:T, i1: Int, i2: Int :: 
      loc(a1, i1) == loc(a2, i2) ==> a1 == a2 && i1 == i2 
    
  lemma len_nonneg()
    ensures forall a:T :: len(a) >= 0
}

module ArrayMax[Arr: IArray] {
  field value: Int

  pred arr(a: Arr, m: Map[Int, Int]) {
    forall j: Int :: 0 <= j < Arr.len(a) ==> own(Arr.loc(a, j), value, m[j], 1.0)
  }
  
  pred is_max(i: Int, m: Map[Int, Int], u: Int) {
    forall j: Int :: 0 <= j && j < u ==> m[j] <= m[i]
  }
  
  proc max(a: Arr, implicit ghost m: Map[Int, Int]) 
    returns (x: Int)
    requires arr(a, m)
    ensures  arr(a, m)
    ensures  Arr.len(a) == 0 ? x == -1 : (0 <= x && x < Arr.len(a))
    ensures  is_max(x, m, Arr.len(a))
  {
    if (Arr.len(a) == 0) {
      x := -1;
    } else {
      var y: Int;
      x := 0;
      y := Arr.len(a) - 1;

      while (x != y)
        invariant arr(a, m)
        invariant 0 <= x && x <= y && y < Arr.len(a)
        invariant (forall i: Int ::
                        ( (0 <= i && i < x) || (y < i && i < Arr.len(a)) )
                           ==> (m[i] < m[x] || m[i] <= m[y])
                        )
      {
        unfold arr(a,m);
        
        var tmp1 : Int  = Arr.loc(a, x).value;
        var tmp2 : Int = Arr.loc(a, y).value;
        
        if (tmp1 <= tmp2) {
          x := x + 1;
        } else {
          y := y - 1;
        }
        fold arr(a,m);
      }
    }

    fold is_max(x, m, Arr.len(a));
  }


  proc client() {
    var a: Arr;
    inhale Arr.len(a) == 3;

    var m: Map[Int, Int];
    m[0] := 1; m[1] := 2; m[2] := 3;

    inhale arr(a, m);

    var x: Int;
    x := max(a, m);

    {!
      unfold is_max(x, m, Arr.len(a));
      unfold arr(a,m);
    !}
    assert Arr.loc(a, 0).value < Arr.loc(a, x).value;

    assert x == 2;

    assert Arr.loc(a, 1).value < Arr.loc(a, x).value;
  }

}


