 
interface resource_algebra {
    rep type T

    val Elts: Set[T]
    val id: T
    val mult: T → T → T
    val valid: T → bool

    alias: a ∘ b = mult(a,b)

    lemma id_valid: id ∈ Elts
    lemma comp_assoc: ∀ a:T, b:T, c:T ; (a ∈ Elts) ∧ (b ∈ Elts) ∧ (c ∈ Elts) → (a ∘ b) ∘ c = a ∘ (b ∘ c)
    lemma comp_commute: ∀ a:T, b:T ; (a ∈ Elts) ∧ (b ∈ Elts) → a ∘ b = b ∘ a
    lemma cancellative: ∀ a:T, b:T c:T ; (a ∈ Elts) ∧ (b ∈ Elts) ∧ (c ∈ Elts) → (a ∘ b) = (c ∘ b) → a = c

    proc FPA(a:T, b:T)
        requires a
        requires a ∈ Elts ∧ b ∈ Elts
        requires ∀ c:T ; c ∈ Elts ∧ valid(a ∘ c) → valid(b ∘ c)
        ensures b
    {
        inhale a;
        exhale b;

        # How to actually make the state transition, while ensuring that the user does not have the power to inhale/exhale arbitrary asertions? Maybe have a special view_shift command that acts as a wrapper around inhale/exhale?

    }

    lemma FPA_helper(a:T, b:T): ∀ c:T ; c ∈ Elts ∧ valid(a ∘ c) → valid(b ∘ c)

    # lemma with arguments, only want to define it, not add the obligation of proving all instantiations of it 
}

module Nat : resource_algebra {
    rep type T = Nat

    val Elts = {| n : Nat :: true |}
    val id = 0

    # which style for function?
    val mult a b = a + b
    func valid(n) = true


    # which style for proving lemmas? Also have to develop assertion language?
    lemma id_valid with {# auto; #}

    proof comp_assoc: auto
}

module Frac : resource_algebra {
    rep type T = Frac

    val Elts = {| n : Frac :: 0 <= n && n <= 1 |}

    val id = 0

    a ∘ b = a + b
}

module Auth(T: Type, S: Set(T)) : resource_algebra {
    rep type (Set(T) )
}