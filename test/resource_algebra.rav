 
interface resource_algebra {
    rep type T

    val Elts: Set[T]
    val id: T
    func mult(a:T, b:T) : T
    func valid(a:T) : Bool

    alias : a ∘ b = mult(a,b)

    # Write lemmas in requires/ensures.

    lemma id_valid
        ensures id ∈ Elts

    # How to extend quantification from requires to ensures? Or just re-quantify?

    lemma comp_assoc
        requires ∀ a:T, b:T, c:T ; (a ∈ Elts) && (b ∈ Elts) && (c ∈ Elts)
        ensures (a ∘ b) ∘ c = a ∘ (b ∘ c)

    lemma comp_commute
        requires ∀ a:T, b:T ; (a ∈ Elts) && (b ∈ Elts)
        ensures a ∘ b = b ∘ a

    lemma cancellative
        requires ∀ a:T, b:T c:T ; (a ∈ Elts) && (b ∈ Elts) && (c ∈ Elts)
        requires (a ∘ b) = (c ∘ b)
        ensures (a = c)

    func FPU_condition(a:T, b:T) : Bool {
        # What to do with this implication?

        ∀ c:T ; c ∈ Elts && valid(a ∘ c) → valid(b ∘ c)
    } 

    # revisit parametrizing in terms of l, f.
    proc FPU(a:T, b:T, l, f)
        requires own(l.f, a)
        requires a ∈ Elts && b ∈ Elts

        requires FPU_condition(a,b)
        ------OR------
        requires ∀ c:T ; c ∈ Elts && valid(a ∘ c) → valid(b ∘ c)
            # explicit reference to FPU_condition makes it more natural to use it with actual resource algebras.

        ensures own(l.f, b)
    {
        exhale a;
        inhale b;
    }

}

module Nat : resource_algebra {
    rep type T = Nat

    val Elts = {| n : Nat :: true |}
    val id = 0

    func mult(a, b) { a+b }
    func valid(n) { true }


    # which style for proving lemmas? Also have to develop assertion language?
    lemma id_valid
        ensures id ∈ Elts
    {
        simpl 
        # can use simpl or auto as a keyword to do state consolidation and resolve proof obligations automatically.
    }

    lemma comp_assoc
        requires ∀ a:T, b:T, c:T ; (a ∈ Elts) && (b ∈ Elts) && (c ∈ Elts)
        ensures (a ∘ b) ∘ c = a ∘ (b ∘ c)
}

module Frac : resource_algebra {
    rep type T = Frac

    val Elts = {| n : Frac :: 0 <= n && n <= 1 |}

    val id = 0

    a ∘ b = a + b
}

module Auth(T: Type, S: Set(T)) : resource_algebra {
    rep type (Set(T) )
}