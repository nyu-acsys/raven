interface ResourceAlgebra {
    rep type T

    val id: T
    func comp(a:T, b:T) returns (ret:T)
    func valid(a:T) returns (ret: Bool)

    /* alias : a âˆ˜ b = comp(a,b) ? */

    lemma idValid()
        ensures valid(id)

    lemma compAssoc(a:T, b:T, c:T)
        ensures (comp(comp(a, b), c) == comp(a, comp(b, c)))

    lemma compCommute(a:T, b:T)
        ensures comp(a, b) == comp(b, a)
		
    lemma fpuUpdate(l:T, a:T, b:T)
        requires own(l, a)
        requires valid(a) && valid(b)
        requires (forall c:T :: (valid(comp(a, c)) ==> valid(comp(b, c))))
        ensures own(l, b)
        /* Should this be a lemma or something else? */
        
    
    lemma ownSep(l:Ref, f:T, a:T, b:T)
        requires own(l.f, comp(a, b))
        ensures own(l.f, a) && own(l.f, b)
}

module Nat : resource_algebra {
    rep type T = Int

    val id = 0

    func comp(a:T, b:T) returns (ret:T) { a+b }
    func valid(n:T) returns (ret:Bool) { n >= 0 ? true : false }


    lemma idValid()
        ensures valid(id)
    {}

    lemma compAssoc(a:T, b:T, c:T)
        ensures comp(comp(a, b), c) == comp(a, comp(b, c))
    {}
}

/*
module Frac : resource_algebra {
    rep type t = Frac

    val id = 0
    func comp(a: Frac, b: Frac) returns { ret := a + b }
}

*/

module Auth [M: ResourceAlgebra] : ResourceAlgebra {
    rep type T = data { 
        case frac(m:M); 
        case auth_frac(n1:M, n2:M);
        case top
    }
    
    val id = frac(M.id);

    func comp(a:T, b:T) 
        returns (ret:T) 
    {
        /* I think at present the front-end won't be able to deal with the use of an undeclared variable like m in the following line for deconstruction. Probably best to just implement case-matching. */
        /* But if we have case-matching then the following code will look much worse. */

        (a == frac(a.m) && b == frac(b.m))?
            (frac(M.comp(a.m,b.m))) :
        (((a == frac(a.m) && b == auth_frac(b.n1, b.n2)) || (a == auth_frac(a.n1, a.n2) && b == frac(b.m))))?
            auth_frac(n1, M.comp(m, n2)) :
            top
    }

    func valid(n:T) {
        !(n == top)
    }

    lemma idValid()
        ensures valid(id)
    {
        /* assert valid(id); 
        what to put here?*/
    }

    lemma compAssoc(a:T, b:T, c:T)
        ensures (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {

    }

    lemma compCommute(a:T, b:T)
        ensures comp(a, b) == comp(b, a)
    {

    }
		
    lemma fpu_update(l:T, a:T, b:T)
        requires own(l, a)
        requires valid(a) && valid(b)
        requires (forall c:T :: (valid(comp(a, c)) ==> valid(comp(b, c))))
        ensures own(l, b)
    {

    }
        
    
    lemma own_sep(l:Ref, f:T, a:T, b:T)
        requires own(l.f, comp(a, b))
        ensures own(l.f, a) && own(l.f, b)
    {
        
    }

}

interface LatticeResourceAlgebra : ResourceAlgebra {

}

interface CancellativeResourceAlgebra : Resource_algebra {
    lemma cancellative(a:T, b:T, c:T)
            requires (a in elts) && (b in elts) && (c in elts)
            requires comp(a, b) == comp(c, b)
            ensures (a == c)
}
