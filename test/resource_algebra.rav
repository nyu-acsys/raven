interface Resource_algebra {
    rep type t

    val id: t
    func comp(a:t, b:t) returns (ret:t)
    func valid(a:t) returns (ret: Bool)

    /* alias : a âˆ˜ b = comp(a,b) ? */

    lemma id_valid()
        ensures valid(id)

    lemma comp_assoc(a:t, b:t, c:t)
        ensures (comp(comp(a, b), c) == comp(a, comp(b, c)))

    lemma comp_commute(a:t, b:t)
        ensures comp(a, b) == comp(b, a)
		
		/* Add these lemmas as axioms
		lemma fpu_update(l:t, a:t, b:t)
        requires own(l, a)
        requires (a in elts) && (b in elts)
        requires (forall c:t :: (valid(comp(a, c)) ==> valid(comp(b, c))))
        ensures own(l, b)
    {
        exhale a;
        inhale b;
    }
    
    lemma own_sep(l:Ref, f:t, a:t, b:t)
      requires own(l.f, comp(a, b))
      ensures own(l.f, a) &*& own(l.f, b)
		*/


		/*
    lemma cancellative(a:t, b:t, c:t)
        requires (a in elts) && (b in elts) && (c in elts)
        requires comp(a, b) == comp(c, b)
        ensures (a == c)
		*/
}

module Nat : resource_algebra {
    rep type t = Int

    val id = 0

    func comp(a:t, b:t) returns (ret:t) { ret := a+b }
    func valid(n:t) returns (ret:Bool) { ret := n >= 0 ? true : false }


    lemma id_valid()
        ensures valid(id)
    {}

    lemma comp_assoc(a:t, b:t, c:t)
        ensures comp(comp(a, b), c) == comp(a, comp(b, c))
    {}
}

/*
module Frac : resource_algebra {
    rep type t = Frac

    val id = 0
    func comp(a: Frac, b: Frac) returns { ret := a + b }
}



module Auth(T: Type, S: Set(T)) : resource_algebra {
    rep type (Set(T) )
} */
