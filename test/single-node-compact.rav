module Lock {
  rep type T = Ref
  
  field bit: Bool
  
  pred lock(l: Ref, b: Bool) {
    own(l, bit, b, 1.0) 
  }

  proc create()
    returns (l: T)
    ensures lock(l, false)
  {
    l := new(bit:false);
    
    {! 
    	fold lock(l, false);
    !}
  }

  proc acquire(l: T, implicit ghost b: Bool)
    requires lock(l, b)
    ensures lock(l, true) // && b == false
  {
    {! 
    	unfold lock(l, b); 
    !}
    
    var res: Bool;

    if (l.bit) { /* can use l.bit OR b*/
      res := false;
     }
    
    else {
      res := true;
      l.bit := true;
    }

    {!
      if (res) {
      	fold lock(l, true);
        assert (lock(l, true) && b == false);
      } else {
      	fold lock(l, true);
      	assert(lock(l, b));
      }
    !}
    
    if (!res) {
    	acquire(l, b);
    }
  }

  proc release(l: T)
    requires lock(l, true)
    ensures lock(l, false)
  {
  	{! 
  		unfold lock(l, true);
  	!}
 
    l.bit := false;
    
    {!
    	fold lock(l, false);
      assert (lock(l, false));
    !}
  }
}


interface Keyspace {
  rep type T
  val ks: Set[T]
}

module SearchStructureSpec[K: Keyspace] {

  type Op = data { case searchOp; case insertOp; case deleteOp }

  pred opSpec(op: Op, k: K, c: Set[K], c1: Set[K], res: Bool) {
    op == searchOp() ?
      c1 == c && res == (k in c) :
    (op == insertOp() ?
      c1 == c ++ {|k|} && res == (k !in c) :
    
    // op == deleteOp 
      c1 == c -- {|k|} && res == (k in c)
    )
  }
}

interface NodeImpl[K: Keyspace] {
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type T

  pred nodeR(n: T, c: Set[Spec.K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Spec.Op, n: T, k: Spec.K, implicit ghost c: Set[Spec.K])
    returns (res: Bool, implicit ghost c1: Set[Spec.K])
    requires k in Spec.K.ks && nodeR(n, c)
    ensures nodeR(n, c1) && Spec.opSpec(dop, k, c, c1, res)
}

interface SearchStructure[K: Keyspace] {
  module Spec = SearchStructureSpec[K]
  type CSS

  pred cssR(r: CSS, c: Set[Spec.K])

  inv cssInv(r: CSS)

  proc create()
    returns (r: CSS)
    ensures cssInv(r) && cssR(r, {||})

  proc cssOp(dop: Spec.Op, r: CSS, k: Spec.K, implicit ghost c: Set[Spec.K])
    returns (res: Bool, implicit ghost c1: Set[Spec.K])
    requires k in Spec.K.ks && cssInv(r)
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c1) && Spec.opSpec(dop, k, c, c1, res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] /* : SearchStructure[K] */ {
  import Node

  module M_temp : Lib.Type {
    rep type T = Set[Node.Spec.K]
  }

  module FracSK = Lib.Frac[M_temp]

  type CSS = Ref
  
  
  field lock: Lock
  field node: Node
  
  //ghost fields
  field cont_lock: FracSK
  field cont_spec: FracSK
  
  pred nodePred(r: CSS, implicit ghost c: Set[Node.Spec.K]) {
    Node.nodeR(r.node, c) && own(r, cont_lock, FracSK.frac_chunk(c, 1.0/2.0))
  }

  pred cssAuth(r: CSS, c: Set[Node.Spec.K]) {
    own(r, cont_spec, FracSK.frac_chunk(c, 1.0/2.0))
  }

  pred cssR(r: CSS, c: Set[Node.Spec.K]) {
    own(r, cont_spec, FracSK.frac_chunk(c, 1.0/2.0))
  }

  pred cssInv(r: CSS, implicit ghost b: Bool, implicit ghost c: Set[Node.Spec.K]) {
    cssAuth(r, c)
    && own(r, cont_lock, FracSK.frac_chunk(c, 1.0/2.0))
    && Lock.lock(r.lock, b) && (b ? true : nodePred(r))
  }

  proc create()
    returns (r: CSS)
    ensures cssInv(r) && cssR(r, {||})
  {
    var l1: Lock;
    l1 := Lock.create();
    var n: Node = Node.create();
    
    r := new(lock:l1, node:n, cont_lock: FracSK.frac_chunk({||}, 1.0), cont_spec: FracSK.frac_chunk({||}, 1.0));
    
    {!   	 	 
    	fold cssAuth(r, {||});

      fold nodePred(r);

    	fold cssInv(r);

    	fold cssR(r, {||});
    !} 
  }

  proc cssOp(dop: Node.Spec.Op, r: CSS, k: Node.Spec.K, implicit ghost c: Set[Node.Spec.K])
    returns (res: Bool, implicit ghost c1: Set[Node.Spec.K])
    requires k in Node.Spec.K.ks
    requires cssInv(r)							
    requires cssR(r, c)
    ensures cssR(r, c1) && Node.Spec.opSpec(dop, k, c, c1, res)
  {
    var b0: Bool = false;
    var c0: Set[Node.Spec.K];

    {!
    	unfold cssInv(r, b0, c0);
    !}

    Lock.acquire(r.lock, b0);
    
    var c0_0: Set[Node.Spec.K];

    {!
    	assert b0 == false;
    	assert nodePred(r);
    	fold cssInv(r, true, c0);
    	unfold nodePred(r, c0_0);
    !}

    res, c1 := Node.decisiveOp(dop, r.node, k, c0_0);

    ghost var b1: Bool = true;
    ghost var c1_0: Set[Node.Spec.K];

		{!
      assert cssInv(r, b1, c1_0);
			unfold cssInv(r, b1, c1_0);

			fpu(r, cont_lock, FracSK.frac_chunk(c1, 1.0));

			fold nodePred(r, c1);
			
			unfold cssAuth(r, c0_0);
			unfold cssR(r, c);
			
      fpu(r, cont_spec, FracSK.frac_chunk(c1, 1.0));

			fold cssAuth(r, c1);
			fold cssR(r, c1);

			assert b1 == true;
			assert Lock.lock(r.lock, true);				
		!}

    Lock.release(r.lock);
    
    {!
    	fold cssInv(r, false, c1);
    !}    
  }
}
