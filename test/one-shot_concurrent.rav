module OneShotIntRA : Lib.ResourceAlgebra {
    rep type T = data {
        case zero;
        case pending;
        case done(i: Int);
        case top
    }

    val id: T = zero();

    func valid(n: T)
        returns (ret: Bool)
    {
        (n == top() ? false : true)
    }

    func comp(a:T, b:T)
        returns (ret:T)
    {
        a == zero() ? b :
            (b == zero() ? a :
        (a == done(a.i) && b == done(a.i) ? 
            done(a.i) :
            top()
        ))
    }

    func frame(a:T, b:T) returns (ret:T) 
    {
        b == zero() ? a :
        (a == pending() && b == pending() ?
            zero() :
            (a == done(a.i) && b == done(a.i) ?
                done(a.i) :
                top()
            ))
    }

    func fpuAllowed(a: T, b:T) returns (ret:Bool)
    {
        a == b ? true :
        (a == pending() && b == done(b.i) ?
            true : false
        )
        
    }
}

module Main {
    field f: Int
    field ghost_state: OneShotIntRA

    inv oneshot_inv(x: Ref) {
         exists n: Int, v: OneShotIntRA :: (own(x, f, n, 1.0) && own(x, ghost_state, v) 
            && ( 
              (n == 0 && v == OneShotIntRA.pending()) ||
              (n != 0 && v == OneShotIntRA.done(n)) 
            ))
    }

    proc main() {
        var x: Ref;
        x := new(f:0, ghost_state: OneShotIntRA.pending());

        one_time_update(x, 5);
    }

    proc one_time_update(x: Ref, k: Int)
        requires k != 0
        requires oneshot_inv(x)
    {
        val res: Bool;

        openInv oneshot_inv(x);
        res := cas(x.f, 0, k);
        {!
            if (res) fpu(x, ghost_state, OneShotIntRA.done(x.f));
        !}
        closeInv oneshot_inv(x);
    }
}


module Main {
    field f: Int

    proc main() {
        var x: Ref;
        x := new(f:0);

        one_time_update(x, 5);
    }

    proc one_time_update(x: Ref, k: Int)
        requires k != 0
        requires exists n: Int :: own(x, f, n, 1.0)
    {
        res := cas(x.f, 0, k);
    }
}