module RustValue: Library.Type {
  rep type T = data {
    case literalInt(v: Int);
    case literalBool(b: Int);
    case mutBorrow1(initialValueForMut: T, finalBorrowNameForMut1: Ref);
    case mutBorrow2(initialRefForMut: Ref, finalBorrowNameForMut2: Ref);
    case immutBorrow1(borrowNameForImmut: Ref);
    case immutBorrow2(valueForImmut: T);
    case rawPointer(referenceToPointed: Ref);
    case struct(lenForStruct: Int, mapForStruct: Map[Int, Ref]);
    case array(lenForArray: Int, mapForArray: Map[Int, Ref]);
    case uninit();
    case isDeref(borrowNameForDeref: Ref)
  }
}

module Option[X: Library.Type] {
  rep type T = data {
    case some(wrappedData: X);
    case none()
  }
}

// so do ensure that you do that.
ghost field resolvedValue: RustValue;
type ResolutionMap = Map[Ref, RustValue];
field value: RustValue;

// Tomorrow morning, wake up, and look at this.
// we need an isTypedBy for TypeTag.
module TypeTag {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isYoinked();
    case isBlocked(blockedRef: Ref, blockedTy: T);
    case isStructuredData()
  }
}

module TypeTrail {
  rep type T = data {
    case literalInt();
    case literalBool();
    case mutBorrow1(mutBorrow1Trail1: T, mutBorrow1Trail2: T);
    case mutBorrow2(mutBorrow2Trail1: T, mutBorrow2Trail2: T);
    case immutBorrow1(immutBorrow1Trail: T);
    case immutBorrow2(immutBorrow2Trail: T);
    case rawPointer();
    case struct(trailForStruct: Map[Int, T]);
    case array(trailForArray: Map[Int, T]);
    case uninit();
    case yoinked(trailForYoinked: Map[Int, T]);
    case structuredData(trailForSD: Map[Int, T])
  }
}

module Unit: Library.Type {
  rep type T = data { case unit() }
}

module UnitA = Library.Agree[Unit];

field ownProphecy: UnitA;

pred isProphecy(r: Ref) {
  own(r, ownProphecy, UnitA.agree(Unit.unit()))
}

pred resolvedProphecy(r: Ref, v: RustValue, m: ResolutionMap) {
  (m[r] == v)
}

proc resolveProphecy(r: Ref, v: RustValue, m: ResolutionMap)
  requires own(r, ownProphecy, UnitA.agree(Unit.unit()))
  ensures resolvedProphecy(r, v, m) {
  exhale own(r, ownProphecy, UnitA.agree(Unit.unit()));
  assume (m[r] == v);
  fold resolvedProphecy(r,v,m);
}

proc makeProphecy() returns (res: Ref) ensures isProphecy(res) {
  res := new (ownProphecy: UnitA.agree(Unit.unit()));
  fold isProphecy(res);
}

func derefsTo(x: RustValue, y: RustValue, m: ResolutionMap) returns (res: Bool) {
  (x == RustValue.isDeref(x.RustValue.borrowNameForDeref) && derefsTo(m[x.RustValue.borrowNameForDeref], y, m)) ||
  (x != RustValue.isDeref(x.RustValue.borrowNameForDeref) && x == y)
}

lemma derefsToSurj(x: RustValue, y: RustValue, z: RustValue, m: ResolutionMap)
 requires derefsTo(x, y, m) && derefsTo(x, z, m)
 ensures y == z {
 if (x == RustValue.isDeref(x.RustValue.borrowNameForDeref)) {
   derefsToSurj(m[x.RustValue.borrowNameForDeref], y, z, m);
 }
}

func refDerefsTo(r: Ref, y: RustValue, m: ResolutionMap) returns (res: Bool) {
  derefsTo(RustValue.isDeref(r), y, m)
}

interface DataInvariant {
  val lenForSD: Int;
  val mapForSD: Map[Int, TypeTag];

  pred dataInv(value: RustValue, m: ResolutionMap);

  lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInv(m[t.RustValue.borrowNameForDeref], m)
    ensures dataInv(t, m)

  lemma dataInvFromDerefsTo(x: RustValue, y: RustValue, m: ResolutionMap) requires derefsTo(x, y, m) && dataInv(y, m)
  ensures dataInv(x, m)
  {
    if (x == RustValue.isDeref(x.RustValue.borrowNameForDeref)) {
      dataInvFromDerefsTo(m[x.RustValue.borrowNameForDeref], y, m);
      dataInvFromBorrow(x, m);
    }
  }

  pred mutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail1: TypeTrail, trail2: TypeTrail) {
    (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
    &&
    typedByAtTrail(t.RustValue.initialValueForMut, tag.TypeTag.mutPointedType, m, trail1)
    &&
    typedByAtTrail(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m, trail2)
  }

  pred mutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail1: TypeTrail, trail2: TypeTrail) {
    (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
    &&
    typedByAtTrail(m[t.RustValue.initialRefForMut], tag.TypeTag.mutPointedType, m, trail1)
    &&
    typedByAtTrail(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m, trail2)
  }

  pred structIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: Map[Int, TypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.TypeTag.mapForStruct[i], m, trail[i], i))
  }

  pred isArrayIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: Map[Int, TypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
    ==>
    placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForArray[i]), tag.TypeTag.collectedType, m, trail[i], i))
  }

  pred isStructuredDataIsTypedBy(t: RustValue, m: ResolutionMap, trail: Map[Int, TypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    dataInv(t, m)
    &&
    ((forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    (placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), mapForSD[i], m, trail[i], i))))
  }

  pred isYoinkedIsTypedBy(t: RustValue, m: ResolutionMap, trail: Map[Int, TypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    ((forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    (placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), mapForSD[i], m, trail[i], i))))
  }

  pred maybeDeref1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTrail) {
    (t
    ==
    RustValue.isDeref(t.RustValue.borrowNameForDeref)
    &&
    typedByAtTrail((m[t.RustValue.borrowNameForImmut]), tag.TypeTag.sharedPointedType, m, trail))
  }

  pred maybeDeref2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTrail) {
    ((t != RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    typedByAtTrail(t, tag.TypeTag.sharedPointedType, m, trail))
  }

  pred immutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTrail) {
    (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
    &&
    (typedByAtTrail(m[t.RustValue.borrowNameForImmut], tag.TypeTag.sharedPointedType, m, trail))
  }

  pred immutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTrail) {
    (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
    &&
    typedByAtTrail(t.RustValue.valueForImmut, tag.TypeTag.sharedPointedType, m, trail)
  }

  pred placeTypedByAtIndex(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTrail, i: Int) {
    typedByAtTrail(t, tag, m, trail)
  }
  pred typedByAtTrail(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTrail) {
    exists pointed: RustValue ::
    derefsTo(t, pointed, m) &&
    ((trail == TypeTrail.literalInt()) ==> ((tag == TypeTag.isInt()) && (pointed == RustValue.literalInt(pointed.RustValue.v))))
    &&
    ((trail == TypeTrail.literalBool()) ==> ((tag == TypeTag.isBool()) && (pointed == RustValue.literalBool(pointed.RustValue.b))))
    &&
    ((trail == TypeTrail.rawPointer()) ==> ((tag == TypeTag.isRawPointer()) && (pointed == RustValue.rawPointer(pointed.RustValue.referenceToPointed))))
    &&
    ((trail == TypeTrail.immutBorrow1(trail.TypeTrail.immutBorrow1Trail)) ==> ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && immutBorrow1IsTypedBy(pointed, tag, m, trail.TypeTrail.immutBorrow1Trail)))
    &&
    ((trail == TypeTrail.immutBorrow2(trail.TypeTrail.immutBorrow2Trail)) ==> ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && immutBorrow2IsTypedBy(pointed, tag, m, trail.TypeTrail.immutBorrow2Trail)))
    &&
    ((trail == TypeTrail.mutBorrow1(trail.TypeTrail.mutBorrow1Trail1, trail.TypeTrail.mutBorrow1Trail2)) ==> ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && mutBorrow1IsTypedBy(pointed, tag, m, trail.TypeTrail.mutBorrow1Trail1, trail.TypeTrail.mutBorrow1Trail2)))
    &&
    ((trail == TypeTrail.mutBorrow2(trail.TypeTrail.mutBorrow2Trail1, trail.TypeTrail.mutBorrow2Trail2)) ==> ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && mutBorrow2IsTypedBy(pointed, tag, m, trail.TypeTrail.mutBorrow2Trail1, trail.TypeTrail.mutBorrow2Trail2)))
    &&
    ((trail == TypeTrail.array(trail.TypeTrail.trailForArray)) ==> ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) && isArrayIsTypedBy(pointed, tag, m, trail.TypeTrail.trailForArray)))
    &&
    ((trail == TypeTrail.uninit()) ==> ((tag == TypeTag.isUninit()) && (pointed == RustValue.uninit())))
    &&
    ((trail == TypeTrail.struct(trail.TypeTrail.trailForStruct)) ==> ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) && structIsTypedBy(pointed, tag, m, trail.TypeTrail.trailForStruct)))
    &&
    ((trail == TypeTrail.structuredData(trail.TypeTrail.trailForSD)) ==> ((tag == TypeTag.isStructuredData()) && isStructuredDataIsTypedBy(pointed, m, trail.TypeTrail.trailForSD)))
    &&
    ((trail == TypeTrail.yoinked(trail.TypeTrail.trailForYoinked)) ==> ((tag == TypeTag.isYoinked()) && isYoinkedIsTypedBy(pointed, m, trail.TypeTrail.trailForYoinked)))
  }

  pred typedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    exists trail: TypeTrail :: typedByAtTrail(t, tag, m, trail)
  }

  lemma placeTypeImpliesDataInv(xs: RustValue, m: ResolutionMap, trail: TypeTrail)
    requires typedByAtTrail(xs, TypeTag.isStructuredData(), m, trail)
    ensures typedBy(xs, TypeTag.isYoinked(), m) && dataInv(xs, m) {
    var pointed: RustValue;
    unfold typedByAtTrail(xs, TypeTag.isStructuredData(), m, trail)[pointed := pointed];
    if (trail == TypeTrail.structuredData(trail.TypeTrail.trailForSD)) {
      assert (isStructuredDataIsTypedBy(pointed, m, trail.TypeTrail.trailForSD));
      unfold isStructuredDataIsTypedBy(pointed, m, trail.TypeTrail.trailForSD);
      dataInvFromDerefsTo(xs, pointed, m);
      fold isYoinkedIsTypedBy(pointed, m, trail.TypeTrail.trailForSD);
      fold typedByAtTrail(xs, TypeTag.isYoinked(), m, TypeTrail.yoinked(trail.TypeTrail.trailForSD))[pointed := pointed];
      fold typedBy(xs, TypeTag.isYoinked, m)[trail := TypeTrail.yoinked(trail.TypeTrail.trailForSD)];
    }
 }
}

field place: RustValue;

module AgreeI = Library.Agree[Library.IntType];
interface VecI: DataInvariant {
  field pointedArr: RustValue;
  val tag: TypeTag;
  val lenForSD: Int = 3;
  val mapForSD: Map[Int, TypeTag] = {|i: Int :: (i == 0) ? TypeTag.isInt(): ((i == 1) ? TypeTag.isInt(): TypeTag.isRawPointer() )|};

  func isStructure(x: RustValue, structure: RustValue, m: ResolutionMap) returns (res: Bool) {
    derefsTo(x, structure, m) && x == RustValue.struct(x.RustValue.lenForStruct, x.RustValue.mapForStruct)
  }

  func isCapField(structure: RustValue, cap: Int, m: ResolutionMap) returns (res: Bool) {
    refDerefsTo(structure.RustValue.mapForStruct[0], RustValue.literalInt(cap), m)
  }

  lemma isCapFieldSurj(structure: RustValue, cap1: Int, cap2: Int, m: ResolutionMap)
    requires isCapField(structure, cap1, m) && isCapField(structure, cap2, m)
    ensures cap1 == cap2
  {
    derefsToSurj(RustValue.isDeref(structure.RustValue.mapForStruct[0]), RustValue.literalInt(cap1), RustValue.literalInt(cap2), m);
  }

  func isLenField(structure: RustValue, len: Int, m: ResolutionMap) returns (res: Bool) {
    refDerefsTo(structure.RustValue.mapForStruct[1], RustValue.literalInt(len), m)
  }

  lemma isLenFieldSurj(structure: RustValue, len1: Int, len2: Int, m: ResolutionMap)
    requires isLenField(structure, len1, m) && isLenField(structure, len2, m)
    ensures len1 == len2
  {
    derefsToSurj(RustValue.isDeref(structure.RustValue.mapForStruct[1]), RustValue.literalInt(len1), RustValue.literalInt(len2), m);
  }

  func isBufField(structure: RustValue, borrowName: Ref, m: ResolutionMap) returns (res: Bool) {
    refDerefsTo(structure.RustValue.mapForStruct[2], RustValue.rawPointer(borrowName), m)
  }

  lemma isBufFieldSurj(structure: RustValue, buf1: Ref, buf2: Ref, m: ResolutionMap)
    requires isBufField(structure, buf1, m) && isBufField(structure, buf2, m)
    ensures buf1 == buf2
  {
    derefsToSurj(RustValue.isDeref(structure.RustValue.mapForStruct[2]), RustValue.rawPointer(buf1), RustValue.rawPointer(buf2), m);
  }

  pred dataInv(rustValue: RustValue, m: ResolutionMap) {
    exists cap: Int, len: Int, borrowName: Ref, map: Map[Int, Ref] ::
    isCapField(rustValue, cap, m) &&
    isLenField(rustValue, len, m) &&
    len <= cap &&
    isBufField(rustValue, borrowName, m) &&
    typedBy(RustValue.isDeref(borrowName), TypeTag.isArrayOf(TypeTag.isMaybeInit(tag)), m) &&
    m[borrowName] == RustValue.array(cap, map) &&
    (forall i: Int :: exists v: RustValue ::
    refDerefsTo(map[i], v, m) &&
    ((0 <= i < len) ==> v != RustValue.uninit()) &&
    ((len <= i < cap) ==> v == RustValue.uninit()))
  }

  pred getUncheckedMutPre(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref, gammaI: Ref) {
    exists structure: RustValue ::
    own(gamma, ownProphecy, UnitA.agree(Unit.unit())) &&
    own(gammaI, ownProphecy, UnitA.agree(Unit.unit())) &&
    typedBy(xs, TypeTag.isStructuredData(), m) &&
    isStructure(xs, structure, m) &&
    isLenField(structure, len, m) &&
    isBufField(structure, gamma, m) &&
    (0 <= idx < len) &&
    isProphecy(gamma)
  }

  pred getUncheckedMutPost(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref, gammaI: Ref) {
    exists map: Map[Int, Ref] ::
    own(gammaI, ownProphecy, UnitA.agree(Unit.unit())) &&
    (m[gamma] == RustValue.array((m[gamma]).RustValue.lenForArray, map)) &&
    (map[idx] == gammaI) &&
    isProphecy(gammaI)
  }

  proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref, gammaI: Ref)
    requires getUncheckedMutPre(xs, idx, len, m, gamma, gammaI)
    ensures getUncheckedMutPost(xs, idx, len, m, gamma, gammaI)
  {
    var structure: RustValue;
    unfold getUncheckedMutPre(xs, idx, len, m, gamma, gammaI)[structure := structure];
    var trail: TypeTrail;
    unfold typedBy(xs, TypeTag.isStructuredData(), m)[trail := trail];
    var pointed: RustValue;
    unfold typedByAtTrail(xs, TypeTag.isStructuredData(), m, trail)[pointed := pointed];
    if (trail == TypeTrail.structuredData(trail.TypeTrail.trailForSD)) {
      unfold isStructuredDataIsTypedBy(pointed, m, trail.TypeTrail.trailForSD);
      dataInvFromDerefsTo(xs, pointed, m);
      fold isYoinkedIsTypedBy(pointed, m, trail.TypeTrail.trailForSD);
      fold typedByAtTrail(xs, TypeTag.isYoinked(), m, TypeTrail.yoinked(trail.TypeTrail.trailForSD))[pointed := pointed];
      fold typedBy(xs, TypeTag.isYoinked, m)[trail := TypeTrail.yoinked(trail.TypeTrail.trailForSD)];
    }
    var cap: Int;
    var len1: Int;
    var borrowName: Ref;
    var map: Map[Int, Ref];
    unfold dataInv(pointed, m)[cap := cap, len1 := len, borrowName := borrowName, map := map];
    isBufFieldSurj(structure, gamma, borrowName, m);
    isLenFieldSurj(structure, len, len1, m);
    exhale own(gamma, ownProphecy, UnitA.agree(Unit.unit()));
    assume (m[gamma] == RustValue.array(cap, map[idx := gammaI]));
    resolveProphecy(gamma, RustValue.array(cap, map[idx := gammaI]), m);
    fold isProphecy(gammaI);
    fold getUncheckedMutPost(xs, idx, len, m, gamma, gammaI)[map := map];
  }
}
