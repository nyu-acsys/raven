module RustValue: Library.Type {
  rep type T = data {
    case literalInt(v: Int);
    case literalBool(b: Int);
    case mutBorrow1(initialValueForMut: T, finalBorrowNameForMut1: Ref);
    case mutBorrow2(initialRefForMut: Ref, finalBorrowNameForMut2: Ref);
    case immutBorrow1(borrowNameForImmut: Ref);
    case immutBorrow2(valueForImmut: T);
    case rawPointer(referenceToPointed: Ref);
    case struct(lenForStruct: Int, mapForStruct: Map[Int, Ref]);
    case array(lenForArray: Int, mapForArray: Map[Int, Ref]);
    case uninit();
    case isDeref(borrowNameForDeref: Ref)
  }
}

module Option[X: Library.Type] {
  rep type T = data {
    case some(wrappedData: X);
    case none()
  }
}

// so do ensure that you do that.
ghost field resolvedValue: RustValue;
type ResolutionMap = Map[Ref, RustValue];
field value: RustValue;

module TypeTag {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isYoinked(indexYoinked: Int);
    case isBlocked(blockedRef: Ref, blockedTy: T);
    case isStructuredData(indexStructured: Int)
  }
}

module TypeTagTrail {
  rep type T = data {
    case literalInt();
    case literalBool();
    case mutBorrow1(mutBorrow1Trail1: T, mutBorrow1Trail2: T);
    case mutBorrow2(mutBorrow2Trail1: T, mutBorrow2Trail2: T);
    case immutBorrow1(immutBorrow1Trail: T);
    case immutBorrow2(immutBorrow2Trail: T);
    case rawPointer();
    case struct(trailForStruct: Map[Int, T]);
    case array(trailForArray: Map[Int, T]);
    case uninit();
    case isDeref(derefTrail: T);
    case yoinked(trailForYoinked: Map[Int, T]);
    case structuredData(trailForSD: Map[Int, T])
  }
}

module Unit: Library.Type {
  rep type T = data { case unit() }
}

module UnitA = Library.Agree[Unit];

field ownProphecy: UnitA;

pred isProphecy(r: Ref) {
  own(r, ownProphecy, UnitA.agree(Unit.unit()))
}

pred resolvedProphecy(r: Ref, v: RustValue, m: ResolutionMap) {
  (m[r] == v)
}

proc resolveProphecy(r: Ref, v: RustValue, m: ResolutionMap)
  requires own(r, ownProphecy, UnitA.agree(Unit.unit()))
  ensures resolvedProphecy(r, v, m) {
  exhale own(r, ownProphecy, UnitA.agree(Unit.unit()));
  assume (m[r] == v);
  fold resolvedProphecy(r,v,m);
}

proc makeProphecy() returns (res: Ref) ensures isProphecy(res) {
  res := new (ownProphecy: UnitA.agree(Unit.unit()));
  fold isProphecy(res);
}

interface DataInvariants {
  val lensForSD: Map[Int, Int];
  val mapsForSD: Map[Int, Map[Int, TypeTag]];
  pred dataInvs(i: Int, value: RustValue, m: ResolutionMap);
  lemma dataInvFromBorrow(i: Int, t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInvs(i, m[t.RustValue.borrowNameForDeref], m)
    ensures dataInvs(i, t, m)

  pred mutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail1: TypeTagTrail, trail2: TypeTagTrail) {
    (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
    &&
    typedByAtTrail(t.RustValue.initialValueForMut, tag.TypeTag.mutPointedType, m, trail1)
    &&
    typedByAtTrail(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m, trail2)
  }

  pred mutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail1: TypeTagTrail, trail2: TypeTagTrail) {
    (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
    &&
    typedByAtTrail(m[t.RustValue.initialRefForMut], tag.TypeTag.mutPointedType, m, trail1)
    &&
    typedByAtTrail(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m, trail2)
  }

  pred structIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: Map[Int, TypeTagTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    typedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.TypeTag.mapForStruct[i], m, trail[i], i))
  }

  pred isArrayIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: Map[Int, TypeTagTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
    ==>
    typedByAtIndex(RustValue.isDeref(t.RustValue.mapForArray[i]), tag.TypeTag.collectedType, m, trail[i], i))
  }

  pred isStructuredDataIsTypedBy(i: Int, t: RustValue, m: ResolutionMap, trail: Map[Int, TypeTagTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lensForSD[i] == t.RustValue.lenForStruct)
    &&
    dataInvs(i, t, m)
    &&
    ((forall j: Int :: (0 <= j < t.RustValue.lenForStruct)
    ==>
    (typedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[j]), mapsForSD[i][j], m, trail[j], j))))
  }

  pred isYoinkedIsTypedBy(i: Int, t: RustValue, m: ResolutionMap, trail: Map[Int, TypeTagTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lensForSD[i] == t.RustValue.lenForStruct)
    &&
    ((forall j: Int :: (0 <= j < t.RustValue.lenForStruct)
    ==>
    (typedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[j]), mapsForSD[i][j], m, trail[j], j))))
  }

  pred maybeDeref1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTagTrail) {
    (t
    ==
    RustValue.isDeref(t.RustValue.borrowNameForDeref)
    &&
    typedByAtTrail((m[t.RustValue.borrowNameForImmut]), tag.TypeTag.sharedPointedType, m, trail))
  }

  pred maybeDeref2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTagTrail) {
    ((t != RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    typedByAtTrail(t, tag.TypeTag.sharedPointedType, m, trail))
  }

  pred immutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTagTrail) {
    (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
    &&
    (typedByAtTrail(m[t.RustValue.borrowNameForImmut], tag.TypeTag.sharedPointedType, m, trail))
  }

  pred immutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTagTrail) {
    (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
    &&
    typedByAtTrail(t.RustValue.valueForImmut, tag.TypeTag.sharedPointedType, m, trail)
  }

  pred typedByAtIndex(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTagTrail, i: Int) {
    typedByAtTrail(t, tag, m, trail)
  }

  pred typedByAtTrail(t: RustValue, tag: TypeTag, m: ResolutionMap, trail: TypeTagTrail) {
    ((trail == TypeTagTrail.isDeref(trail.TypeTagTrail.derefTrail)) ==> (t == RustValue.isDeref(t.RustValue.borrowNameForDeref)) && typedByAtTrail(m[t.RustValue.borrowNameForDeref], tag, m, trail.TypeTagTrail.derefTrail))
    &&
    ((trail == TypeTagTrail.literalInt()) ==> ((tag == TypeTag.isInt()) && (t == RustValue.literalInt(t.RustValue.v))))
    &&
    ((trail == TypeTagTrail.literalBool()) ==> ((tag == TypeTag.isBool()) && (t == RustValue.literalBool(t.RustValue.b))))
    &&
    ((trail == TypeTagTrail.rawPointer()) ==> ((tag == TypeTag.isRawPointer()) && (t == RustValue.rawPointer(t.RustValue.referenceToPointed))))
    &&
    ((trail == TypeTagTrail.immutBorrow1(trail.TypeTagTrail.immutBorrow1Trail)) ==> ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && immutBorrow1IsTypedBy(t, tag, m, trail.TypeTagTrail.immutBorrow1Trail)))
    &&
    ((trail == TypeTagTrail.immutBorrow2(trail.TypeTagTrail.immutBorrow2Trail)) ==> ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && immutBorrow2IsTypedBy(t, tag, m, trail.TypeTagTrail.immutBorrow2Trail)))
    &&
    ((trail == TypeTagTrail.mutBorrow1(trail.TypeTagTrail.mutBorrow1Trail1, trail.TypeTagTrail.mutBorrow1Trail2)) ==> ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && mutBorrow1IsTypedBy(t, tag, m, trail.TypeTagTrail.mutBorrow1Trail1, trail.TypeTagTrail.mutBorrow1Trail2)))
    &&
    ((trail == TypeTagTrail.mutBorrow2(trail.TypeTagTrail.mutBorrow2Trail1, trail.TypeTagTrail.mutBorrow2Trail2)) ==> ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && mutBorrow2IsTypedBy(t, tag, m, trail.TypeTagTrail.mutBorrow2Trail1, trail.TypeTagTrail.mutBorrow2Trail2)))
    &&
    ((trail == TypeTagTrail.array(trail.TypeTagTrail.trailForArray)) ==> ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) && isArrayIsTypedBy(t, tag, m, trail.TypeTagTrail.trailForArray)))
    &&
    ((trail == TypeTagTrail.uninit()) ==> ((tag == TypeTag.isUninit()) && (t == RustValue.uninit())))
    &&
    ((trail == TypeTagTrail.struct(trail.TypeTagTrail.trailForStruct)) ==> ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) && structIsTypedBy(t, tag, m, trail.TypeTagTrail.trailForStruct)))
    &&
    ((trail == TypeTagTrail.structuredData(trail.TypeTagTrail.trailForSD)) ==> ((tag == TypeTag.isStructuredData(tag.TypeTag.indexStructured)) && isStructuredDataIsTypedBy(tag.TypeTag.indexStructured, t, m, trail.TypeTagTrail.trailForSD)))
    &&
    ((trail == TypeTagTrail.yoinked(trail.TypeTagTrail.trailForYoinked)) ==> ((tag == TypeTag.isYoinked(tag.TypeTag.indexYoinked)) && isYoinkedIsTypedBy(tag.TypeTag.indexYoinked, t, m, trail.TypeTagTrail.trailForYoinked)))
  }

  pred typedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    exists trail: TypeTagTrail :: typedByAtTrail(t, tag, m, trail)
  }

  lemma typeImpliesDataInv(i: Int, xs: RustValue, m: ResolutionMap, trail: TypeTagTrail)
    requires typedByAtTrail(xs, TypeTag.isStructuredData(i), m, trail)
    ensures typedBy(xs, TypeTag.isYoinked(i), m) && dataInvs(i, xs, m) {
    unfold typedByAtTrail(xs,TypeTag.isStructuredData(i),m,trail);
    if (trail == TypeTagTrail.isDeref(trail.TypeTagTrail.derefTrail)){
      assert (xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref));
      assert typedByAtTrail(m[xs.RustValue.borrowNameForDeref],
        TypeTag.isStructuredData(i),
        m,
        trail.TypeTagTrail.derefTrail);
      typeImpliesDataInv(i, m[xs.RustValue.borrowNameForDeref], m, trail.TypeTagTrail.derefTrail);
      dataInvFromBorrow(i, xs, m);
      var newTrail: TypeTagTrail;
      unfold typedBy(m[xs.RustValue.borrowNameForDeref],TypeTag.isYoinked(i), m)[newTrail := trail];
      fold typedByAtTrail(xs,TypeTag.isYoinked(i), m, TypeTagTrail.isDeref(newTrail));
      fold typedBy(xs, TypeTag.isYoinked(i), m)[trail := TypeTagTrail.isDeref(newTrail)];
    } else if (trail == TypeTagTrail.structuredData(trail.TypeTagTrail.trailForSD)) {
      assert (isStructuredDataIsTypedBy(i, xs, m, trail.TypeTagTrail.trailForSD));
      unfold isStructuredDataIsTypedBy(i, xs,m,trail.TypeTagTrail.trailForSD);
      fold isYoinkedIsTypedBy(i, xs,m,trail.TypeTagTrail.trailForSD);
      fold typedByAtTrail(xs,TypeTag.isYoinked(i),m,TypeTagTrail.yoinked(trail.TypeTagTrail.trailForSD));
      fold typedBy(xs,TypeTag.isYoinked(i),m)[trail := TypeTagTrail.yoinked(trail.TypeTagTrail.trailForSD)];
    }
  }
}

field place: RustValue;

func derefsTo(x: RustValue, y: RustValue, m: ResolutionMap) returns (res: Bool) {
  (x == RustValue.isDeref(x.RustValue.borrowNameForDeref) && derefsTo(m[x.RustValue.borrowNameForDeref], y, m)) ||
  (x != RustValue.isDeref(y.RustValue.borrowNameForDeref) && x == y)
}

func refDerefsTo(ref: Ref, y: RustValue, m: ResolutionMap) returns (res: Bool) {
  derefsTo(RustValue.isDeref(ref), y, m)
}

interface GenericTypeTag {
  rep type T = data {
    case unit()
  }
  val tag: TypeTag;
}

interface Main[G: GenericTypeTag]: DataInvariants {
  field rustData: RustValue;
  pred placeTypedBy(l: Ref, v: RustValue, tag: TypeTag);
  axiom unfoldPlaceTypedBy(l: Ref, v: RustValue, tag: TypeTag, m: ResolutionMap)
    requires placeTypedBy(l, v, tag) && own(l, rustData, v)
    ensures typedBy(v, tag, m);
  axiom foldPlaceTypedBy(l: Ref, v: RustValue, tag: TypeTag, m: ResolutionMap)

  module RawVec[G: GenericTypeTag] {
    field pointedBuf: RustValue;
    val lenForSD: Int = 2;
    val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};
    val typeID: Int = 0;
    func isBufField(xs: RustValue, buf: Ref, m: ResolutionMap) returns (res: Bool) {
      (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
      refDerefsTo(xs.RustValue.mapForStruct[0], RustValue.rawPointer(buf), m)
    }
    func isCapField(xs: RustValue, cap: Int, m: ResolutionMap) returns (res: Bool) {
      (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
      refDerefsTo(xs.RustValue.mapForStruct[1], RustValue.literalInt(cap), m)
    }
    pred dataInv(xs: RustValue, m: ResolutionMap) {
      exists structure: RustValue, bufField: Ref, capField: Int, buf: RustValue, zs: RustValue ::
        derefsTo(xs, structure, m) &&
        isBufField(structure, bufField, m) &&
        isCapField(structure, capField, m) &&
        own(bufField, pointedBuf, buf, 1.0) &&
        typedBy(buf, TypeTag.isArrayOf(G.tag), m)
    }
    lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
      requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
      &&
      dataInv(m[t.RustValue.borrowNameForDeref], m)
      ensures dataInv(t, m) {
      var structure: RustValue;
      var bufField: Ref;
      var capField: Int;
      var buf: RustValue;
      var zs: RustValue;
      unfold dataInv(m[t.RustValue.borrowNameForDeref], m)[structure := structure, bufField := bufField, capField := capField, buf := buf, zs := zs];
      assert (derefsTo(t, structure, m));
      fold dataInv(t, m)[structure := structure, bufField := bufField, capField := capField, buf := buf, zs := zs];
    }
  }

  // module Vec[G: GenericTypeTag] {
  //   module RawVecI = RawVec[G];
  //   field pointedBuf: RustValue;
  //   val lenForSD: Int = 2;
  //   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isStructuredData(RawVecI.typeID) : TypeTag.isInt() |};
  //   val typeID: Int = 1;
  //   // func isRawVecField(xs: RustValue, rawVec: RustValue, m: ResolutionMap) returns (res: Bool) {
  //   //   (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
  //   //   refDerefsTo(xs.RustValue.mapForStruct[0], RustValue.rawPointer(rawVec), m)
  //   // }
  //   // func isLenField(xs: RustValue, len: Int, m: ResolutionMap) returns (res: Bool) {
  //   //   (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
  //   //   refDerefsTo(xs.RustValue.mapForStruct[1], RustValue.literalInt(len), m)
  //   // }
  //   pred dataInv(xs: RustValue, m: ResolutionMap) { true }
  //   // pred dataInv(xs: RustValue, m: ResolutionMap) {
  //   //   exists structure: RustValue, bufField: Ref, capField: Int, buf: RustValue, zs: RustValue ::
  //   //     derefsTo(xs, structure, m) &&
  //   //     isBufField(structure, bufField, m) &&
  //   //     isCapField(structure, capField, m) &&
  //   //     own(bufField, pointedBuf, buf, 1.0) &&
  //   //     typedBy(buf, TypeTag.isArrayOf(G.tag), m)
  //   // }
  //   lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
  //     requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
  //     &&
  //     dataInv(m[t.RustValue.borrowNameForDeref], m)
  //     ensures dataInv(t, m) {
  //     var structure: RustValue;
  //     var bufField: Ref;
  //     var capField: Int;
  //     var buf: RustValue;
  //     var zs: RustValue;
  //     unfold dataInv(m[t.RustValue.borrowNameForDeref], m)[structure := structure, bufField := bufField, capField := capField, buf := buf, zs := zs];
  //     assert (derefsTo(t, structure, m));
  //     fold dataInv(t, m)[structure := structure, bufField := bufField, capField := capField, buf := buf, zs := zs];
  //   }
  // }

  // module VecI = Vec[G];
  module RawVecI = RawVec[G];
  val lensForSD: Map[Int, Int] = {| i: Int :: i == RawVecI.typeID ? 1 : 1 |};
  val mapsForSD: Map[Int, Map[Int, TypeTag]] = {| i: Int :: i == RawVecI.typeID ? RawVecI.mapForSD : RawVecI.mapForSD |}
  pred dataInvs(i: Int, v: RustValue, m: ResolutionMap) {
    RawVecI.dataInv(v, m)
  }
  lemma dataInvFromBorrow(i: Int, t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInvs(i, m[t.RustValue.borrowNameForDeref], m)
    ensures dataInvs(i, t, m) {
    if (i == RawVecI.typeID) {
      unfold dataInvs(i, m[t.RustValue.borrowNameForDeref], m);
      RawVecI.dataInvFromBorrow(t, m);
      fold dataInvs(i, t, m);
    } else {
      unfold dataInvs(i, m[t.RustValue.borrowNameForDeref], m);
      RawVecI.dataInvFromBorrow(t, m);
      fold dataInvs(i, t, m);
    }
  }
}

// module RawVec[G: GenericTypeTag, I: DataInvariants] {
//   field pointedBuf: RustValue;
//   val lenForSD: Int = 2;
//   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};
//   func isBufField(xs: RustValue, buf: Ref, m: ResolutionMap) returns (res: Bool) {
//     (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
//     refDerefsTo(xs.RustValue.mapForStruct[0], RustValue.rawPointer(buf), m)
//   }

//   func isCapField(xs: RustValue, cap: Int, m: ResolutionMap) returns (res: Bool) {
//     (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
//     refDerefsTo(xs.RustValue.mapForStruct[1], RustValue.literalInt(cap), m)
//   }

//   pred dataInv(xs: RustValue, m: ResolutionMap) {
//     exists structure: RustValue, bufField: Ref, capField: Int, buf: RustValue, zs: RustValue ::
//       derefsTo(xs, structure, m) &&
//       isBufField(structure, bufField, m) &&
//       isCapField(structure, capField, m) &&
//       own(bufField, pointedBuf, buf, 1.0) &&
//       I.typedBy(buf, TypeTag.isArrayOf(G.tag), m)
//   }
// }

// module VecI[G: GenericTypeTag, I: DataInvariants] {
//   module RawVecInst = RawVec[G, I];
  
// }

// module Main[G: GenericTypeTag]: DataInvariants {
//   field pointedBuf: RustValue;
//   val lenForSD: Int = 2;
//   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};

// }

// interface VecI[G: GenericTypeTag]: DataInvariant {
//   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};
// }

// interface VecI: DataInvariant {
//   field pointedArr: RustValue;
//   val tag: TypeTag;
//   val vecType: TypeTag = TypeTag.isStructOf(3, {|i: Int :: (i == fCap) ? TypeTag.isInt(): ((i == fLen) ? TypeTag.isInt(): TypeTag.isArrayOf(tag))|});

//   val lenForSD: Int = 1;
//   val mapForSD: Map[Int, TypeTag] = {|i: Int :: TypeTag.isRawPointer()|};
//   func isUnderlying(xs: RustValue, len: )

//   func derefsTo(x: RustValue, y: RustValue, m: ResolutionMap) returns (res: Bool) {
//     (x == RustValue.isDeref(x.RustValue.borrowNameForDeref) && derefsTo(m[x.RustValue.borrowNameForDeref], y, m)) ||
//     (x != RustValue.isDeref(y.RustValue.borrowNameForDeref) && x == y)
//   }

//   func refDerefsTo(ref: Ref, y: RustValue, m: ResolutionMap) returns (res: Bool) {
//     derefsTo(RustValue.isDeref(ref), y, m)
//   }


//   func isCap(raw: Ref, cap: Int) {
//     refDerefsTo(raw, )
//   }

//   func isLen(raw: Ref, len: Int) {
//     refDerefsTo(Ref, )
//   }

//   pred dataInvForStruct(rustValue: RustValue, m: ResolutionMap) {
//     (m[rustValue.RustValue.mapForStruct[0]] == RustValue.rawPointer((m[rustValue.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed))
//     &&
//     (exists cap: Int :: (exists arr: RustValue :: exists len: Int :: own(rustValue.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len))
//     &&
//     (isProphecy(rustValue.RustValue.referenceToPointed)
//     &&
//     typedBy((m[rustValue.RustValue.referenceToPointed]), vecType, m)
//     &&
//     (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fCap]] == RustValue.literalInt(cap))
//     &&
//     (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fLen]] == RustValue.literalInt(len))
//     &&
//     (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fArr]] == arr)
//     &&
//     (forall i: Int :: (0 <= i < len)
//     ==>
//     ((m[arr.RustValue.mapForArray[i]] != RustValue.uninit())))
//     &&
//     (forall i: Int :: (len <= i < cap)
//     ==>
//     (m[arr.RustValue.mapForArray[i]] == RustValue.uninit())))))
//   }

//   pred dataInv(rustValue: RustValue, m: ResolutionMap) {
//     (rustValue == RustValue.isDeref(rustValue.RustValue.borrowNameForDeref) ==> dataInv(m[rustValue.RustValue.borrowNameForDeref], m))
//     &&
//     (rustValue == RustValue.struct(1, rustValue.RustValue.mapForStruct) ==> dataInvForStruct(rustValue, m))
//     &&
//     ((rustValue != RustValue.isDeref(rustValue.RustValue.borrowNameForDeref) && rustValue != RustValue.struct(1, rustValue.RustValue.mapForStruct) ==> false))
//   }

//   pred isReborrowedAtIndex(rustValue: RustValue, idx: Int, prophecy: Ref, m: ResolutionMap) {
//     ((rustValue == RustValue.isDeref(rustValue.RustValue.borrowNameForDeref))
//     ==>
//     isReborrowedAtIndex(m[rustValue.RustValue.borrowNameForDeref], idx, prophecy, m))
//     &&
//     ((rustValue == RustValue.rawPointer(rustValue.RustValue.referenceToPointed))
//     ==>
//     (isProphecy(prophecy) && (exists arr: RustValue :: m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fArr]] == arr && (m[arr.RustValue.mapForArray[i]] == m[prophecy]))))
//     &&
//     (((rustValue != RustValue.isDeref(rustValue.RustValue.borrowNameForDeref))
//     &&
//     (rustValue != RustValue.rawPointer(rustValue.RustValue.referenceToPointed)))
//     ==>
//     false)
//   }

//   pred isReborrowedWithProphecy(xs: RustValue, idx: Int, m: ResolutionMap) {
//     exists prophecy: Ref :: isReborrowedAtIndex(xs, idx, prophecy, m)
//   }

//   pred isVectorStruct(xs: RustValue, len: Int, m: ResolutionMap) {
//     exists trail: TypeTagTrail :: own(xs.RustValue.mapForStruct[fArr], pointedCap, AgreeI.agree(len))
//     &&
//     typedByAtTrail(xs, TypeTag.isStructuredData(), m, trail)
//     &&
//     isProphecy((m[xs.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed)
//   }

//   pred isVector(xs: RustValue, len: Int, m: ResolutionMap) {
//     ((xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref))
//     ==>
//     isVector(m[xs.RustValue.borrowNameForDeref], len, m))
//     &&
//     ((xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct))
//     ==>
//     isVectorStruct(xs, len, m))
//     &&
//     (((xs != RustValue.isDeref(xs.RustValue.borrowNameForDeref)) && (xs != RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct))) ==> false)
//   }

//   proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap)
//     requires typedBy(xs, TypeTag.isStructuredData(), m)
//     requires exists ys: RustValue ::
//              derefsTo(xs, ys, m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[0].RustValue.mapForStruct[fLen],
//                          RustValue.literalInt(len), m) &&
//              isProphecy(ys.RustValue.mapForArray[0])
//     ensures typedBy(xs, TypeTag.isStructuredData(), m)
//     requires exists ys: RustValue, cap: Int, arr: RustValue ::
//              derefsTo(xs, ys, m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[fLen], RustValue.literalInt(len), m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[fCap], RustValue.literalInt(cap), m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[fArr], RustValue.array(cap, arr), m) &&
//              isProphecy(ys.RustValue.mapForArray[fArr], )
//   {
//   }
//   // proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap)
//   //   requires isVector(xs, len, m) && (0 <= idx < len)
//   //   // TODO change isVector to isBorrowedVector -- we've consumed the prophecy variable
//   //   ensures isVector(xs, len, m) && isReborrowedWithProphecy(xs, idx, m) {
//   //   unfold   isVector(xs,len,m);
//   //   if (xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref)){
//   //     getUncheckedMut(m[xs.RustValue.borrowNameForDeref], idx, len, m);
//   //     var prophecy: Ref;
//   //     unfold   isReborrowedWithProphecy(m[xs.RustValue.borrowNameForDeref],idx,m)[prophecy := prophecy];
//   //     fold isReborrowedAtIndex(xs,idx,prophecy,m);
//   //     fold isReborrowedWithProphecy(xs,idx,m)[prophecy := prophecy];
//   //     fold isVector(xs,len,m);
//   //   } else {
//   //     var trail: TypeTagTrail;
//   //     unfold   isVectorStruct(xs,len,m)[trail := trail];
//   //     placeTypeImpliesDataInv(xs, m, trail);
//   //     unfold  dataInv(xs, m);
//   //     var cap: Int;
//   //     var arr: RustValue;
//   //     var len: Int;
//   //     unfold  dataInvForStruct(xs, m)[cap := cap, arr := arr, len := len];
//   //     var finalValueAtIndex: RustValue;
//   //     havoc finalValueAtIndex;
//   //     assume typedBy(finalValueAtIndex, tag);
//   //     res := new (ownProphecy: UnitA.agree(Unit.unit()));
//   //     assume (m[res] == finalValueAtIndex);
//   //     fold isProphecy(res);
//   //     resolveProphecy(arr.RustValue.referenceToPointed, , m)
//   //     assume false;
//   //     //
//   //   }
//   // }
// }
