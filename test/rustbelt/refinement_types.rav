module TypeTag: Library.Type {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isBoxedPointer(boxedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isMaybeDeref(potentiallyReferencedType: T)
  }
}

module RustValue: Library.Type {
  module AgreeTag = Library.Agree[TypeTag];
  field typeTag: AgreeTag;
  rep type T = data {
    case literalInt(v: Int);
    case literalBool(b: Int);
    case mutBorrow1(initialValueForMut: T, finalBorrowNameForMut1: Ref);
    case mutBorrow2(initialRefForMut: Ref, finalBorrowNameForMut2: Ref);
    case immutBorrow1(borrowNameForImmut: Ref);
    case immutBorrow2(valueForImmut: T);
    case boxed1(borrowNameForBoxed: Ref);
    case boxed2(valueForBoxed: T);
    case rawPointer(referenceToPointed: Ref);
    case struct(lenForStruct: Int, mapForStruct: Map[Int, Ref]);
    case array(lenForArray: Int, mapForArray: Map[Int, Ref]);
    case uninit();
    case isDeref(borrowNameForDeref: Ref)
  }
}

module Option[X: Library.Type] {
  rep type T = data {
    case some(wrappedData: X);
    case none()
  }
}

// so do ensure that you do that.
ghost field resolvedValue: RustValue;
type ResolutionMap = Map[Ref, RustValue];
field value: RustValue;

func mutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
  &&
  isTypedBy(t.RustValue.initialValueForMut, tag.TypeTag.mutPointedType, m)
  &&
  isTypedBy((m[t.RustValue.finalBorrowNameForMut2]), tag.TypeTag.mutPointedType, m)
}

func mutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
  &&
  isTypedBy(m[t.RustValue.initialRefForMut], tag.TypeTag.mutPointedType, m)
  &&
  isTypedBy(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m)
}

func immutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
  &&
  isTypedBy(m[t.RustValue.borrowNameForImmut], tag.TypeTag.sharedPointedType, m)
}

func immutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
  &&
  isTypedBy(t.RustValue.valueForImmut, tag.TypeTag.sharedPointedType, m)
}

func boxed1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.boxed1(t.RustValue.borrowNameForBoxed))
  &&
  isTypedBy(m[t.RustValue.borrowNameForImmut], tag.TypeTag.boxedPointedType, m)
}

func boxed2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.boxed2(t.RustValue.valueForImmut))
  &&
  isTypedBy(t.RustValue.valueForImmut, tag.TypeTag.boxedPointedType, m)
}

// lenForStruct: Int, mapForStruct: Map[Int, T]
func structIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
  &&
  (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
  &&
  isTypedBy(RustValue.isDeref(t.RustValue.mapForStruct[i]), TypeTag.isMaybeDeref(tag.TypeTag.mapForStruct[i]), m))
}

func arrayIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.array(t.RustValue.lenForArray, t.RustValue.mapForArray))
  &&
  (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
  &&
  isTypedBy(RustValue.isDeref(t.RustValue.mapForArray[i]), TypeTag.isMaybeDeref(tag.TypeTag.collectedType), m))
}

func maybeDerefIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t
  ==
  RustValue.isDeref(t.RustValue.borrowNameForDeref)
  &&
  (isTypedBy(m[t.RustValue.borrowNameForDeref], tag.TypeTag.potentiallyReferencedType, m)))
  ||
  (t != RustValue.isDeref(t.RustValue.borrowNameForDeref) && isTypedBy(t, tag.TypeTag.potentiallyReferencedType, m))
}

func isTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  ((t == RustValue.isDeref(t.RustValue.borrowNameForDeref)) && (isTypedBy(m[t.RustValue.borrowNameForDeref], tag, m)))
  ||
  ((tag == TypeTag.isInt()) && (t == RustValue.literalInt(t.RustValue.v)))
  ||
  ((tag == TypeTag.isBool()) && (t == RustValue.literalBool(t.RustValue.b)))
  ||
  ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && (mutBorrow1IsTypedBy(t, tag, m) || mutBorrow2IsTypedBy(t, tag, m)))
  ||
  ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && (immutBorrow1IsTypedBy(t, tag, m) || immutBorrow2IsTypedBy(t, tag, m)))
  ||
  ((tag == TypeTag.isBoxedPointer(tag.TypeTag.boxedPointedType)) && (boxed1IsTypedBy(t, tag, m) || boxed2IsTypedBy(t, tag, m)))
  ||
  ((tag == TypeTag.isRawPointer()) && (t == RustValue.rawPointer(t.RustValue.referenceToPointed)))
  ||
  ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) && structIsTypedBy(t, tag, m))
  ||
  ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) && arrayIsTypedBy(t, tag, m))
  ||
  (tag == TypeTag.isUninit() && t == RustValue.uninit())
  ||
  (tag == TypeTag.isMaybeInit(tag.TypeTag.potentiallyInitializedType) && (t == RustValue.uninit() || isTypedBy(t, tag.TypeTag.potentiallyInitializedType, m)))
  ||
  ((tag == TypeTag.isMaybeDeref(tag.TypeTag.potentiallyReferencedType)) && maybeDerefIsTypedBy(t, tag, m))
}

// Tomorrow morning, wake up, and look at this.
// we need an isTypedBy for PlaceType.
module PlaceType {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isBoxedPointer(boxedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isMaybeDeref(potentiallyReferencedType: T);
    case isYoinked(yoinkedValue: RustValue, yoinkedTy: T);
    case isBlocked(blockedRef: Ref, blockedTy: T);
    case isStructuredData(lenSD: Int, mapForSD: Map[Int, T])
  }
}

module PlaceTypeTrail {
  rep type T = data {
    case literalInt();
    case literalBool();
    case mutBorrow1(mutBorrow1Trail1: T, mutBorrow1Trail2: T);
    case mutBorrow2(mutBorrow2Trail1: T, mutBorrow2Trail2: T);
    case immutBorrow1(immutBorrow1Trail: T);
    case immutBorrow2(immutBorrow2Trail: T);
    case boxed1(boxed1Trail: T);
    case boxed2(boxed2Trail: T);
    case rawPointer();
    case struct(trailForStruct: Map[Int, I]);
    case array(trailForArray: Map[Int, I]);
    case maybeInit1();
    case maybeInit2(maybeInit2Trail: T);
    case uninit();
    case maybeDeref1(maybeDeref1Trail: T);
    case maybeDeref2(maybeDeref2Trail: T);
    case isDeref(derefTrail: T)
    case yoinked(trailForYoinked: Map[Int, I])
  }

  // I for indexed
  type I = data {
    case tagged(index: Int, placeTag: T)
  }
}

field programValue: RustValue;
pred locationTypedBy(ref: Ref, tag: TypeTag, m: ResolutionMap) {
  exists pVal: RustValue :: own(ref, programValue, pVal) && isTypedBy(pVal, tag, m)
}

module Unit: Library.Type {
  rep type T = data { case unit()}
}

module UnitA = Library.Agree[Unit];

field ownProphecy: UnitA;

pred isProphecy(r: Ref) {
  own(r, ownProphecy, UnitA.agree(Unit.unit()))
}

pred resolvedProphecy(r: Ref, v: RustValue, m: ResolutionMap) {
  (m[r] == v)
}

proc resolveProphecy(r: Ref, v: RustValue, m: ResolutionMap)
  requires own(r, ownProphecy, UnitA.agree(Unit.unit()))
  ensures resolvedProphecy(r, v, m) {
  exhale own(r, ownProphecy, UnitA.agree(Unit.unit()));
  assume (m[r] == v);
  fold resolvedProphecy(r,v,m);
}

proc makeProphecy() returns (res: Ref) ensures isProphecy(res) {
  res := new (ownProphecy: UnitA.agree(Unit.unit()));
  fold isProphecy(res);
}

interface DataInvariant {
  pred dataInv(value: RustValue, m: ResolutionMap);

  lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInv(m[t.RustValue.borrowNameForDeref], m)
    ensures dataInv(t, m)

  pred mutBorrow1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail1: PlaceTypeTrail, trail2: PlaceTypeTrail) {
    (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
    &&
    placeTypedBy(t.RustValue.initialValueForMut, tag.PlaceType.mutPointedType, m, trail1)
    &&
    placeTypedBy(m[t.RustValue.finalBorrowNameForMut2], tag.PlaceType.mutPointedType, m, trail2)
  }

  pred mutBorrow2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail1: PlaceTypeTrail, trail2: PlaceTypeTrail) {
    (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
    &&
    placeTypedBy(m[t.RustValue.initialRefForMut], tag.PlaceType.mutPointedType, m, trail1)
    &&
    placeTypedBy(m[t.RustValue.finalBorrowNameForMut2], tag.PlaceType.mutPointedType, m, trail2)
  }

  pred boxed1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.boxed1(t.RustValue.borrowNameForBoxed))
    &&
    placeTypedBy(m[t.RustValue.borrowNameForImmut], tag.PlaceType.boxedPointedType, m, trail)
  }

  pred boxed2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.boxed2(t.RustValue.valueForImmut))
    &&
    placeTypedBy(t.RustValue.valueForImmut, tag.PlaceType.boxedPointedType, m, trail)
  }

  pred structIsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail.I]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    placeTypedBy(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.PlaceType.mapForStruct[i], m, (trail[i]).PlaceTypeTrail.placeTag) && ((trail[i]).PlaceTypeTrail.index == i))
  }

  pred arrayIsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail.I]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
    ==>
    placeTypedBy(RustValue.isDeref(t.RustValue.mapForArray[i]), tag.PlaceType.collectedType, m, (trail[i]).PlaceTypeTrail.placeTag) && (trail[i]).PlaceTypeTrail.index == i)
  }

  pred isYoinkedTy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    ((forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    placeTypedBy(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.PlaceType.mapForSD[i], m, trail[i])))
  }

  pred isStructuredDataIsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail.I]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    dataInv(t, m)
    &&
    ((forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    placeTypedBy(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.PlaceType.mapForSD[i], m, (trail[i]).PlaceTypeTrail.placeTag) && ((trail[i]).PlaceTypeTrail.index == i)))
  }

  pred maybeDeref1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.isDeref(t.RustValue.borrowNameForDeref)
    &&
    placeTypedBy((m[t.RustValue.borrowNameForImmut]), tag.PlaceType.sharedPointedType, m, trail))
  }

  pred maybeDeref2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    ((t != RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    placeTypedBy(t, tag.PlaceType.sharedPointedType, m, trail))
  }

  pred immutBorrow1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
    &&
    (placeTypedBy(m[t.RustValue.borrowNameForImmut], tag.PlaceType.sharedPointedType, m, trail))
  }

  pred immutBorrow2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
    &&
    placeTypedBy(t.RustValue.valueForImmut, tag.PlaceType.sharedPointedType, m, trail)
  }

  pred placeTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    ((trail == PlaceTypeTrail.isDeref(trail.PlaceTypeTrail.derefTrail)) ==> (t == RustValue.isDeref(t.RustValue.borrowNameForDeref)) && placeTypedBy(m[t.RustValue.borrowNameForDeref], tag, m, trail.PlaceTypeTrail.derefTrail))
    &&
    ((trail == PlaceTypeTrail.literalInt()) ==> ((tag == PlaceType.isInt()) && (t == RustValue.literalInt(t.RustValue.v))))
    &&
    ((trail == PlaceTypeTrail.literalBool()) ==> ((tag == PlaceType.isBool()) && (t == RustValue.literalBool(t.RustValue.b))))
    &&
    ((trail == PlaceTypeTrail.rawPointer()) ==> ((tag == PlaceType.isRawPointer()) && (t == RustValue.rawPointer(t.RustValue.referenceToPointed))))
    &&
    ((trail == PlaceTypeTrail.immutBorrow1(trail.PlaceTypeTrail.immutBorrow1Trail)) ==> ((tag == PlaceType.isSharedBorrow(tag.PlaceType.sharedPointedType)) && immutBorrow1IsTypedBy(t, tag, m, trail.PlaceTypeTrail.immutBorrow1Trail)))
    &&
    ((trail == PlaceTypeTrail.immutBorrow2(trail.PlaceTypeTrail.immutBorrow2Trail)) ==> ((tag == PlaceType.isSharedBorrow(tag.PlaceType.sharedPointedType)) && immutBorrow2IsTypedBy(t, tag, m, trail.PlaceTypeTrail.immutBorrow2Trail)))
    &&
    ((trail == PlaceTypeTrail.mutBorrow1(trail.PlaceTypeTrail.mutBorrow1Trail1, trail.PlaceTypeTrail.mutBorrow1Trail2)) ==> ((tag == PlaceType.isMutBorrow(tag.PlaceType.mutPointedType)) && mutBorrow1IsTypedBy(t, tag, m, trail.PlaceTypeTrail.mutBorrow1Trail1, trail.PlaceTypeTrail.mutBorrow1Trail1)))
    &&
    ((trail == PlaceTypeTrail.mutBorrow2(trail.PlaceTypeTrail.mutBorrow2Trail1, trail.PlaceTypeTrail.mutBorrow2Trail2)) ==> ((tag == PlaceType.isMutBorrow(tag.PlaceType.mutPointedType)) && mutBorrow2IsTypedBy(t, tag, m, trail.PlaceTypeTrail.mutBorrow2Trail1, trail.PlaceTypeTrail.mutBorrow2Trail2)))
    &&
    ((trail == PlaceTypeTrail.array(trail.PlaceTypeTrail.trailForArray)) ==> ((tag == PlaceType.isArrayOf(tag.PlaceType.collectedType)) && arrayIsTypedBy(t, tag, m, trail.PlaceTypeTrail.trailForArray)))
    &&
    ((trail == PlaceTypeTrail.uninit()) ==> ((tag == PlaceType.isUninit()) && (t == RustValue.uninit())))
    &&
    ((trail == PlaceTypeTrail.maybeInit1()) ==> ((tag == PlaceType.isMaybeInit(tag.PlaceType.potentiallyInitializedType)) && (t == RustValue.uninit())))
    &&
    ((trail == PlaceTypeTrail.maybeInit2(trail.PlaceTypeTrail.maybeInit2Trail)) ==> (tag == PlaceType.isMaybeInit(tag.PlaceType.potentiallyInitializedType)) && placeTypedBy(t, tag.PlaceType.potentiallyInitializedType, m, trail.PlaceTypeTrail.maybeInit2Trail))
    &&
    ((trail == PlaceTypeTrail.maybeDeref1(trail.PlaceTypeTrail.maybeDeref1Trail)) ==> (tag == PlaceType.isMaybeDeref(tag.PlaceType.potentiallyInitializedType)) && maybeDeref1IsTypedBy(t, tag, m, trail.PlaceTypeTrail.maybeDeref1Trail))
    &&
    ((trail == PlaceTypeTrail.maybeDeref2(trail.PlaceTypeTrail.maybeDeref2Trail)) ==> (tag == PlaceType.isMaybeDeref(tag.PlaceType.potentiallyInitializedType)) && maybeDeref2IsTypedBy(t, tag, m, trail.PlaceTypeTrail.maybeDeref2Trail))
    &&
    ((trail == PlaceTypeTrail.struct(trail.PlaceTypeTrail.trailForStruct)) ==> ((tag == PlaceType.isStructOf(tag.PlaceType.len, tag.PlaceType.mapForStruct)) && structIsTypedBy(t, tag, m, trail.PlaceTypeTrail.trailForStruct)))
    &&
    ((trail == PlaceTypeTrail.array(trail.PlaceTypeTrail.trailForArray)) ==> ((tag == PlaceType.isStructuredData(tag.PlaceType.len, tag.PlaceType.mapForStruct)) && isStructuredDataIsTypedBy(t, tag, m, trail.PlaceTypeTrail.trailForStruct)))
    &&
    ((trail == PlaceTypeTrail.yoinked(trail.PlaceTypeTrail.trailForYoinked)) ==> ((tag == PlaceType.isYoinked(tag.PlaceType.yoinkedValue, tag.PlaceType.yoinkedTy)) && structIsTypedBy(t, tag, m, trail.PlaceTypeTrail.trailForYoinked)))
  }

  field placedValue: RustValue;

  pred placeValueTypedBy(r: Ref, tag: PlaceType, m: ResolutionMap) {
    exists value: RustValue, trail: PlaceTypeTrail :: own(r, placedValue, value) && placeTypedBy(value, tag, m, trail)
  }

  func fromTypeTag(tag: TypeTag) returns (res: PlaceType) {
    (tag == TypeTag.isInt()) ? PlaceType.isInt(): //
    ((tag == TypeTag.isBool()) ? PlaceType.isBool(): //
    ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) ? PlaceType.isSharedBorrow(fromTypeTag(tag.TypeTag.sharedPointedType)): //
    ((tag == TypeTag.isBoxedPointer(tag.TypeTag.boxedPointedType)) ? PlaceType.isBoxedPointer(fromTypeTag(tag.TypeTag.boxedPointedType)): //
    ((tag == TypeTag.isRawPointer()) ? PlaceType.isRawPointer(): //
    ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) ? PlaceType.isStructOf(tag.TypeTag.len, {|i: Int :: fromTypeTag(tag.TypeTag.mapForStruct[i])|}): //
    ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) ? PlaceType.isArrayOf(fromTypeTag(tag.TypeTag.collectedType)): //
    ((tag == TypeTag.isUninit()) ? PlaceType.isUninit(): //
    ((tag == TypeTag.isMaybeInit(tag.TypeTag.potentiallyInitializedType)) ? PlaceType.isMaybeInit(fromTypeTag(tag.TypeTag.potentiallyInitializedType)): //
    PlaceType.isMaybeDeref(fromTypeTag(tag.TypeTag.potentiallyReferencedType))))))))))
  }
}

field place: RustValue;

module AgreeI = Library.Agree[Library.IntType];
interface VecI: DataInvariant {
  field pointedCap: AgreeI;
  field pointedArr: RustValue;
  val tag: TypeTag;
  val vecType: TypeTag = TypeTag.isStructOf(3, {|i: Int :: (i == 0) ? TypeTag.isInt(): ((i == 1) ? TypeTag.isInt(): TypeTag.isArrayOf(tag))|});

  pred dataInv(rustValue: RustValue, m: ResolutionMap) {
    (rustValue == RustValue.struct(1, rustValue.RustValue.mapForStruct))
    &&
    (m[rustValue.RustValue.mapForStruct[0]] == RustValue.rawPointer((m[rustValue.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed))
    &&
    (exists cap: Int :: (exists arr: RustValue :: exists len: Int :: own(rustValue.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len))
    &&
    (isProphecy(rustValue.RustValue.referenceToPointed)
    &&
    isTypedBy((m[rustValue.RustValue.referenceToPointed]), vecType, m)
    &&
    (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[0]] == RustValue.literalInt(cap))
    &&
    (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[1]] == RustValue.literalInt(len))
    &&
    (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[2]] == arr)
    &&
    (forall i: Int :: (0 <= i < len)
    ==>
    ((m[arr.RustValue.mapForArray[i]] != RustValue.uninit())))
    &&
    (forall i: Int :: (len <= i < cap)
    ==>
    (m[arr.RustValue.mapForArray[i]] == RustValue.uninit())))))
  }

  pred isReborrowedAtIndex(rustValue: RustValue, idx: Int, prophecy: Ref, m: ResolutionMap) {
    isProphecy(prophecy)
    &&
    (rustValue == RustValue.rawPointer(rustValue.RustValue.referenceToPointed))
    &&
    (exists arr: RustValue :: m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[2]] == arr && (m[arr.RustValue.mapForArray[i]] == m[prophecy]))
  }

  lemma placeTypeImpliesDataInv(xs: RustValue, pty: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail)
  requires placeTypedBy(xs, PlaceType.isStructuredData(1, {|i: Int :: PlaceType.isRawPointer()|}), m, trail)
    ensures dataInv(xs, m) {
    unfold placeTypedBy(xs,PlaceType.isStructuredData(1, {|i: Int :: PlaceType.isRawPointer()|}),m, trail);
    if (trail == PlaceTypeTrail.isDeref(trail.PlaceTypeTrail.derefTrail)) {
      assert (xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref));
      assert placeTypedBy(m[xs.RustValue.borrowNameForDeref],
        PlaceType.isStructuredData(1, {|i: Int :: PlaceType.isRawPointer()|}),
        m,
        trail.PlaceTypeTrail.derefTrail);
      placeTypeImpliesDataInv(m[xs.RustValue.borrowNameForDeref], pty, m, trail.PlaceTypeTrail.derefTrail);
      assert dataInv(m[xs.RustValue.borrowNameForDeref], m);
      dataInvFromBorrow(xs, m);
    } else if (0 < i < 14){
      assert false;
    } else if (i > 14){
      assume false;
    } else {
      unfold isStructuredDataIsTypedBy(xs, pty, m, trail.PlaceTypeTrail.trailForStruct);
    }
  }

  proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap)
    requires own(xs.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len))
    &&
    (0 <= idx < len)
    &&
    (exists trail: PlaceTypeTrail :: placeTypedBy(xs, PlaceType.isStructuredData(1, {| i: Int :: PlaceType.isRawPointer() |}), m, trail))
    &&
    isProphecy((m[xs.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed)
  // ensures (exists prophecy: Ref ::
  //          own(xs.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len)) &&
  //          (0 <= idx < len) &&
  //          isReborrowedAtIndex(xs, idx, prophecy, m))
  {
    // assert (exists trail: PlaceTypeTrail :: placeTypedBy(xs, PlaceType.isStructuredData(1, {|i: Int :: PlaceType.isRawPointer()|}), m, trail));
    // assert dataInv(xs, m);
    var xsPlace: Ref := new(place: xs);
  }
}
