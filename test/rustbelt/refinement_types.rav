// TODO:
// Construct an instance of the array.
// Write up the _modified code_ + _modified annotations_ that translate to this code.
// Explain why these are already "place types".

module RustValue: Library.Type {
  rep type T = data {
    case literalInt(v: Int);
    case literalBool(b: Int);
    case mutBorrow1(initialValueForMut: T, finalBorrowNameForMut1: Ref);
    case mutBorrow2(initialRefForMut: Ref, finalBorrowNameForMut2: Ref);
    case immutBorrow1(borrowNameForImmut: Ref);
    case immutBorrow2(valueForImmut: T);
    case rawPointer(referenceToPointed: Ref);
    case struct(lenForStruct: Int, mapForStruct: Map[Int, T]);
    case array(lenForArray: Int, mapForArray: Map[Int, T]);
    case uninit();
    case isDeref(borrowNameForDeref: Ref)
  }
}

module Option[X: Library.Type] {
  rep type T = data {
    case some(wrappedData: X);
    case none()
  }
}

// so do ensure that you do that.
ghost field resolvedValue: RustValue;
type ResolutionMap = Map[Ref, RustValue];
field value: RustValue;

// Tomorrow morning, wake up, and look at this.
// we need an isTypedBy for TypeTag.
module TypeTag {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isYoinked();
    case isBlocked(blockedRef: Ref, blockedTy: T);
    case isStructuredData()
  }
}

module Unit: Library.Type {
  rep type T = data { case unit()}
}

module UnitA = Library.Agree[Unit];

field ownProphecy: UnitA;

pred isProphecy(r: Ref) {
  own(r, ownProphecy, UnitA.agree(Unit.unit()))
}

pred resolvedProphecy(r: Ref, v: RustValue, m: ResolutionMap) {
  (m[r] == v)
}

proc resolveProphecy(r: Ref, v: RustValue, m: ResolutionMap)
  requires isProphecy(r)
  ensures resolvedProphecy(r, v, m) {
  unfold isProphecy(r);
  exhale own(r, ownProphecy, UnitA.agree(Unit.unit()));
  assume (m[r] == v);
  fold resolvedProphecy(r, v, m);
}

proc makeProphecy() returns (res: Ref) ensures isProphecy(res) {
  res := new (ownProphecy: UnitA.agree(Unit.unit()));
  fold isProphecy(res);
}

func derefsTo(x: RustValue, y: RustValue, m: ResolutionMap) returns (res: Bool ) {
  (x == RustValue.isDeref(x.RustValue.borrowNameForDeref) && derefsTo(m[x.RustValue.borrowNameForDeref], y, m))
  ||
  (x != RustValue.isDeref(x.RustValue.borrowNameForDeref) && x == y)
}

lemma derefsToSurj(x: RustValue, y: RustValue, z: RustValue, m: ResolutionMap)
  requires derefsTo(x, y, m) && derefsTo(x, z, m)
  ensures y == z {
  if (x == RustValue.isDeref(x.RustValue.borrowNameForDeref)) {
    derefsToSurj(m[x.RustValue.borrowNameForDeref], y, z, m);
  }
}

func refDerefsTo(r: Ref, y: RustValue, m: ResolutionMap) returns (res: Bool ) {
  derefsTo(RustValue.isDeref(r), y, m)
}

interface DataInvariant {
  val lenForSD: Int;
  val mapForSD: Map[Int, TypeTag];

  pred dataInv(value: RustValue, m: ResolutionMap);

  lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInv(m[t.RustValue.borrowNameForDeref], m)
    ensures dataInv(t, m)

  lemma dataInvFromDerefsTo(x: RustValue, y: RustValue, m: ResolutionMap) requires derefsTo(x, y, m) && dataInv(y, m)
    ensures dataInv(x, m) {
    if (x == RustValue.isDeref(x.RustValue.borrowNameForDeref)) {
      dataInvFromDerefsTo(m[x.RustValue.borrowNameForDeref], y, m);
      dataInvFromBorrow(x, m);
    }
  }

  pred mutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
    &&
    typedBy(t.RustValue.initialValueForMut, tag.TypeTag.mutPointedType, m)
    &&
    typedBy(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m)
  }

  pred mutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
    &&
    typedBy(m[t.RustValue.initialRefForMut], tag.TypeTag.mutPointedType, m)
    &&
    typedBy(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m)
  }

  pred structIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    typedByAtIndex(t.RustValue.mapForStruct[i], tag.TypeTag.mapForStruct[i], m, i))
  }

  pred isArrayIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
    ==>
    typedByAtIndex(t.RustValue.mapForArray[i], tag.TypeTag.collectedType, m, i))
  }

  pred isStructuredDataIsTypedBy(t: RustValue, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    dataInv(t, m)
    &&
    ((forall j: Int :: (0 <= j < t.RustValue.lenForStruct)
    ==>
    (typedByAtIndex(t.RustValue.mapForStruct[j], mapForSD[j], m, j))))
  }

  pred isYoinkedIsTypedBy(t: RustValue, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    ((forall j: Int :: (0 <= j < t.RustValue.lenForStruct)
    ==>
    (typedByAtIndex(t.RustValue.mapForStruct[j], mapForSD[j], m, j))))
  }

  pred maybeDeref1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t
    ==
    RustValue.isDeref(t.RustValue.borrowNameForDeref)
    &&
    typedBy((m[t.RustValue.borrowNameForImmut]), tag.TypeTag.sharedPointedType, m))
  }

  pred maybeDeref2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    ((t != RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    typedBy(t, tag.TypeTag.sharedPointedType, m))
  }

  pred immutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
    &&
    (typedBy(m[t.RustValue.borrowNameForImmut], tag.TypeTag.sharedPointedType, m))
  }

  pred immutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
    &&
    typedBy(t.RustValue.valueForImmut, tag.TypeTag.sharedPointedType, m)
  }

  pred typedByAtIndex(t: RustValue, tag: TypeTag, m: ResolutionMap, i: Int) {
    typedBy(t, tag, m)
  }

  pred typedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    exists pointed: RustValue :: derefsTo(t, pointed, m)
    &&
    (((tag == TypeTag.isInt()) ==> (pointed == RustValue.literalInt(pointed.RustValue.v))))
    &&
    ((tag == TypeTag.isBool()) ==> (pointed == RustValue.literalBool(pointed.RustValue.b)))
    &&
    (((tag == TypeTag.isRawPointer()) ==> (pointed == RustValue.rawPointer(pointed.RustValue.referenceToPointed))))
    &&
    (tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType) ==> ((t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut)) || (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))))
    &&
    (((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))) ==> immutBorrow1IsTypedBy(pointed, tag, m))
    &&
    (((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))) ==> immutBorrow2IsTypedBy(pointed, tag, m))
    &&
    ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) ==> ((t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1)) || (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))))
    &&
    (((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))) ==> mutBorrow1IsTypedBy(pointed, tag, m))
    &&
    (((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))) ==> mutBorrow2IsTypedBy(pointed, tag, m))
    &&
    ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) ==> isArrayIsTypedBy(pointed, tag, m))
    &&
    (((tag == TypeTag.isUninit()) ==> (pointed == RustValue.uninit())))
    &&
    (((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) ==> structIsTypedBy(pointed, tag, m)))
    &&
    (((tag == TypeTag.isStructuredData()) ==> isStructuredDataIsTypedBy(pointed, m)))
    &&
    (((tag == TypeTag.isYoinked()) ==> isYoinkedIsTypedBy(pointed, m)))
  }
}

field place: RustValue;

module AgreeI = Library.Agree[Library.IntType];
interface VecI: DataInvariant {
  field pointedArr: RustValue;
  val tag: TypeTag;
  val lenForSD: Int = 3;
  val mapForSD: Map[Int, TypeTag] = {|i: Int :: (i == 0) ? TypeTag.isInt(): ((i == 1) ? TypeTag.isInt(): TypeTag.isArrayOf(TypeTag.isMutBorrow(tag)))|};

  func isStructure(x: RustValue, structure: RustValue, m: ResolutionMap) returns (res: Bool ) {
    derefsTo(x, structure, m) && structure == RustValue.struct(structure.RustValue.lenForStruct, structure.RustValue.mapForStruct)
  }

  lemma isStructureSurj(x: RustValue, structure1: RustValue, structure2: RustValue, m: ResolutionMap)
    requires isStructure(x, structure1, m) && isStructure(x, structure2, m)
    ensures structure1 == structure2 {
    derefsToSurj(x, structure1, structure2, m);
  }

  func isCapField(structure: RustValue, cap: Int, m: ResolutionMap) returns (res: Bool ) {
    derefsTo(structure.RustValue.mapForStruct[0], RustValue.literalInt(cap), m)
  }

  lemma isCapFieldSurj(structure: RustValue, cap1: Int, cap2: Int, m: ResolutionMap)
    requires isCapField(structure, cap1, m) && isCapField(structure, cap2, m)
    ensures cap1 == cap2 {
    derefsToSurj(structure.RustValue.mapForStruct[0], RustValue.literalInt(cap1), RustValue.literalInt(cap2), m);
  }

  func isLenField(structure: RustValue, len: Int, m: ResolutionMap) returns (res: Bool ) {
    derefsTo(structure.RustValue.mapForStruct[1], RustValue.literalInt(len), m)
  }

  lemma isLenFieldSurj(structure: RustValue, len1: Int, len2: Int, m: ResolutionMap)
    requires isLenField(structure, len1, m) && isLenField(structure, len2, m)
    ensures len1 == len2 {
    derefsToSurj(structure.RustValue.mapForStruct[1], RustValue.literalInt(len1), RustValue.literalInt(len2), m);
  }

  func isBufField(structure: RustValue, cap: Int, map: Map[Int, RustValue], m: ResolutionMap) returns (res: Bool ) {
    derefsTo(structure.RustValue.mapForStruct[2], RustValue.array(cap, map), m)
  }

  lemma isBufFieldSurj(structure: RustValue, cap1: Int, map1: Map[Int, RustValue], cap2: Int, map2: Map[Int, RustValue], m: ResolutionMap)
    requires isBufField(structure, cap1, map1, m) && isBufField(structure, cap2, map2, m)
    ensures (cap1 == cap2) && (map1 == map2) {
    derefsToSurj(structure.RustValue.mapForStruct[2], RustValue.array(cap1, map1), RustValue.array(cap2, map2), m);
  }

  pred initializedForLen(len: Int, cap: Int, map: Map[Int, RustValue], m: ResolutionMap) {
    ((0 <= i < len) ==> map[i] != RustValue.uninit())
    &&
    ((len <= i < cap) ==> map[i] == RustValue.uninit())
  }

  pred dataInv(rustValue: RustValue, m: ResolutionMap) {
    exists structure: RustValue,
    cap: Int,
    len: Int,
    map: Map[Int, RustValue] ::
    isStructure(rustValue, structure, m)
    &&
    isCapField(structure, cap, m)
    &&
    isLenField(structure, len, m)
    &&
    len
    <=
    cap
    &&
    isBufField(structure, cap, map, m)
    &&
    typedBy(RustValue.array(cap, map), TypeTag.isArrayOf(TypeTag.isMaybeInit(tag)), m)
    &&
    initializedForLen(len, cap, map, m)
  }

  pred getUncheckedMutPre(xs: RustValue, gamma: Ref, idx: Int, len: Int, m: ResolutionMap, gammaI: Ref) {
    exists structure: RustValue,
    cap: Int,
    map: Map[Int, RustValue] :: typedBy(RustValue.mutBorrow1(xs, gamma), TypeTag.isMutBorrow(TypeTag.isStructuredData()), m)
    &&
    isStructure(xs, structure, m)
    &&
    isLenField(structure, len, m)
    &&
    isBufField(structure, cap, map, m)
    &&
    (0 <= idx < len)
    &&
    isProphecy(gamma)
    &&
    isProphecy(gammaI)
  }

  pred getUncheckedMutPost(xs: RustValue, gamma: Ref, idx: Int, len: Int, m: ResolutionMap, xi: RustValue, gammaI: Ref) {
    exists structure: RustValue, cap: Int, map: Map[Int, RustValue] ::
    isStructure(xs, structure, m)
    &&
    isBufField(structure, cap, map, m)
    &&
    // we need to add a reborrows(r, r') predicate which will allow r to depend on the resolved value of r'
    resolvedProphecy(gamma, RustValue.array(cap, (map[idx := RustValue.isDeref(gammaI)])), m)
    &&
    (map[idx] == xi)
    &&
    isProphecy(gammaI)
  }

  proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref)
    returns (xi: RustValue, gammaI: Ref)
    requires getUncheckedMutPre(xs, gamma, idx, len, m, gammaI)
    ensures getUncheckedMutPost(xs, gamma, idx, len, m, xi, gammaI)
     {
    // Unfold the precondition:
    var structure: RustValue;
    var cap: Int;
    var map: Map[Int, RustValue];
    unfold getUncheckedMutPre(xs, gamma, idx, len, m, gammaI)[structure := structure, cap:= cap, map := map];
    // Unfold the typedBy predicate, following dereferences:
    var pointed1: RustValue;
    unfold typedBy(RustValue.mutBorrow1(xs, gamma),TypeTag.isMutBorrow(TypeTag.isStructuredData()),m)[pointed1 := pointed];
    assert pointed1 == RustValue.mutBorrow1(xs, gamma);
    // Yoink the invariant from the data
    unfold mutBorrow1IsTypedBy(RustValue.mutBorrow1(xs, gamma), TypeTag.isMutBorrow(TypeTag.isStructuredData()), m);
    var pointed: RustValue;
    unfold typedBy(xs, TypeTag.isStructuredData(), m)[pointed := pointed];
    unfold isStructuredDataIsTypedBy(pointed, m);
    dataInvFromDerefsTo(xs, pointed, m);
    fold isYoinkedIsTypedBy(pointed, m);
    fold typedBy(xs, TypeTag.isYoinked(), m)[pointed := pointed];
    // Unfold the invariant
    var cap2: Int;
    var len1: Int;
    var borrowName: Ref;
    var map2: Map[Int, RustValue];
    var structure1: RustValue;
    unfold dataInv(xs, m)[cap2 := cap, len1:= len, map2:= map, structure1 := structure];
    // The field is accessed by both the precondition and the invariant;
    // assert that they are equal
    isStructureSurj(xs, structure, structure1, m);
    assert (structure == structure1);
    assert isBufField(structure, cap, map, m);
    assert isBufField(structure1, cap2, map2, m);
    isBufFieldSurj(structure, cap, map, cap2, map2, m);
    isLenFieldSurj(structure, len, len1, m);
    // Resolve the prophecy variable
    resolveProphecy(gamma, RustValue.array(cap, map[idx := RustValue.isDeref(gammaI)]), m);
    // Fold the postcondition
    assert isStructure(xs, structure, m);
    assert isBufField(structure, cap, map, m);
    assert isProphecy(gammaI);
    assert resolvedProphecy(gamma, RustValue.array(cap, (map[idx := RustValue.isDeref(gammaI)])), m);
    xi := map[idx];
    fold getUncheckedMutPost(xs, gamma, idx, len, m, xi, gammaI)[structure := structure, cap:= cap, map := map];
    // Because we have no place types yet, the type is only asserted
    // over the pure rust value "xs";
    // no need to reestablish the type at a location.
    // So we are done.
  }
}

module Main: VecI {
  val tag: TypeTag = TypeTag.isInt();

  lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInv(m[t.RustValue.borrowNameForDeref], m)
    ensures dataInv(t, m) {
    var cap: Int;
    var len: Int;
    var borrowName: Ref;
    var map: Map[Int, RustValue];
    var structure: RustValue;
    var pointed: RustValue;
    unfold dataInv(m[t.RustValue.borrowNameForDeref], m)[structure := structure,cap:= cap,len:= len,map := map];
    fold dataInv(t, m)[structure := structure,cap:= cap,len:= len,map := map];
  }
}

// module RawVec[G: GenericTypeTag, I: DataInvariants] {
//   field pointedBuf: RustValue;
//   val lenForSD: Int = 2;
//   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};
//   func isBufField(xs: RustValue, buf: Ref, m: ResolutionMap) returns (res: Bool) {
//     (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
//     refDerefsTo(xs.RustValue.mapForStruct[0], RustValue.rawPointer(buf), m)
//   }

//   func isCapField(xs: RustValue, cap: Int, m: ResolutionMap) returns (res: Bool) {
//     (xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) &&
//     refDerefsTo(xs.RustValue.mapForStruct[1], RustValue.literalInt(cap), m)
//   }

//   pred dataInv(xs: RustValue, m: ResolutionMap) {
//     exists structure: RustValue, bufField: Ref, capField: Int, buf: RustValue, zs: RustValue ::
//       derefsTo(xs, structure, m) &&
//       isBufField(structure, bufField, m) &&
//       isCapField(structure, capField, m) &&
//       own(bufField, pointedBuf, buf, 1.0) &&
//       I.typedBy(buf, TypeTag.isArrayOf(G.tag), m)
//   }
// }

// module VecI[G: GenericTypeTag, I: DataInvariants] {
//   module RawVecInst = RawVec[G, I];

// }

// module Main[G: GenericTypeTag]: DataInvariants {
//   field pointedBuf: RustValue;
//   val lenForSD: Int = 2;
//   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};

// }

// interface VecI[G: GenericTypeTag]: DataInvariant {
//   val mapForSD: Map[Int, TypeTag] = {| i: Int :: (i == 0) ? TypeTag.isRawPointer() : TypeTag.isInt() |};
// }

// interface VecI: DataInvariant {
//   field pointedArr: RustValue;
//   val tag: TypeTag;
//   val vecType: TypeTag = TypeTag.isStructOf(3, {|i: Int :: (i == fCap) ? TypeTag.isInt(): ((i == fLen) ? TypeTag.isInt(): TypeTag.isArrayOf(tag))|});

//   val lenForSD: Int = 1;
//   val mapForSD: Map[Int, TypeTag] = {|i: Int :: TypeTag.isRawPointer()|};
//   func isUnderlying(xs: RustValue, len: )

//   func derefsTo(x: RustValue, y: RustValue, m: ResolutionMap) returns (res: Bool) {
//     (x == RustValue.isDeref(x.RustValue.borrowNameForDeref) && derefsTo(m[x.RustValue.borrowNameForDeref], y, m)) ||
//     (x != RustValue.isDeref(y.RustValue.borrowNameForDeref) && x == y)
//   }

//   func refDerefsTo(ref: Ref, y: RustValue, m: ResolutionMap) returns (res: Bool) {
//     derefsTo(RustValue.isDeref(ref), y, m)
//   }

//   func isCap(raw: Ref, cap: Int) {
//     refDerefsTo(raw, )
//   }

//   func isLen(raw: Ref, len: Int) {
//     refDerefsTo(Ref, )
//   }

//   pred dataInvForStruct(rustValue: RustValue, m: ResolutionMap) {
//     (m[rustValue.RustValue.mapForStruct[0]] == RustValue.rawPointer((m[rustValue.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed))
//     &&
//     (exists cap: Int :: (exists arr: RustValue :: exists len: Int :: own(rustValue.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len))
//     &&
//     (isProphecy(rustValue.RustValue.referenceToPointed)
//     &&
//     typedBy((m[rustValue.RustValue.referenceToPointed]), vecType, m)
//     &&
//     (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fCap]] == RustValue.literalInt(cap))
//     &&
//     (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fLen]] == RustValue.literalInt(len))
//     &&
//     (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fArr]] == arr)
//     &&
//     (forall i: Int :: (0 <= i < len)
//     ==>
//     ((m[arr.RustValue.mapForArray[i]] != RustValue.uninit())))
//     &&
//     (forall i: Int :: (len <= i < cap)
//     ==>
//     (m[arr.RustValue.mapForArray[i]] == RustValue.uninit())))))
//   }

//   pred dataInv(rustValue: RustValue, m: ResolutionMap) {
//     (rustValue == RustValue.isDeref(rustValue.RustValue.borrowNameForDeref) ==> dataInv(m[rustValue.RustValue.borrowNameForDeref], m))
//     &&
//     (rustValue == RustValue.struct(1, rustValue.RustValue.mapForStruct) ==> dataInvForStruct(rustValue, m))
//     &&
//     ((rustValue != RustValue.isDeref(rustValue.RustValue.borrowNameForDeref) && rustValue != RustValue.struct(1, rustValue.RustValue.mapForStruct) ==> false))
//   }

//   pred isReborrowedAtIndex(rustValue: RustValue, idx: Int, prophecy: Ref, m: ResolutionMap) {
//     ((rustValue == RustValue.isDeref(rustValue.RustValue.borrowNameForDeref))
//     ==>
//     isReborrowedAtIndex(m[rustValue.RustValue.borrowNameForDeref], idx, prophecy, m))
//     &&
//     ((rustValue == RustValue.rawPointer(rustValue.RustValue.referenceToPointed))
//     ==>
//     (isProphecy(prophecy) && (exists arr: RustValue :: m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[fArr]] == arr && (m[arr.RustValue.mapForArray[i]] == m[prophecy]))))
//     &&
//     (((rustValue != RustValue.isDeref(rustValue.RustValue.borrowNameForDeref))
//     &&
//     (rustValue != RustValue.rawPointer(rustValue.RustValue.referenceToPointed)))
//     ==>
//     false)
//   }

//   pred isReborrowedWithProphecy(xs: RustValue, idx: Int, m: ResolutionMap) {
//     exists prophecy: Ref :: isReborrowedAtIndex(xs, idx, prophecy, m)
//   }

//   pred isVectorStruct(xs: RustValue, len: Int, m: ResolutionMap) {
//     exists trail: TypeTagTrail :: own(xs.RustValue.mapForStruct[fArr], pointedCap, AgreeI.agree(len))
//     &&
//     typedBy(xs, TypeTag.isStructuredData(), m, trail)
//     &&
//     isProphecy((m[xs.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed)
//   }

//   pred isVector(xs: RustValue, len: Int, m: ResolutionMap) {
//     ((xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref))
//     ==>
//     isVector(m[xs.RustValue.borrowNameForDeref], len, m))
//     &&
//     ((xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct))
//     ==>
//     isVectorStruct(xs, len, m))
//     &&
//     (((xs != RustValue.isDeref(xs.RustValue.borrowNameForDeref)) && (xs != RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct))) ==> false)
//   }

//   proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap)
//     requires typedBy(xs, TypeTag.isStructuredData(), m)
//     requires exists ys: RustValue ::
//              derefsTo(xs, ys, m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[0].RustValue.mapForStruct[fLen],
//                          RustValue.literalInt(len), m) &&
//              isProphecy(ys.RustValue.mapForArray[0])
//     ensures typedBy(xs, TypeTag.isStructuredData(), m)
//     requires exists ys: RustValue, cap: Int, arr: RustValue ::
//              derefsTo(xs, ys, m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[fLen], RustValue.literalInt(len), m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[fCap], RustValue.literalInt(cap), m) &&
//              refDerefsTo(ys.RustValue.mapForStruct[fArr], RustValue.array(cap, arr), m) &&
//              isProphecy(ys.RustValue.mapForArray[fArr], )
//   {
//   }
//   // proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap)
//   //   requires isVector(xs, len, m) && (0 <= idx < len)
//   //   // TODO change isVector to isBorrowedVector -- we've consumed the prophecy variable
//   //   ensures isVector(xs, len, m) && isReborrowedWithProphecy(xs, idx, m) {
//   //   unfold   isVector(xs,len,m);
//   //   if (xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref)){
//   //     getUncheckedMut(m[xs.RustValue.borrowNameForDeref], idx, len, m);
//   //     var prophecy: Ref;
//   //     unfold   isReborrowedWithProphecy(m[xs.RustValue.borrowNameForDeref],idx,m)[prophecy := prophecy];
//   //     fold isReborrowedAtIndex(xs,idx,prophecy,m);
//   //     fold isReborrowedWithProphecy(xs,idx,m)[prophecy := prophecy];
//   //     fold isVector(xs,len,m);
//   //   } else {
//   //     var trail: TypeTagTrail;
//   //     unfold   isVectorStruct(xs,len,m)[trail := trail];
//   //     placeTypeImpliesDataInv(xs, m, trail);
//   //     unfold  dataInv(xs, m);
//   //     var cap: Int;
//   //     var arr: RustValue;
//   //     var len: Int;
//   //     unfold  dataInvForStruct(xs, m)[cap := cap, arr := arr, len := len];
//   //     var finalValueAtIndex: RustValue;
//   //     havoc finalValueAtIndex;
//   //     assume typedBy(finalValueAtIndex, tag);
//   //     res := new (ownProphecy: UnitA.agree(Unit.unit()));
//   //     assume (m[res] == finalValueAtIndex);
//   //     fold isProphecy(res);
//   //     resolveProphecy(arr.RustValue.referenceToPointed, , m)
//   //     assume false;
//   //     //
//   //   }
//   // }
// }
