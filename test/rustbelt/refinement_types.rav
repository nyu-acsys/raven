module RustValue: Library.Type {
  rep type T = data {
    case literalInt(v: Int);
    case literalBool(b: Int);
    case mutBorrow1(initialValueForMut: T, finalBorrowNameForMut1: Ref);
    case mutBorrow2(initialRefForMut: Ref, finalBorrowNameForMut2: Ref);
    case immutBorrow1(borrowNameForImmut: Ref);
    case immutBorrow2(valueForImmut: T);
    case rawPointer(referenceToPointed: Ref);
    case struct(lenForStruct: Int, mapForStruct: Map[Int, T]);
    case array(lenForArray: Int, mapForArray: Map[Int, T]);
    case uninit()
  }
}

module Option[X: Library.Type] {
  rep type T = data {
    case some(wrappedData: X);
    case none()
  }
}

type ResolutionMap = Map[Ref, RustValue];
field value: RustValue;

module TypeTag : Library.Type {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isYoinked();
    case isBlocked(blockedRef: Ref, blockedTy: T);
    case isStructuredData()
  }
}

type ResolvedType = Map[Ref, TypeTag];

module TypeTagA = Library.Agree[TypeTag];

field ownProphecy: TypeTagA;

pred isProphecy(r: Ref, t: TypeTag) {
  own(r, ownProphecy, TypeTagA.agree(t))
}

// proc resolveProphecy(r: Ref, t: v: RustValue, m: ResolutionMap)
//   requires own(r, ownProphecy, UnitA.agree(Unit.unit()))
//   ensures resolvedProphecy(r, v, m) {
//   exhale own(r, ownProphecy, UnitA.agree(Unit.unit()));
//   assume (m[r] == v);
//   fold resolvedProphecy(r,v,m);
// }

// proc makeProphecy() returns (res: Ref) ensures isProphecy(res) {
//   res := new (ownProphecy: UnitA.agree(Unit.unit()));
//   fold isProphecy(res);
// }

// lemma derefsToSurj(x: RustValue, y: RustValue, z: RustValue, m: ResolutionMap)
//  requires derefsTo(x, y) && derefsTo(x, z, m)
//  ensures y == z {
//  if (x == RustValue.isDeref(x.RustValue.dereferenced)) {
//    derefsToSurj(m[x.RustValue.dereferenced], y, z, m);
//  }
// }

interface DataInvariant {
  val lenForSD: Int;
  val mapForSD: Map[Int, TypeTag];

  pred dataInv(value: RustValue, m: ResolutionMap);

  pred prophecyTypedBy(prophecy: Ref, tag: TypeTag);

  proc allocateProphecy(tag: TypeTag, m: ResolutionMap)
    returns (prophecy: Ref)
    ensures isProphecy(prophecy, tag) && prophecyTypedBy(prophecy, tag) {
    prophecy := new(ownProphecy: TypeTagA.agree(tag));
    assume prophecyTypedBy(prophecy, tag); // inhale?
  }

  pred resolvedProphecy(prophecy: Ref, v: RustValue, tag: TypeTag, m: ResolutionMap) {
    (m[prophecy] == v) && typedBy(v, tag, m)
  }

  proc resolveProphecy(prophecy: Ref, tag: TypeTag, m: ResolutionMap, v: RustValue)
    requires isProphecy(prophecy, tag) && prophecyTypedBy(prophecy, tag) && typedBy(v, tag, m)
    ensures resolvedProphecy(prophecy, v, tag, m) {
    exhale isProphecy(prophecy, tag);
    exhale prophecyTypedBy(prophecy, tag);
    assume (m[prophecy] == v);
    fold resolvedProphecy(prophecy, tag, m);
  }

  pred mutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
    &&
    typedBy(t.RustValue.initialValueForMut, tag.TypeTag.mutPointedType, m)
    &&
    prophecyTypedBy(t.RustValue.finalBorrowNameForMut1, tag)
  }

  pred mutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
    &&
    prophecyTypedBy(t.RustValue.initialRefForMut, tag.TypeTag.mutPointedType)
    &&
    prophecyTypedBy(t.RustValue.finalBorrowNameForMut2, tag)
  }

  pred structIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    typedByAtIndex(t.RustValue.mapForStruct[i], tag.TypeTag.mapForStruct[i], m, i))
  }

  pred isArrayIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
    ==>
    typedByAtIndex(t.RustValue.mapForArray[i], tag.TypeTag.collectedType, m, i))
  }

  pred isStructuredDataIsTypedBy(t: RustValue, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    dataInv(t, m)
    &&
    ((forall j: Int :: (0 <= j < t.RustValue.lenForStruct)
    ==>
    (typedByAtIndex(t.RustValue.mapForStruct[j], mapForSD[j], m, j))))
  }

  pred isYoinkedIsTypedBy(t: RustValue, m: ResolutionMap) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    ((forall j: Int :: (0 <= j < t.RustValue.lenForStruct)
    ==>
    (typedByAtIndex(t.RustValue.mapForStruct[j], mapForSD[j], m, j))))
  }

  pred immutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
    &&
    prophecyTypedBy(t.RustValue.borrowNameForImmut, tag.TypeTag.sharedPointedType)
  }

  pred immutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
    &&
    typedBy(t.RustValue.valueForImmut, tag.TypeTag.sharedPointedType, m)
  }

  pred typedByAtIndex(t: RustValue, tag: TypeTag, m: ResolutionMap, i: Int) {
    typedBy(t, tag, m)
  }

  pred typedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) {
    ((tag == TypeTag.isInt()) ==> (t == RustValue.literalInt(t.RustValue.v)))
    &&
    (((tag == TypeTag.isBool()) ==> (t == RustValue.literalBool(t.RustValue.b))))
    &&
    ((tag == TypeTag.isRawPointer()) ==> (t == RustValue.rawPointer(t.RustValue.referenceToPointed)))
    &&
    ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) ==> ((t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut) ) || (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))))
    &&
    ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType) && (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))) ==> immutBorrow1IsTypedBy(t, tag, m))
    &&
    ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType) && (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))) ==> immutBorrow2IsTypedBy(t, tag, m))
    &&
    ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) ==> ((t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1)) || (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))))
    &&
    ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType) && (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))) ==> mutBorrow1IsTypedBy(t, tag, m))
    &&
    (((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))) ==> mutBorrow2IsTypedBy(t, tag, m))
    &&
    ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) ==> isArrayIsTypedBy(t, tag, m))
    &&
    (((tag == TypeTag.isUninit()) ==> (t == RustValue.uninit())))
    &&
    ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) ==> structIsTypedBy(t, tag, m))
    &&
    ((tag == TypeTag.isStructuredData()) ==> isStructuredDataIsTypedBy(t, m))
    &&
    (((tag == TypeTag.isYoinked()) ==> isYoinkedIsTypedBy(t, m)))
  }
}

module AgreeI = Library.Agree[Library.IntType];
interface VecI: DataInvariant {
  field pointedArr: RustValue;
  val tag: TypeTag;
  val lenForSD: Int = 3;
  val mapForSD: Map[Int, TypeTag] = {|i: Int :: (i == 0) ? TypeTag.isInt(): ((i == 1) ? TypeTag.isInt(): TypeTag.isRawPointer() )|};

  pred dataInv(rustValue: RustValue, m: ResolutionMap) {
    exists cap: Int, len: Int, buf: Ref, map: Map[Int, RustValue] ::
    0 <= len <= cap &&
    (rustValue.RustValue.mapForArray[0] == RustValue.literalInt(cap)) &&
    (rustValue.RustValue.mapForArray[1] == RustValue.literalInt(len)) &&
    (rustValue.RustValue.mapForArray[2] == RustValue.rawPointer(buf)) &&
    own(buf, value, RustValue.array(cap, map)) &&
    typedBy(RustValue.array(cap, map), TypeTag.isArrayOf(TypeTag.isMaybeInit(TypeTag.isMutBorrow(tag))), m) &&
    (forall i: Int :: exists v: RustValue ::
    ((0 <= i < len) ==> v != RustValue.uninit()) &&
    ((len <= i < cap) ==> v == RustValue.uninit()))
  }

  pred getUncheckedMutPre(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref, gammaI: Ref) {
    isProphecy(gamma, TypeTag.isStructuredData()) &&
    isProphecy(gammaI, tag) &&
    typedBy(xs, isMutBorrow(TypeTag.isStructuredData()), m) &&
    (0 <= idx < len)
  }

  pred getUncheckedMutPost(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref, gammaI: Ref) {
    resolvedProphecy(xs)
    exists map: Map[Int, Ref] ::
    own(gammaI, ownProphecy, TypeTagA.agree(tag)) &&
    (m[gamma] == RustValue.array((m[gamma]).RustValue.lenForArray, map)) &&
    (map[idx] == gammaI) &&
    isProphecy(gammaI, tag)
  }

  // proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap, gamma: Ref, gammaI: Ref)
  //   requires getUncheckedMutPre(xs, idx, len, m, gamma, gammaI)
  //   ensures getUncheckedMutPost(xs, idx, len, m, gamma, gammaI)
  // {
  //   // Unfold the precondition:
  //   var structure: RustValue;
  //   unfold getUncheckedMutPre(xs, idx, len, m, gamma, gammaI)[structure := structure];
  //   // Unfold the typedBy predicate, following dereferences:
  //   var pointed: RustValue;
  //   unfold typedBy(xs, TypeTag.isStructuredData(), m)[pointed := pointed];
  //   // Yoink the invariant from the data
  //   if (trail == TypeTrail.structuredData(trail.TypeTrail.trailForSD)) {
  //     unfold isStructuredDataIsTypedBy(pointed, m, trail.TypeTrail.trailForSD);
  //     dataInvFromDerefsTo(xs, pointed, m);
  //     fold isYoinkedIsTypedBy(pointed, m, trail.TypeTrail.trailForSD);
  //     fold typedBy(xs, TypeTag.isYoinked(), m, TypeTrail.yoinked(trail.TypeTrail.trailForSD))[pointed := pointed];
  //     fold typedBy(xs, TypeTag.isYoinked, m)[trail := TypeTrail.yoinked(trail.TypeTrail.trailForSD)];
  //   }
  //   // Unfold the invariant
  //   var cap: Int;
  //   var len1: Int;
  //   var borrowName: Ref;
  //   var map: Map[Int, Ref];
  //   unfold dataInv(pointed, m)[cap := cap, len1 := len, borrowName := borrowName, map := map];
  //   // The field is accessed by both the precondition and the invariant;
  //   // assert that they are equal

  //   isBufFieldSurj(structure, gamma, borrowName, m);
  //   isLenFieldSurj(structure, len, len1, m);
  //   // Resolve the prophecy variable
  //   exhale own(gamma, ownProphecy, UnitA.agree(Unit.unit()));
  //   assume (m[gamma] == RustValue.array(cap, map[idx := gammaI]));
  //   resolveProphecy(gamma, RustValue.array(cap, map[idx := gammaI]), m);
  //   // Fold the postcondition
  //   fold isProphecy(gammaI);
  //   fold getUncheckedMutPost(xs, idx, len, m, gamma, gammaI)[map := map];
  //   // Because we have no place types yet, the type is only asserted
  //   // over the pure rust value "xs";
  //   // no need to reestablish the type at a location.
  //   // So we are done.
  // }
}
