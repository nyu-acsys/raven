module TypeTag: Library.Type {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T)
  }
}

module RustValue: Library.Type {
  module AgreeTag = Library.Agree[TypeTag];
  field typeTag: AgreeTag;
  rep type T = data {
    case literalInt(v: Int);
    case literalBool(b: Int);
    case mutBorrow1(initialValueForMut: T, finalBorrowNameForMut1: Ref);
    case mutBorrow2(initialRefForMut: Ref, finalBorrowNameForMut2: Ref);
    case immutBorrow1(borrowNameForImmut: Ref);
    case immutBorrow2(valueForImmut: T);
    case rawPointer(referenceToPointed: Ref);
    case struct(lenForStruct: Int, mapForStruct: Map[Int, Ref]);
    case array(lenForArray: Int, mapForArray: Map[Int, Ref]);
    case uninit();
    case isDeref(borrowNameForDeref: Ref)
  }
}

module Option[X: Library.Type] {
  rep type T = data {
    case some(wrappedData: X);
    case none()
  }
}

// so do ensure that you do that.
ghost field resolvedValue: RustValue;
type ResolutionMap = Map[Ref, RustValue];
field value: RustValue;

func mutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
  &&
  isTypedBy(t.RustValue.initialValueForMut, tag.TypeTag.mutPointedType, m)
  &&
  isTypedBy((m[t.RustValue.finalBorrowNameForMut2]), tag.TypeTag.mutPointedType, m)
}

func mutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
  &&
  isTypedBy(m[t.RustValue.initialRefForMut], tag.TypeTag.mutPointedType, m)
  &&
  isTypedBy(m[t.RustValue.finalBorrowNameForMut2], tag.TypeTag.mutPointedType, m)
}

func immutBorrow1IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
  &&
  isTypedBy(m[t.RustValue.borrowNameForImmut], tag.TypeTag.sharedPointedType, m)
}

func immutBorrow2IsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
  &&
  isTypedBy(t.RustValue.valueForImmut, tag.TypeTag.sharedPointedType, m)
}

// lenForStruct: Int, mapForStruct: Map[Int, T]
func structIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
  &&
  (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
  &&
  isTypedBy(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.TypeTag.mapForStruct[i], m))
}

func arrayIsTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  (t == RustValue.array(t.RustValue.lenForArray, t.RustValue.mapForArray))
  &&
  (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
  &&
  isTypedBy(RustValue.isDeref(t.RustValue.mapForArray[i]), tag.TypeTag.collectedType, m))
}

func isTypedBy(t: RustValue, tag: TypeTag, m: ResolutionMap) returns (res: Bool ) {
  ((t == RustValue.isDeref(t.RustValue.borrowNameForDeref)) && (isTypedBy(m[t.RustValue.borrowNameForDeref], tag, m)))
  ||
  ((tag == TypeTag.isInt()) && (t == RustValue.literalInt(t.RustValue.v)))
  ||
  ((tag == TypeTag.isBool()) && (t == RustValue.literalBool(t.RustValue.b)))
  ||
  ((tag == TypeTag.isMutBorrow(tag.TypeTag.mutPointedType)) && (mutBorrow1IsTypedBy(t, tag, m) || mutBorrow2IsTypedBy(t, tag, m)))
  ||
  ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) && (immutBorrow1IsTypedBy(t, tag, m) || immutBorrow2IsTypedBy(t, tag, m)))
  ||
  ((tag == TypeTag.isRawPointer()) && (t == RustValue.rawPointer(t.RustValue.referenceToPointed)))
  ||
  ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) && structIsTypedBy(t, tag, m))
  ||
  ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) && arrayIsTypedBy(t, tag, m))
  ||
  (tag == TypeTag.isUninit() && t == RustValue.uninit())
  ||
  (tag == TypeTag.isMaybeInit(tag.TypeTag.potentiallyInitializedType) && (t == RustValue.uninit() || isTypedBy(t, tag.TypeTag.potentiallyInitializedType, m)))
}

// Tomorrow morning, wake up, and look at this.
// we need an isTypedBy for PlaceType.
module PlaceType {
  rep type T = data {
    case isInt();
    // fix int later with some size
    case isBool();
    case isMutBorrow(mutPointedType: T);
    case isSharedBorrow(sharedPointedType: T);
    case isRawPointer();
    case isStructOf(len: Int, mapForStruct: Map[Int, T]);
    case isArrayOf(collectedType: T);
    case isUninit();
    case isMaybeInit(potentiallyInitializedType: T);
    case isYoinked();
    case isBlocked(blockedRef: Ref, blockedTy: T);
    case isStructuredData()
  }
}

module PlaceTypeTrail {
  rep type T = data {
    case literalInt();
    case literalBool();
    case mutBorrow1(mutBorrow1Trail1: T, mutBorrow1Trail2: T);
    case mutBorrow2(mutBorrow2Trail1: T, mutBorrow2Trail2: T);
    case immutBorrow1(immutBorrow1Trail: T);
    case immutBorrow2(immutBorrow2Trail: T);
    case rawPointer();
    case struct(trailForStruct: Map[Int, T]);
    case array(trailForArray: Map[Int, T]);
    case uninit();
    case isDeref(derefTrail: T);
    case yoinked(trailForYoinked: Map[Int, T]);
    case structuredData(trailForSD: Map[Int, T])
  }
}

field programValue: RustValue;
pred locationTypedBy(ref: Ref, tag: TypeTag, m: ResolutionMap) {
  exists pVal: RustValue :: own(ref, programValue, pVal) && isTypedBy(pVal, tag, m)
}

module Unit: Library.Type {
  rep type T = data { case unit()}
}

module UnitA = Library.Agree[Unit];

field ownProphecy: UnitA;

pred isProphecy(r: Ref) {
  own(r, ownProphecy, UnitA.agree(Unit.unit()))
}

pred resolvedProphecy(r: Ref, v: RustValue, m: ResolutionMap) {
  (m[r] == v)
}

proc resolveProphecy(r: Ref, v: RustValue, m: ResolutionMap)
  requires own(r, ownProphecy, UnitA.agree(Unit.unit()))
  ensures resolvedProphecy(r, v, m) {
  exhale own(r, ownProphecy, UnitA.agree(Unit.unit()));
  assume (m[r] == v);
  fold resolvedProphecy(r,v,m);
}

proc makeProphecy() returns (res: Ref) ensures isProphecy(res) {
  res := new (ownProphecy: UnitA.agree(Unit.unit()));
  fold isProphecy(res);
}

interface DataInvariant {
  val lenForSD: Int;
  val mapForSD: Map[Int, PlaceType];

  pred dataInv(value: RustValue, m: ResolutionMap);

  lemma dataInvFromBorrow(t: RustValue, m: ResolutionMap)
    requires (t == RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    dataInv(m[t.RustValue.borrowNameForDeref], m)
    ensures dataInv(t, m)

  pred mutBorrow1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail1: PlaceTypeTrail, trail2: PlaceTypeTrail) {
    (t == RustValue.mutBorrow1(t.RustValue.initialValueForMut, t.RustValue.finalBorrowNameForMut1))
    &&
    placeTypedByAtTrail(t.RustValue.initialValueForMut, tag.PlaceType.mutPointedType, m, trail1)
    &&
    placeTypedByAtTrail(m[t.RustValue.finalBorrowNameForMut2], tag.PlaceType.mutPointedType, m, trail2)
  }

  pred mutBorrow2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail1: PlaceTypeTrail, trail2: PlaceTypeTrail) {
    (t == RustValue.mutBorrow2(t.RustValue.initialRefForMut, t.RustValue.finalBorrowNameForMut2))
    &&
    placeTypedByAtTrail(m[t.RustValue.initialRefForMut], tag.PlaceType.mutPointedType, m, trail1)
    &&
    placeTypedByAtTrail(m[t.RustValue.finalBorrowNameForMut2], tag.PlaceType.mutPointedType, m, trail2)
  }

  pred structIsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), tag.PlaceType.mapForStruct[i], m, trail[i], i))
  }

  pred isArrayIsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (forall i: Int :: (0 <= i < t.RustValue.lenForArray)
    ==>
    placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForArray[i]), tag.PlaceType.collectedType, m, trail[i], i))
  }

  pred isStructuredDataIsTypedBy(t: RustValue, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    dataInv(t, m)
    &&
    ((forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    (placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), mapForSD[i], m, trail[i], i))))
  }

  pred isYoinkedIsTypedBy(t: RustValue, m: ResolutionMap, trail: Map[Int, PlaceTypeTrail]) {
    (t == RustValue.struct(t.RustValue.lenForStruct, t.RustValue.mapForStruct))
    &&
    (lenForSD == t.RustValue.lenForStruct)
    &&
    ((forall i: Int :: (0 <= i < t.RustValue.lenForStruct)
    ==>
    (placeTypedByAtIndex(RustValue.isDeref(t.RustValue.mapForStruct[i]), mapForSD[i], m, trail[i], i))))
  }

  pred maybeDeref1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t
    ==
    RustValue.isDeref(t.RustValue.borrowNameForDeref)
    &&
    placeTypedByAtTrail((m[t.RustValue.borrowNameForImmut]), tag.PlaceType.sharedPointedType, m, trail))
  }

  pred maybeDeref2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    ((t != RustValue.isDeref(t.RustValue.borrowNameForDeref))
    &&
    placeTypedByAtTrail(t, tag.PlaceType.sharedPointedType, m, trail))
  }

  pred immutBorrow1IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.immutBorrow1(t.RustValue.borrowNameForImmut))
    &&
    (placeTypedByAtTrail(m[t.RustValue.borrowNameForImmut], tag.PlaceType.sharedPointedType, m, trail))
  }

  pred immutBorrow2IsTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    (t == RustValue.immutBorrow2(t.RustValue.valueForImmut))
    &&
    placeTypedByAtTrail(t.RustValue.valueForImmut, tag.PlaceType.sharedPointedType, m, trail)
  }

  pred placeTypedByAtIndex(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail, i: Int) {
    placeTypedByAtTrail(t, tag, m, trail)
  }

  pred placeTypedByAtTrail(t: RustValue, tag: PlaceType, m: ResolutionMap, trail: PlaceTypeTrail) {
    ((trail == PlaceTypeTrail.isDeref(trail.PlaceTypeTrail.derefTrail)) ==> (t == RustValue.isDeref(t.RustValue.borrowNameForDeref)) && placeTypedByAtTrail(m[t.RustValue.borrowNameForDeref], tag, m, trail.PlaceTypeTrail.derefTrail))
    &&
    ((trail == PlaceTypeTrail.literalInt()) ==> ((tag == PlaceType.isInt()) && (t == RustValue.literalInt(t.RustValue.v))))
    &&
    ((trail == PlaceTypeTrail.literalBool()) ==> ((tag == PlaceType.isBool()) && (t == RustValue.literalBool(t.RustValue.b))))
    &&
    ((trail == PlaceTypeTrail.rawPointer()) ==> ((tag == PlaceType.isRawPointer()) && (t == RustValue.rawPointer(t.RustValue.referenceToPointed))))
    &&
    ((trail == PlaceTypeTrail.immutBorrow1(trail.PlaceTypeTrail.immutBorrow1Trail)) ==> ((tag == PlaceType.isSharedBorrow(tag.PlaceType.sharedPointedType)) && immutBorrow1IsTypedBy(t, tag, m, trail.PlaceTypeTrail.immutBorrow1Trail)))
    &&
    ((trail == PlaceTypeTrail.immutBorrow2(trail.PlaceTypeTrail.immutBorrow2Trail)) ==> ((tag == PlaceType.isSharedBorrow(tag.PlaceType.sharedPointedType)) && immutBorrow2IsTypedBy(t, tag, m, trail.PlaceTypeTrail.immutBorrow2Trail)))
    &&
    ((trail == PlaceTypeTrail.mutBorrow1(trail.PlaceTypeTrail.mutBorrow1Trail1, trail.PlaceTypeTrail.mutBorrow1Trail2)) ==> ((tag == PlaceType.isMutBorrow(tag.PlaceType.mutPointedType)) && mutBorrow1IsTypedBy(t, tag, m, trail.PlaceTypeTrail.mutBorrow1Trail1, trail.PlaceTypeTrail.mutBorrow1Trail2)))
    &&
    ((trail == PlaceTypeTrail.mutBorrow2(trail.PlaceTypeTrail.mutBorrow2Trail1, trail.PlaceTypeTrail.mutBorrow2Trail2)) ==> ((tag == PlaceType.isMutBorrow(tag.PlaceType.mutPointedType)) && mutBorrow2IsTypedBy(t, tag, m, trail.PlaceTypeTrail.mutBorrow2Trail1, trail.PlaceTypeTrail.mutBorrow2Trail2)))
    &&
    ((trail == PlaceTypeTrail.array(trail.PlaceTypeTrail.trailForArray)) ==> ((tag == PlaceType.isArrayOf(tag.PlaceType.collectedType)) && isArrayIsTypedBy(t, tag, m, trail.PlaceTypeTrail.trailForArray)))
    &&
    ((trail == PlaceTypeTrail.uninit()) ==> ((tag == PlaceType.isUninit()) && (t == RustValue.uninit())))
    &&
    ((trail == PlaceTypeTrail.struct(trail.PlaceTypeTrail.trailForStruct)) ==> ((tag == PlaceType.isStructOf(tag.PlaceType.len, tag.PlaceType.mapForStruct)) && structIsTypedBy(t, tag, m, trail.PlaceTypeTrail.trailForStruct)))
    &&
    ((trail == PlaceTypeTrail.structuredData(trail.PlaceTypeTrail.trailForSD)) ==> ((tag == PlaceType.isStructuredData()) && isStructuredDataIsTypedBy(t, m, trail.PlaceTypeTrail.trailForSD)))
    &&
    ((trail == PlaceTypeTrail.yoinked(trail.PlaceTypeTrail.trailForYoinked)) ==> ((tag == PlaceType.isYoinked()) && isYoinkedIsTypedBy(t, m, trail.PlaceTypeTrail.trailForYoinked)))
  }

  pred placeTypedBy(t: RustValue, tag: PlaceType, m: ResolutionMap) {
    exists trail: PlaceTypeTrail :: placeTypedByAtTrail(t, tag, m, trail)
  }

  func fromTypeTag(tag: TypeTag) returns (res: PlaceType) {
    (tag == TypeTag.isInt()) ? PlaceType.isInt(): //
    ((tag == TypeTag.isBool()) ? PlaceType.isBool(): //
    ((tag == TypeTag.isSharedBorrow(tag.TypeTag.sharedPointedType)) ? PlaceType.isSharedBorrow(fromTypeTag(tag.TypeTag.sharedPointedType)): //
    ((tag == TypeTag.isRawPointer()) ? PlaceType.isRawPointer(): //
    ((tag == TypeTag.isStructOf(tag.TypeTag.len, tag.TypeTag.mapForStruct)) ? PlaceType.isStructOf(tag.TypeTag.len, {|i: Int :: fromTypeTag(tag.TypeTag.mapForStruct[i])|}): //
    ((tag == TypeTag.isArrayOf(tag.TypeTag.collectedType)) ? PlaceType.isArrayOf(fromTypeTag(tag.TypeTag.collectedType)): //
    ((tag == TypeTag.isUninit()) ? PlaceType.isUninit(): //
    (PlaceType.isMaybeInit(fromTypeTag(tag.TypeTag.potentiallyInitializedType)))))))))
  }

  lemma placeTypeImpliesDataInv(xs: RustValue, m: ResolutionMap, trail: PlaceTypeTrail)
    requires placeTypedByAtTrail(xs, PlaceType.isStructuredData(), m, trail)
    ensures placeTypedBy(xs, PlaceType.isYoinked(), m) && dataInv(xs, m) {
    unfold placeTypedByAtTrail(xs, PlaceType.isStructuredData(), m, trail);
    if (trail == PlaceTypeTrail.isDeref(trail.PlaceTypeTrail.derefTrail)){
      assert (xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref));
      assert placeTypedByAtTrail(m[xs.RustValue.borrowNameForDeref],
        PlaceType.isStructuredData(),
        m,
        trail.PlaceTypeTrail.derefTrail);
      placeTypeImpliesDataInv(m[xs.RustValue.borrowNameForDeref], m, trail.PlaceTypeTrail.derefTrail);
      dataInvFromBorrow(xs, m);
      var newTrail: PlaceTypeTrail;
      unfold placeTypedBy(m[xs.RustValue.borrowNameForDeref], PlaceType.isYoinked(), m)[newTrail := trail];
      fold placeTypedByAtTrail(xs, PlaceType.isYoinked(), m, PlaceTypeTrail.isDeref(newTrail));
      fold placeTypedBy(xs, PlaceType.isYoinked, m)[trail := PlaceTypeTrail.isDeref(newTrail)];
    } else if (trail == PlaceTypeTrail.structuredData(trail.PlaceTypeTrail.trailForSD)){
      assert (isStructuredDataIsTypedBy(xs, m, trail.PlaceTypeTrail.trailForSD));
      unfold isStructuredDataIsTypedBy(xs, m, trail.PlaceTypeTrail.trailForSD);
      fold isYoinkedIsTypedBy(xs, m, trail.PlaceTypeTrail.trailForSD);
      fold placeTypedByAtTrail(xs, PlaceType.isYoinked(), m, PlaceTypeTrail.yoinked(trail.PlaceTypeTrail.trailForSD));
      fold placeTypedBy(xs, PlaceType.isYoinked, m)[trail := PlaceTypeTrail.yoinked(trail.PlaceTypeTrail.trailForSD)];
    }
  }
}

field place: RustValue;

module AgreeI = Library.Agree[Library.IntType];
interface VecI: DataInvariant {
  field pointedCap: AgreeI;
  field pointedArr: RustValue;
  val tag: TypeTag;
  val vecType: TypeTag = TypeTag.isStructOf(3, {|i: Int :: (i == 0) ? TypeTag.isInt(): ((i == 1) ? TypeTag.isInt(): TypeTag.isArrayOf(tag))|});
  val lenForSD: Int = 1;
  val mapForSD: Map[Int, PlaceType] = {|i: Int :: PlaceType.isRawPointer()|};

  pred dataInvForStruct(rustValue: RustValue, m: ResolutionMap) {
    (m[rustValue.RustValue.mapForStruct[0]] == RustValue.rawPointer((m[rustValue.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed))
    &&
    (exists cap: Int :: (exists arr: RustValue :: exists len: Int :: own(rustValue.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len))
    &&
    (isProphecy(rustValue.RustValue.referenceToPointed)
    &&
    isTypedBy((m[rustValue.RustValue.referenceToPointed]), vecType, m)
    &&
    (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[0]] == RustValue.literalInt(cap))
    &&
    (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[1]] == RustValue.literalInt(len))
    &&
    (m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[2]] == arr)
    &&
    (forall i: Int :: (0 <= i < len)
    ==>
    ((m[arr.RustValue.mapForArray[i]] != RustValue.uninit())))
    &&
    (forall i: Int :: (len <= i < cap)
    ==>
    (m[arr.RustValue.mapForArray[i]] == RustValue.uninit())))))
  }

  pred dataInv(rustValue: RustValue, m: ResolutionMap) {
    (rustValue == RustValue.isDeref(rustValue.RustValue.borrowNameForDeref) ==> dataInv(m[rustValue.RustValue.borrowNameForDeref], m))
    &&
    (rustValue == RustValue.struct(1, rustValue.RustValue.mapForStruct) ==> dataInvForStruct(rustValue, m))
    &&
    ((rustValue != RustValue.isDeref(rustValue.RustValue.borrowNameForDeref) && rustValue != RustValue.struct(1, rustValue.RustValue.mapForStruct) ==> false))
  }

  pred isReborrowedAtIndex(rustValue: RustValue, idx: Int, prophecy: Ref, m: ResolutionMap) {
    ((rustValue == RustValue.isDeref(rustValue.RustValue.borrowNameForDeref)) ==>
      isReborrowedAtIndex(m[rustValue.RustValue.borrowNameForDeref], idx, prophecy, m)) &&
    ((rustValue == RustValue.rawPointer(rustValue.RustValue.referenceToPointed)) ==>
     (isProphecy(prophecy) && (exists arr: RustValue :: m[(m[rustValue.RustValue.referenceToPointed]) . RustValue.mapForStruct[2]] == arr && (m[arr.RustValue.mapForArray[i]] == m[prophecy])))) &&
     (((rustValue != RustValue.isDeref(rustValue.RustValue.borrowNameForDeref)) &&
      (rustValue != RustValue.rawPointer(rustValue.RustValue.referenceToPointed))) ==> false)
  }

  pred isReborrowedWithProphecy(xs: RustValue, idx: Int, m: ResolutionMap) {
    exists prophecy: Ref ::
    isReborrowedAtIndex(xs, idx, prophecy, m)
  }

  pred isVectorStruct(xs: RustValue, len: Int, m: ResolutionMap) {
    exists trail: PlaceTypeTrail :: own(xs.RustValue.mapForStruct[0], pointedCap, AgreeI.agree(len)) &&
    placeTypedByAtTrail(xs, PlaceType.isStructuredData(), m, trail) &&
    isProphecy((m[xs.RustValue.mapForStruct[0]]) . RustValue.referenceToPointed)
  }

  pred isVector(xs: RustValue, len: Int, m: ResolutionMap) {
    ((xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref)) ==>
     isVector(m[xs.RustValue.borrowNameForDeref], len, m)) &&
    ((xs == RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct)) ==>
     isVectorStruct(xs, len, m)) &&
    (((xs != RustValue.isDeref(xs.RustValue.borrowNameForDeref)) && (xs != RustValue.struct(xs.RustValue.lenForStruct, xs.RustValue.mapForStruct))) ==> false)
  }

  proc getUncheckedMut(xs: RustValue, idx: Int, len: Int, m: ResolutionMap)
    requires isVector(xs, len, m) && (0 <= idx < len)
    ensures isVector(xs, len, m) && isReborrowedWithProphecy(xs, idx, m)
  {
    unfold isVector(xs, len, m);
    if (xs == RustValue.isDeref(xs.RustValue.borrowNameForDeref)) {
      getUncheckedMut(m[xs.RustValue.borrowNameForDeref], idx, len, m);
      var prophecy: Ref;
      unfold isReborrowedWithProphecy(m[xs.RustValue.borrowNameForDeref], idx, m)[prophecy := prophecy];
      fold isReborrowedAtIndex(xs, idx, prophecy, m);
      fold isReborrowedWithProphecy(xs, idx, m)[prophecy := prophecy];
      fold isVector(xs, len, m);
    } else {
      var trail: PlaceTypeTrail;
      unfold isVectorStruct(xs, len, m)[trail := trail];
      placeTypeImpliesDataInv(xs, m, trail);
      assume false;
      //
    }
  }
}
