import Library.Type

module Option[E: Type] {
  rep type T = data {
    case none
    case some(x: E)
  }
}

module List[E: Type] {
  rep type T = data {
    case nil
    case cons(hd: E, tl: T) 
  }
}

module Stack[T: Type] {

  module TOption = Option[T]
  module TList = List[T]
  import TList._
  import TOption._

  field head: Ref
  field next: Ref
  field value: T


  pred is_list(x: Ref; xs: TList) {
    x == null ? 
      xs == nil : 
      (xs != nil && (exists tl0: Ref, q: Real ::  q > 0.0 && (own(x, value, xs.hd, q) && own(x, next, tl0, q) && is_list(tl0, xs.tl))))
  }

  pred is_stack(s: Ref; xs: TList) {
    exists x: Ref :: (is_list(x, xs) && own(s, head, x, 1.0))
  }

  proc push(s: Ref, x: T, implicit ghost xs: TList)
    atomic requires is_stack(s, xs)
    atomic ensures is_stack(s, cons(x, xs))
  {
    ghost val phi: AtomicToken := bindAU();
    ghost val xs0: TList := openAU(phi);

    unfold is_stack(s, xs0);
    var top: Ref := s.head;
    fold is_stack(s, xs0);

    abortAU(phi);

    var s0 : Ref;
    s0 := new(value: x, next: top);

    ghost val xs1: TList := openAU(phi);

    ghost val top1: Ref;
    unfold is_stack(s, xs1);
    top1 :| is_list(top1, xs1) && own(s, head, top1, 1.0);
  
    var res: Bool := cas(s.head, top, s0);

    {!
      if (res) {
        assert   
          (s0 == null ? 
            cons(x, xs1) == nil : 
            (cons(x,xs1) != nil && (1.0 > 0.0 && (own(s0, value, cons(x, xs1).hd, 1.0) && own(s0, next, top1, 1.0) && is_list(top1, cons(x, xs1).tl)))));

        fold is_list(s0, cons(x, xs1)); 
        fold is_stack(s, cons(x, xs1));
        commitAU(phi);
      } else {
        fold is_stack(s, xs1);
        abortAU(phi);
      }
    !}

    if (!res) { 
      var xs2: TList := openAU(phi);
      push(s, x);
      commitAU(phi);
    }
  }

  proc pop(s: Ref, implicit ghost xs: TList)
    returns (result: TOption)
    atomic requires is_stack(s, xs)
    atomic ensures 
      xs == nil ? 
        (is_stack(s, xs) && result == none) : 
        (is_stack(s, xs.tl) && result == some(xs.hd))
  {
    ghost val phi: AtomicToken := bindAU();
    ghost val xs0: TList := openAU(phi);

    unfold is_stack(s, xs0);

    var top: Ref := s.head;
  
    {!
      if (top == null) {
        unfold is_list(top, xs0);
        fold is_list(top, xs0);
        fold is_stack(s, xs0);
        commitAU(phi, none);
      } else {
        ghost val q: Real;
        ghost val tl0: Ref;
        unfold is_list(top, xs0);

        tl0, q :| 
          top == null ? 
          xs0 == nil : 
          (xs0 != nil && (q > 0.0 && (own(top, value, xs0.hd, q) && own(top, next, tl0, q) && is_list(tl0, xs0.tl))));
      
        assert top == null ? 
          xs0 == nil : 
          (xs0 != nil && (q/2.0 > 0.0 && (own(top, value, xs0.hd, q/2.0) && own(top, next, tl0, q/2.0) && is_list(tl0, xs0.tl))));
      
        fold is_list(top, xs0);
        fold is_stack(s, xs0);
        abortAU(phi);
      }
    !}

    if (top == null) {
      return none;
    }

    val top_next: Ref := top.next;
    val top_value: T := top.value;

    ghost val xs1: TList := openAU(phi);

    ghost val top1: Ref;
    unfold is_stack(s, xs1);
    top1 :| is_list(top1, xs1) && own(s, head, top1, 1.0);

    var res: Bool := cas(s.head, top, top_next);

    {!
      if (res) {
        unfold is_list(top1, xs1);
        fold is_stack(s, xs1.tl);
        commitAU(phi, some(top_value));
      } else {
        fold is_stack(s, xs1);
        abortAU(phi);
      }

    !}

    if (res) {
      return some(top_value);
    } else { 
      ghost val xs2: TList := openAU(phi);
      val ret: TOption := pop(s);
      commitAU(phi, ret);

      return ret;
    }
  }
}