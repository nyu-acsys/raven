include "lock.rav"

interface SpinLock : Lock {
  field bit: Bool
  
  pred lockRep(l: Ref; b: Bool) {
    own(l, bit, b, 1.0)
  }

  proc create(x: Ref)
    requires exists l0: Ref :: own(x, lock, l0, 1.0) && resource(x)
    ensures is_lock(x, false)
  {
    var l: Ref;
    l := new (bit: false);
    fold lockRep(l, false);
    x.lock := l;
    assert own(x, lock, l, 1.0) && lockRep(l, false) && (false ? true : resource(x));
    fold is_lock(x, false);
  }

  /*proc acquire(x: Ref, implicit ghost b: Bool)
    atomic requires is_lock(x, b)
    atomic ensures is_lock(x, true) && resource(x)
  {
    ghost val phi: AtomicToken = bindAU();
    
    var l: Ref; 
    ghost var q: Real; ghost var l1: Ref;
    ghost var b1 : Bool := openAU(phi);
    unfold is_lock(x, b1);
    l1, q :| own(x, lock, l1, q);
    l := x.lock;
    assert own(x, lock, l, q/2.0) && lockRep(l, b1) && (b1 ? true : resource(x));
    fold is_lock(x, b1);
    abortAU(phi);
    
    b1 := openAU(phi);
    unfold is_lock(x, b1);
    unfold lockRep(l, b1);
    val res: Bool := cas(l.bit, false, true);
    {!
      fold lockRep(l, b1 == false);
      assert own(x, lock, l, q/2.0) && lockRep(l, b1 == false) && (b1 == false ? true : resource(x));
      fold is_lock(x, b1 == false);
      if (res) {
        commitAU(phi);
      } else {
        abortAU(phi);
      }
    !}

    if (res) {
      return;
    }

    b1 := openAU(phi);
    assert is_lock(x, b1);
    acquire(x);
    commitAU(phi);
  }
  */
  /*proc release(l: Ref)
    atomic requires lockR(l, true) && lockResource(l)
    atomic ensures lockR(l, false)
  {
    ghost val phi: AtomicToken = bindAU();  
    openAU(phi);
    unfold lockR(l, true);
    l.bit := false;
    fold lockR(l, false);
    commitAU(phi);
  }*/
}


