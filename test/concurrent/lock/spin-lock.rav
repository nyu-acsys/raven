interface Lock {
  field bit: Bool
  
  pred lockResource(l: Ref)

  pred lockR(l: Ref, implicit ghost b: Bool) {
    own(l, bit, b, 1.0) && 
    (b ? true : lockResource(l))
  }

  proc allocResource(l: Ref)
    ensures lockResource(l)

  proc create()
    returns (l: Ref)
    ensures lockR(l, false)
  {
    l := new (bit: false);
    allocResource(l);
    fold lockR(l, false);
  }

  proc acquire(l: Ref, implicit ghost b: Bool)
    atomic requires lockR(l, b)
    atomic ensures lockR(l, true) && lockResource(l)
  {
    ghost val phi: AtomicToken = bindAU();
    
    ghost var b1 : Bool := openAU(phi);
    unfold lockR(l, b1);

    val res: Bool := cas(l.bit, false, true);

    {!
      if (res) {
        fold lockR(l, true);
        commitAU(phi);
      } else {
        fold lockR(l, b1);
        abortAU(phi);
      }
    !}

    if (res) {
      return;
    }

    b1 := openAU(phi);
    assert lockR(l, b1);
    acquire(l);
    commitAU(phi);
  }

  proc release(l: Ref)
    atomic requires lockR(l, true) && lockResource(l)
    atomic ensures lockR(l, false)
  {
    ghost val phi: AtomicToken = bindAU();  
    openAU(phi);
    unfold lockR(l, true);
    l.bit := false;
    fold lockR(l, false);
    commitAU(phi);
  }
}


