interface Lock {
  module R: Library.Type

  module Agree = Library.Agree[R]

  ghost field agr: Agree
  
  // Resource protected by the lock
  pred resource(r: R)

  // Lock representation invariant
  pred lock_rep(l: Ref; b: Bool)

  // Abstract predicate describing a lock 
  pred is_lock(l: Ref; r: R, b: Bool) {
    own(l, agr, Agree.agree(r)) 
    && lock_rep(l, b)
    && (b ? true : resource(r))
  }

  proc create(r: R)
    returns (l: Ref)
    requires resource(r)
    ensures is_lock(l, r, false)

  proc acquire(l: Ref, implicit ghost r: R, implicit ghost b: Bool)
    atomic requires is_lock(l, r, b)
    atomic ensures is_lock(l, r, true) && b == false && resource(r)

  proc release(l: Ref, implicit ghost r: R)
    atomic requires is_lock(l, r, true) && resource(r)
    atomic ensures is_lock(l, r, false)
}
