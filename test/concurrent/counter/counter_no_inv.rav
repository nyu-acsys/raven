field c: Int

pred counter(x: Ref; v: Int) {
  own(x.c, v, 1.0)
}

proc incr(x: Ref, implicit ghost v: Int) 
  atomic requires counter(x, v)
  atomic ensures counter(x, v + 1)
{
  ghost var phi: AtomicToken := bindAU();

  var v1: Int;

  ghost var v2: Int := openAU(phi);

  unfold counter(x, v2);
  v1 := x.c;
  fold counter(x, v2);
  
  abortAU(phi);
  
  var new_v1 : Int := v1 + 1;

  ghost var v3: Int := openAU(phi);

  unfold counter(x,v3);

  var res: Bool := cas(x.c, v1, new_v1);
  
  {! 
    if (res) {
      fold counter(x, new_v1);
      commitAU(phi);
    } else {
      fold counter(x, v3);
      abortAU(phi);
    }
  !}

  if (!res) {
    ghost var v4: Int := openAU(phi);
    incr(x);
    commitAU(phi);
  }
}

proc read(x: Ref, implicit ghost v: Int)
  returns (v2: Int)
  atomic requires counter(x, v)
  atomic ensures counter(x, v) && v2 == v
  ensures v2 == v

{
  ghost var phi: AtomicToken := bindAU();

  ghost var v1: Int := openAU(phi);
  unfold counter(x, v1);

  var v3: Int := x.c;
  
  fold counter(x, v1);
  commitAU(phi, v3);

  return v3;
}