module Lock {
  rep type t = struct {
    var bit: Bool
  }
  
  pred lock(l: t, b: Bool) {
    own(l.bit, b) 
  }

  proc create()
    returns (l: t)
    ensures lock(l, false)
  {
    l := new t;
    l.bit := false;
    
    {! 
    	fold lock(l, false);
    !}
  }

  proc acquire(l: t, implicit ghost b: Bool)
    atomic requires lock(l, b)
    atomic ensures lock(l, true) && b == false
  {
    {! 
      var phi: AtomicToken;
      phi := bindAU();
    	var b: Bool;
      b := openAU(phi);

    	unfold lock(l, b); 
    !}
    
    var res: Bool;
    /* val res := cas(l.bit, false, true); */

    if (l.bit) { /* can use l.bit OR b*/
      res := false;
     }
    
    else {
      res := true;
    }

    {!
      if (res) {
      	fold lock(l, true);
      	commitAU(phi);
      } else {
      	fold lock(l, false); 
      	abortAU(phi);
      }	
    !}
    
    if (!res) {
    	acquire(l);
    }
  }

  proc release(l: t)
    atomic requires lock(l, true)
    atomic ensures lock(l, false)
  {
  	{! 
  		var phi: AtomicToken;
      phi := bindAU();
      openAU(phi);
  		unfold lock(l, true);
  	!}
 
    l.bit := false;
    
    {!
    	fold lock(l, true);
    	commitAU(phi);
    !}
  }
}


interface Keyspace {
  rep type t
  val ks: Set[t]
}

module IntKeyspace : Keyspace {
  rep type t = Int

  val ks = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type op = data { case searchOp; case insertOp; case deleteOp }

/*  pred opSpec(op: op, k: K, c: Set[K], c': Set[K], res: Bool) {
    match(op) {
     case searchOp => C' == C && res == (k in C)
     case insertOp => C' == C ++ {|k|} && res == (k !in C)
     case insertOp => C' == C -- {|k|} && res == (k in C)
    }
  } */
}

interface NodeImpl[K: Keyspace] {
  /* import K.ks */
  import K
  /* Need to figure out uppercase/lowercase for these commands.*/
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type t

  pred nodeR(n: t, c: Set[k])

  proc create()
    returns (n: t)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: op, n: t, k: k, implicit ghost c: Set[k])
    returns (res: Bool, implicit ghost c': Set[k])
    requires k in ks && node(n, c)
    ensures nodeR(n, c') && opSpec(dop, k, c, c', res)
}

interface SearchStructure[K: Keyspace] {
  /* import K.ks */
  import K
  module Spec = SearchStructureSpec[K]
  import Spec

  type css

  pred cssR(r: css, c: Set[K])

  inv cssInv(r: CSS)

  proc create()
    returns (r: CSS)
    ensures cssInv(r) && cssR(r, {||})
    /* What does `inv(cssI, cssInv(r))` mean? */

  proc cssOp(dop: op, r: css, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
    requires k in ks && cssInv(r)
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c') && opSpec(dop, k, c, c', res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] : SearchStructure[K] {
  import K
  import Node

  module FracSK = Frac[Set[K]]

  type css = struct {
    var lock: Lock
    var node: Node
    ghost var cont_lock: FracSK
    ghost var cont_spec: FracSK
  }
  
  pred nodePred(r: css, implicit ghost c: Set[K]) {
    nodeR(r.node, c) && own(r.cont_lock.frac(1/2, c))
  }

  pred cssAuth(r: css, c: Set[K]) {
    own(r.cont_spec.frac(1/2, c))
  }

  pred cssR(r: css, c: Set[K]) {
    own(r.cont_spec.frac(1/2, c))
  }

  pred cssInv(r: css, implicit ghost b: Bool, implicit ghost c: Set[K]) {
    cssAuth(r, c)
    && own(r.cont_lock.frac(1/2, c))
    && Lock.lock(r.lock, b) && (b ? true : nodePred(r))
  }

  proc create()
    returns (r: css)
  {
    var l: Lock = Lock.create();
    var n: Node = Node.create();
    
    var r: CSS = new css;
    r.lock := l;
    r.node := n;
    r.cont_lock := frac(1, {||});
    r.cont_spec := (frac(1, {||}));

    /*var r: CSS = new(lock(l), node(n), cont_lock(frac(1, {||})), cont_spec(frac(1, {||})) */
    
    {!
    	/* check how dafny does it: uses assert */
    	/* exists: false, {||} */

			/* Not sure how symbolic execution is supposed to figure out where to apply this */
			assert frac(1, {||}) == (frac(1/2, {||}) * frac(1/2, {||}));
    	 	 
    	fold(cssAuth(r, {||}));  	

    	assert cssAuth(r, c)
      				&& own(r.cont_lock.frac(1/2, c))
      				&& Lock.lock(r.lock, b) && (b ? true : nodePred(r));
    	fold(cssInv(r));
      /*createInv cssI cssInv(r);*/

    	fold cssR(r, {||});
    !} 
  }

  proc cssOp(dop: op, r: css, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
  {
    {!
    	unfold cssI;
    	unfold cssInv(r, b0, c0);
    	fold Lock.lock(r.lock, b0);
    !}
    
    acquire(r.lock);
    
    {!
    	assert b0 == false;
    	assert nodePred(r);
    	unfold Lock.lock(r.lock, true);
    	fold cssInv(r, true, c0);
    	unfold nodePred(r, c0');
    !} 
    
    res, c1 := decisiveOp(dop, r, k);

		{!
			unfold cssInv;
			unfold cssInv(r, b1, c1');

			/* lemma below asserts C0' = C1' 

      lemma frac_eq(l: loc, )

      */

			frac_eq((r.cont_lock), 1/2, 1/2, c0', c1');

			/* lemma below sums up fractional resources */
			frac_sum((r.cont_lock), 1/2, 1/2, c0');
			
			/* lemma frac_update l C C' : 
						own(l.frac(1, C)) ~~> own(l.frac(1, C')) */
			frac_update((r.cont_lock), c0', c1);

			fold nodePred(r, c1);
			
			val phi: AtomicToken;
      phi := bindAU();
      c1'' := openAU(phi);
			
			unfold cssAuth(r, c0');
			unfold cssR(r, c1'');
			frac_eq((r.cont_spec), 1/2, 1/2, c0', c1'');
			frac_sum((r.cont_spec), 1/2, 1/2, c0');
			frac_update((r.cont_spec), c0', c1);
			
			fold cssAuth(r, c1);
			fold cssR(r, c1);
			commitAU(phi);

			assert b1 == true;
			fold Lock.lock(r, true);				
		!}

    release(r.lock);
    
    {!
    	unfold Lock.lock(r, false);
    	fold cssInv(r, false, c1);
    !}    
  }
}
