module Lock {
  rep type T = Ref
  
  field bit: Bool
  
  pred lock(l: Ref, b: Bool) {
    own(l, bit, b, 1.0) 
  }

  proc create()
    returns (l: T)
    ensures lock(l, false)
  {
    l := new(bit:false);
    // l.bit := false;
    
    {! 
    	fold lock(l, false);
    !}
  }

  proc acquire(l: T, implicit ghost b: Bool)
    // atomic requires lock(l, b)
    requires lock(l, b)
    // atomic ensures lock(l, true) && b == false
    ensures lock(l, true) // && b == false
  {
    {! 
      // var phi: AtomicToken;
      // phi := bindAU();
    	// var b: Bool;
      // b := openAU(phi);
      // inhale(lock(l,b));

      // havoc b?

    	unfold lock(l, b); 
    !}
    
    var res: Bool;
    /* val res := cas(l.bit, false, true); */

    if (l.bit) { /* can use l.bit OR b*/
      res := false;
     }
    
    else {
      res := true;
      l.bit := true;
    }

    {!

      if (res) {
      	fold lock(l, true);
      	// commitAU(phi);
        assert (lock(l, true) && b == false);
      } else {
      	fold lock(l, true);
        // abortAU(phi);
      	assert(lock(l, b));
      }
    !}
    
    if (!res) {
    	acquire(l, b);
    }
  }

  proc release(l: T)
    // atomic requires lock(l, true)
    // atomic ensures lock(l, false)
    requires lock(l, true)
    ensures lock(l, false)
  {
  	{! 
  		// var phi: AtomicToken;
      // phi := bindAU();
      // openAU(phi);
  		unfold lock(l, true);
  	!}
 
    l.bit := false;
    
    {!
    	fold lock(l, false);
    	// commitAU(phi);
      assert (lock(l, false));
    !}
  }
}


interface Keyspace {
  rep type T
  val ks: Set[T]
}

// module IntKeyspace : Keyspace {
//   rep type T = Int

//   val ks: Set[T] = {| k: Int :: true |}
// }

module SearchStructureSpec[K: Keyspace] {

  type Op = data { case searchOp; case insertOp; case deleteOp }

  pred opSpec(op: Op, k: K, c: Set[K], c1: Set[K], res: Bool) {
    op == searchOp() ?
      c1 == c && res == (k in c) :
    (op == insertOp() ?
      c1 == c ++ {|k|} && res == (k !in c) :
    
    // op == deleteOp 
      c1 == c -- {|k|} && res == (k in c)
    )
  }
}

interface NodeImpl[K: Keyspace] {
  /* import K.ks */
  // import K
  /* Need to figure out uppercase/lowercase for these commands.*/
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type T

  pred nodeR(n: T, c: Set[Spec.K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Spec.Op, n: T, k: Spec.K, implicit ghost c: Set[Spec.K])
    returns (res: Bool, implicit ghost c1: Set[Spec.K])
    // returns (res: DecisiveOpRet)
    requires k in Spec.K.ks && nodeR(n, c)
    ensures nodeR(n, c1) && Spec.opSpec(dop, k, c, c1, res)
}

interface SearchStructure[K: Keyspace] {
  /* import K.ks */
  // import K
  module Spec = SearchStructureSpec[K]
  // import Spec

  type CSS

  pred cssR(r: CSS, c: Set[Spec.K])

  inv cssInv(r: CSS)

  proc create()
    returns (r: CSS)
    ensures cssInv(r) && cssR(r, {||})

  proc cssOp(dop: Spec.Op, r: CSS, k: Spec.K, implicit ghost c: Set[Spec.K])
    returns (res: Bool, implicit ghost c1: Set[Spec.K])
    requires k in Spec.K.ks && cssInv(r)
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c1) && Spec.opSpec(dop, k, c, c1, res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] /* : SearchStructure[K] */ {
  // import K
  import Node

  module M_temp : Lib.Type {
    rep type T = Set[Node.Spec.K]
  }

  module FracSK = Lib.Frac[M_temp]

  type CSS = Ref
  
  
  field lock: Lock
  field node: Node
  
  //ghost fields
  field cont_lock: FracSK
  field cont_spec: FracSK
  
  pred nodePred(r: CSS, implicit ghost c: Set[Node.Spec.K]) {
    Node.nodeR(r.node, c) && own(r, cont_lock, FracSK.frac_chunk(c, 1.0/2.0))
  }

  pred cssAuth(r: CSS, c: Set[Node.Spec.K]) {
    own(r, cont_spec, FracSK.frac_chunk(c, 1.0/2.0))
  }

  pred cssR(r: CSS, c: Set[Node.Spec.K]) {
    own(r, cont_spec, FracSK.frac_chunk(c, 1.0/2.0))
  }

  pred cssInv(r: CSS, implicit ghost b: Bool, implicit ghost c: Set[Node.Spec.K]) {
    cssAuth(r, c)
    && own(r, cont_lock, FracSK.frac_chunk(c, 1.0/2.0))
    && Lock.lock(r.lock, b) && (b ? true : nodePred(r))
  }

  proc create()
    returns (r: CSS)
    ensures cssInv(r) && cssR(r, {||})
  {
    var l1: Lock;
    l1 := Lock.create();
    var n: Node = Node.create();
    
    // var r: CSS;
    r := new(lock:l1, node:n, cont_lock: FracSK.frac_chunk({||}, 1.0), cont_spec: FracSK.frac_chunk({||}, 1.0));
    
    {!
    	/* check how dafny does it: uses assert */
    	/* exists: false, {||} */

			/* Not sure how symbolic execution is supposed to figure out where to apply this */
			// assert frac(1, {||}) == (frac(1/2, {||}) * frac(1/2, {||}));
    	 	 
    	fold cssAuth(r, {||});

      fold nodePred(r);

    	// assert cssAuth(r, {||})
      //   && own(r, cont_lock, {||}, 1.0/2.0)
        // && Lock.lock(r.lock, b) && (b ? true : nodePred(r));
    	fold cssInv(r);
      /*createInv cssI cssInv(r);*/

    	fold cssR(r, {||});
    !} 
  }

  proc cssOp(dop: Node.Spec.Op, r: CSS, k: Node.Spec.K, implicit ghost c: Set[Node.Spec.K], implicit ghost l50: Ref)
    returns (res: Bool, implicit ghost c1: Set[Node.Spec.K])
    requires k in Node.Spec.K.ks
    requires own(r, lock, l50, 1.0)
    // requires cssInv(r)							
    // atomic requires cssR(r, c)
    // requires cssR(r, c)
    // atomic ensures cssR(r, c1) && opSpec(dop, k, c, c1, res)
    // ensures cssR(r, c1) && Node.Spec.opSpec(dop, k, c, c1, res)
  {
    var b0: Bool;
    var c0: Set[Node.Spec.K];

    {!
    	// unfold cssI;
      inhale cssInv(r);

      // asserting above is useless for three reasons:
      // 1. Currently asserting only checks whether stmt is valid. Does not actually assert it again to help the solver. This should be changed.
      // 2. In the current implementation, predHeaps don't store implicit ghost variables. So b0, c0 are already being dropped before even asserting the pred.

      assume cssInv(r, b0, c0);
      // EG: Even if we add implicit ghost vars to PredHeaps, how will that solve the binding problem? 

    	unfold cssInv(r, b0, c0);

    	// fold Lock.lock(r.lock, b0);
      // no need to fold since the lock is already given to us by the invariant.
    !}

    // Lock.acquire(r.lock);
    assert (exists b: Bool :: Lock.lock(r.lock,b));

    var b1: Bool;
    assume Lock.lock(r.lock,b1);
    exhale Lock.lock(r.lock,b1);
    
    inhale Lock.lock(r.lock, true) && b1 == false;
    
    var c0_0: Set[Node.Spec.K];

    {!
    	assert b0 == false;
    	assert nodePred(r);
    	// unfold Lock.lock(r.lock, true);
    	fold cssInv(r, true, c0);
    	unfold nodePred(r, c0_0);
    !}

    // res, c1 := Node.decisiveOp(dop, r.node, k, c0_0);
    exhale k in Node.Spec.K.ks && Node.nodeR(r.node,c);
    inhale nodeR(r.node,c1) && Node.Spec.opSpec(dop, k, c0_0, c1, res);

    ghost var b2: Bool = true;
    ghost var c1_0: Set[Node.Spec.K];

		{!
			// unfold cssInv;
      assert cssInv(r, b2, c1_0);
			unfold cssInv(r, b2, c1_0);

			/* lemma below asserts C0' = C1' 

      lemma frac_eq(l: loc, )

      */

			// frac_eq((r.cont_lock), 1/2, 1/2, c0_0, c1_0);

			/* lemma below sums up fractional resources */
			// frac_sum((r.cont_lock), 1/2, 1/2, c0_0);
			
			/* lemma frac_update l C C' : 
						own(l, frac(1, C)) ~~> own(l, frac(1, C')) */
			fpu(r, cont_lock, FracSK.frac_chunk(c1, 1.0));

			fold nodePred(r, c1);
			
			// val phi: AtomicToken;
      // phi := bindAU();
      // c1_1 := openAU(phi);
			
			unfold cssAuth(r, c0_0);
			unfold cssR(r, c);

			// frac_eq((r.cont_spec), 1/2, 1/2, c0_0, c);
			// frac_sum((r.cont_spec), 1/2, 1/2, c0_0);
			// frac_update((r.cont_spec), c0_0, c1);
			
      fpu(r, cont_spec, FracSK.frac_chunk(c1, 1.0));

			fold cssAuth(r, c1);
			fold cssR(r, c1);
			// commitAU(phi);

			assert b2 == true;
			assert Lock.lock(r.lock, true);				
		!}

    Lock.release(r.lock);
    
    {!
    	// unfold Lock.lock(r.lock, false);
    	fold cssInv(r, false, c1);
    !}    
  }
}
