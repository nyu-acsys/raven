module Lock {

  field bit: Bool
  
  pred lock(l: Ref, b: Bool) {
    own(l, bit, b, 1.0) 
  }

  proc create()
    returns (l: Ref)
    ensures lock(l, false)
  {
    l := new(bit:false);
    
    {! 
      fold lock(l, false);
    !}
  }

  proc acquire(l: Ref, implicit ghost b: Bool)
    atomic requires lock(l, b)
    atomic ensures lock(l, true) && b == false
  {
    val phi: AtomicToken := bindAU();
    val b1: Bool;
    b1 := openAU(phi);
    unfold lock(l, b1); 

   	// val res = cas(l.bit, false, true); 
    ghost var res: Bool;
    {!
      ghost var curr_val: Bool := l.bit;

      if (curr_val == false) {
        l.bit := true;
        res := true;
      } else {
        res := false;
      }
    !}

    {!
      if (res) {
        fold lock(l, true);
        commitAU(phi);
        
      } else {
        fold lock(l, b1);
        // fold lock(l, false); // <-- this is not working
        abortAU(phi);
      }	
    !}

    if (!res) {
      val b2: Bool;
      b2 := openAU(phi);
			assert lock(l, b2);
			acquire(l);
			commitAU(phi);
    }	
  }

  proc release(l: Ref)
    atomic requires lock(l, true)
    atomic ensures lock(l, false)
  {
    val phi: AtomicToken;
    {! 
      phi := bindAU();
      openAU(phi);
      unfold lock(l, true);
    !}
 
    l.(Lock.bit) := false;
    
    {!
      fold lock(l, false);
      commitAU(phi);
    !}
  }
}

// interface Keyspace {
//   rep type T

//   val keyset: Set[T]
// }

// module IntKeyspace : Keyspace {
//   rep type T = Int

//   val keyset: Set[T] = {| k: Int :: true |}
// }

interface SearchStructureSpec {
  type K
  val keyset: Set[K]

  type Op = data { case searchOp ; case insertOp ; case deleteOp }

	pred opSpec(op: Op, k: K, c_in: Set[K], c_out: Set[K], res: Bool) {
    op == searchOp() ? 
      c_in == c_out && res == (k in c_in) :
    op == insertOp() ?
      c_out == c_in ++ {| k |} && res == (k !in c_in) :
      c_out == c_in -- {| k |} && res == (k in c_in)
	}
}

interface NodeImpl {

  module Spec : SearchStructureSpec
  // import Spec
  import Spec.K
  import Spec.Op
  import Spec.opSpec
  import Spec.keyset

  pred nodeR(n: Ref; c: Set[K])

  proc create()
    returns (n: Ref)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Op, n: Ref, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c1: Set[K])
    requires k in keyset 
    requires nodeR(n, c)
    ensures nodeR(n, c1) && opSpec(dop, k, c, c1, res)

  lemma nodeSepStar(n: Ref, c1: Set[K], c2: Set[K])
    requires nodeR(n, c1) && nodeR(n, c2)
    ensures false
}

interface SearchStructure {

  module Spec: SearchStructureSpec
  import Spec.K
  import Spec.Op
  import Spec.opSpec
  import Spec.keyset

  pred cssR(r: Ref, c: Set[K])

  // inv cssInv(r: Ref)

  proc create()
    returns (r: Ref)
    ensures cssR(r, {||})

  // proc cssOp(dop: Op, r: Ref, k: K, implicit ghost c: Set[K])
  //   returns (res: Bool, implicit ghost c1: Set[K])
  //   requires k in keyset
  //   // requires cssInv(r)
  //   atomic requires cssR(r, c)
  //   atomic ensures cssR(r, c1) && opSpec(dop, k, c, c1, res)
}

interface SingleNodeTemplate[Node: NodeImpl] {
  field lock: Bool

  // module KeyMod : Library.Type {
  //   rep type T = Set[Node.Spec.K]
  // }

  // module FracSK = Node.Spec.K


  module Spec: SearchStructureSpec = Node.Spec

  // import Node.Spec.K
  // import Node.Spec.Op
  // import Node.Spec.opSpec
  // import Node.Spec.keyset

  // import Spec._
  import Node.Spec._

  // import Spec.K
  // import Spec.Op
  // import Spec.opSpec
  // import Spec.keyset

  field frac: Set[K];

  pred cssR(r: Ref, c: Set[K]) {
      exists b: Bool :: own(r, frac, c, 0.5) && own(r, lock, b, 1.0) && 
      (b ? true : (Node.nodeR(r, c) && own(r, frac, c, 0.5)))
  }


  proc lockNode(n: Ref, implicit ghost b: Bool)
    atomic requires own(n, lock, b, 1.0)
    atomic ensures own(n, lock, true, 1.0) && b == false

  proc unlockNode(n: Ref)
    atomic requires own(n, lock, true, 1.0)
    atomic ensures own(n, lock, false, 1.0)


  proc create()
    returns (r: Ref)
    ensures cssR(r, {||})
  {
    r := Node.create();
    r := new(lock:false, frac:{||});
    assert own(r, frac, {||}, 0.5) && own(r, lock, false, 1.0) && 
      (false ? true : (Node.nodeR(r, {||}) && own(r, frac, {||}, 0.5)));
    // assert own(r, lock, false, 1.0) && (false ? true : Node.nodeR(r, {||}));
    fold cssR(r, {||});
  }

  proc cssOp(dop: Op, r: Ref, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c_ret: Set[K])
    requires k in keyset
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c_ret) && opSpec(dop, k, c, c_ret, res)
  {
    var phi: AtomicToken := bindAU();

    var c0: Set[K];
    ghost var b: Bool;

    c0 := openAU(phi);
    unfold cssR(r, c0);
    b :| own(r, frac, c0, 0.5) && own(r, lock, b, 1.0) && (b ? true : (Node.nodeR(r, c0) && own(r, frac, c0, 0.5)));
    lockNode(r, b);
    assert b == false;
    assert own(r, frac, c0, 0.5) && own(r, lock, true, 1.0) && 
      (true ? true : (Node.nodeR(r, c0) && own(r, frac, c0, 0.5)));

    fold cssR(r, c0);
    assert Node.nodeR(r, c0) && own(r, frac, c0, 0.5);
    abortAU(phi);

    var res1: Bool;
    var c1: Set[K];

    res1, c1 := Node.decisiveOp(dop, r, k, c0);

    ghost var b2: Bool;
    var c2: Set[K] := openAU(phi);

    unfold cssR(r, c2);
    b2 :| own(r, frac, c2, 0.5) && own(r, lock, b2, 1.0) && 
      (b2 ? true : (Node.nodeR(r, c2) && own(r, frac, c2, 0.5)));


    assert !b2 ==> Node.nodeR(r, c1) && Node.nodeR(r, c2);

    {!
      if (!b2) {
        Node.nodeSepStar(r, c1, c2);
        assert false;
      } else {
        assert b2 == true;
      }
    !}

    assert b2 == true;
    assert c2 == c0;

    fpu(r, frac, c2, c1);

    unlockNode(r);

    assert own(r, frac, c1, 0.5) && own(r, lock, false, 1.0) && 
      (false ? true : (Node.nodeR(r, c1) && own(r, frac, c1, 0.5)));
    fold cssR(r, c1);
    
    commitAU(phi, res1, c1);

    // assert false;

    return res1, c1;

  }
}

module IntSearchStructureSpec : SearchStructureSpec {
  type K = Int
  val keyset : Set[K] = {| k: Int :: k >= 0 |}
}

interface IntNodeImpl : NodeImpl {
  module Spec: SearchStructureSpec = IntSearchStructureSpec
  
  import Spec._
  // import Spec.K
  // import Spec.Op
  // import Spec.opSpec
  // import Spec.keyset

  field value: K
  field next: Ref

  pred lseg(n1: Ref, n2: Ref, c: Set[K]) {
    n1 == n2 ? 
      c == {||} : 
      
      (exists n0: Ref, v: K :: lseg(n0, n2, c -- {| v |}) && own(n1, value, v, 1.0) && own(n1, next, n0, 1.0) &&
        (forall v1: K :: v1 in c ==> v1 > v)
      )
  }

  lemma lseg_chain(n1: Ref, n2: Ref, c1: Set[K], c2: Set[K])
    requires lseg(n1, n2, c1) && lseg(n2, null, c2)
    ensures lseg(n1, null, c1 ++ c2)
  {
    if (n1 == n2) {

    } else {
    ghost var n0: Ref;
    ghost var v: K;
    unfold lseg(n1, n2, c1);
    n0, v :| n1 != n2 ==> (lseg(n0, n2, c1 -- {|v|}) && own(n1, value, v, 1.0) && own(n1, next, n0, 1.0));

    assert lseg(n0, n2, c1 -- {|v|});
    assert lseg(n2, null, c2);
    lseg_chain(n0, n2, c1 -- {|v|}, c2);

    assert n1 != null;
    assert lseg(n0, null, c1 -- {|v|} ++ c2);
    assert (lseg(n0, null, c1 -- {|v|} ++ c2) && own(n1, value, v, 1.0) && own(n1, next, n0, 1.0));
    assert (n1 == null ? 
      c1 ++ c2 == {||} : 
      
      (lseg(n0, null, c1 ++ c2 -- {|v|}) && own(n1, value, v, 1.0) && own(n1, next, n0, 1.0)));



    fold lseg(n1, null, c1 ++ c2);
    }
    // lseg_chain
    // assert n1 != n2;
    // assert n2 != n3;
    // assert n1 != n3;
    // assert exists n0: Ref, v: K :: lseg(n0, n2, c -- {| v |}) && own(n1, value, v, 1.0) && own(n1, next, n0, 1.0);
    // assert exists n0: Ref, v: K :: lseg(n0, n3, c -- {| v |}) && own(n2, value, v, 1.0) && own(n2, next, n0, 1.0);
    // assert exists n0: Ref, v: K :: lseg(n0, n3, c -- {| v |}) && own(n1, value, v, 1.0) && own(n1, next, n0, 1.0);
  }

  pred nodeR(n: Ref; c: Set[K]) {
    exists n1: Ref :: lseg(n1, null, c) && own(n, next, n1, 1.0)
  }

  proc create()
    returns (n: Ref)
    ensures nodeR(n, {||})
  {
    n := new(value:0, next:null);
    fold lseg(null, null, {||});
    assert own(n, next, null, 1.0) && lseg(null, null, {||});
    fold nodeR(n, {||});
  }

  proc decisiveOp(dop: Op, n: Ref, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c_ret: Set[K])
    requires k in keyset
    requires nodeR(n, c)
    ensures nodeR(n, c_ret) && opSpec(dop, k, c, c_ret, res)
  {

    unfold nodeR(n, c);
    ghost var n0: Ref;
    n0 :| lseg(n0, null, c) && own(n, next, n0, 1.0);
    var n1: Ref := n0;
    var c0: Set[K] := {||};


    fold lseg(n0, n1, c0);
    unfold lseg(n1, null, c);

    var ll: Bool := true;
    
    var n2: Ref;
    var v: Int;

    if (n1 == null) {
      // Completely empty list
      assume false;
    }

    else {

      n2 := n1.next;
      v := n1.value;
      var c1: Set[K] := c -- {| v |};

      while (n2 != null && v < k) 
        invariant lseg(n0, n1, c0)
        invariant own(n1, value, v, 1.0) && own(n1, next, n2, 1.0) 
        invariant lseg(n2, null, c1)
      {
        ghost var n3: Ref;
        ghost var v3: K;
        unfold lseg(n1, null, c1);
        n3, v3 :| 
          n1 != null ==>
          (own(n1, value, v3, 1.0) && own(n1, next, n3, 1.0) && lseg(n3, null, c -- {| v3 |}));

        c0 := c0 ++ {| v3 |};
        c1 := c1 -- {| v3 |};
        n1 := n2;
        n2 := n3;
        v := v3;

        fold lseg(n0, n1, c0);
        fold lseg(n2, null, c1);
      }

      if (n2 == null) {
        if (dop == searchOp()) {
          res := false;
          c_ret := c0;

          assert lseg(n0, n1, c_ret);
          assert own(n1, next, null, 1.0);
          assert own(n1, value, v, 1.0);

          fold lseg(n0, null, c_ret);
          fold nodeR(n, c_ret);
          fold opSpec(dop, k, c, c_ret, res);
          return res, c_ret;

        } else {
          if (dop == insertOp()) {
            var new_n: Ref;
            new_n := new(value:k, next:null);
            c_ret := c ++ {| k |};
            res := true;
          
            fold nodeR(n, c_ret);
            fold opSpec(dop, k, c, c_ret, res);
            // assert false;
            return res, c_ret;
          } else {
            res := false;
            c_ret := c;

            fold nodeR(n, c_ret);
            fold opSpec(dop, k, c, c_ret, res);
            return res, c_ret;
          }
        }
      }

    }

    // var v: K;
    // var n1: Ref;
    // v := open(n, value);
    // n1 := open(n, next);
    // if (dop == searchOp()) {
    //   res := (v == k);
    //   c1 := c;
    // } else {
    //   var res1: Bool;
    //   var c1_1: Set[K];
    //   res1, c1_1 := decisiveOp(dop, n1, k, c -- {| v |});
    //   if (res1) {
    //     if (dop == insertOp()) {
    //       c1 := c ++ {| v |};
    //     } else {
    //       c1 := c -- {| v |};
    //     }
    //   } else {
    //     c1 := c;
    //   }
    //   res := res1;
    // }
  }

  lemma nodeSepStar(n: Ref, c1: Set[K], c2: Set[K])
    requires nodeR(n, c1) && nodeR(n, c2)
    ensures false
  {
    unfold nodeR(n, c1);
    unfold nodeR(n, c2);
    assert false;
  }
}