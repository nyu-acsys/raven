include "give-up.rav"
include "../../arrays/ordered_array.rav"

interface BPlusTree[O: Library.OrderedType] : NodeImpl {

  module Spec : SearchStructureSpec {
    type K = O
    val keyspace: Set[K] = {| k: K :: true |}
  }

  import Spec._

  module KOption = Library.Option[O]

  import KOption.some
  import KOption.none

  import Flow_K._
  import Multiset_K.elem

  interface AK = OrderedArray[O]

  module RefType : Library.Type {
    rep type T = Ref
  }

  interface AN = Array[RefType]

  // Width parameter of the B-tree
  val b: Int

  auto axiom bValid() 
    ensures b > 0

  // Fields of a B-tree node
  field len: Int
  field rangeLb: KOption
  field rangeUb: KOption
  field keys: AK.T
  field ptrs: AN.T

  func le(ko: KOption, k: K) returns (res : Bool)
  {
    ko == none ? true : O.le(ko.KOption.value, k)
  }

  func lt(k: K, ko: KOption) returns (res : Bool)
  {
    ko == none ? true : O.lt(k, ko.KOption.value)
  }

  func flow_int_of(n: Ref, l: Int, lb: KOption, ub: KOption, kmap: Map[Int, K], cmap: Map[Int, Ref]) returns (flow_int: Flow_K)
  {
    Flow_K.int({| np: Ref :: np == n ? {| k: K :: le(lb, k) && lt(k, ub) ? 1 : 0 |} : Multiset_K.id |},
               {| np: Ref :: 0 <= AN.inverse(cmap, 0, l+1, np) <= l ? 
                 {| k: K :: cmap[0] != null && (0 < AN.inverse(cmap, 0, l+1, np) ==> O.le(kmap[AN.inverse(cmap, 0, l+1, np) - 1], k)) &&
                            (AN.inverse(cmap, 0, l+1, np) < l ==> O.lt(k, kmap[AN.inverse(cmap, 0, l+1, np)])) ? 1 : 0 |} : Multiset_K.id |},
               {| n |})
  }

  func node_cond(n: Ref, c: Set[K], flow_int: Flow_K, l: Int, lb: KOption, ub: KOption, ks: AK.T, chlds: AN.T, kmap: Map[Int, K], cmap: Map[Int, Ref]) returns (res: Bool) {
       0 <= l && l < 2*b 
    && AK.length(ks) == 2*b 
    && AN.length(chlds) == 2*b
    // Definition of flow interface
    && flow_int == flow_int_of(n, l, lb, ub, kmap, cmap)
    // Definition of contents
    && c == (cmap[0] == null ? /* Leaf */ AK.set_of_map(kmap, 0, l) : {||})
    // Keys are sorted
    && (forall i: Int, j: Int :: {kmap[i], kmap[j]} 0 <= i < j < l ==> O.lt(kmap[i], kmap[j]))
    // Keys are within range
    && (l > 0 ==> le(lb, kmap[0]) && lt(kmap[l-1], ub))
    // Consistency of cmap
    && (forall i: Int :: {cmap[i]} 0 <= i <= l ==> n != cmap[i])
    && AN.injective(cmap, 0, l+1)
    // Internal nodes don't point to null
    && (cmap[0] != null ==> (forall i: Int :: {cmap[i]} 0 <= i <= l ==> cmap[i] != null))    
  }

  pred node(n: Ref; c: Set[K], flow_int: Flow_K) {
    exists l: Int, lb: KOption, ub: KOption, ks: AK.T, chlds: AN.T, kmap: Map[Int, K], cmap: Map[Int, Ref] ::
    node_cond(n, c, flow_int, l, lb, ub, ks, chlds, kmap, cmap)
    // Heap resources
    && own(n, len, l, 1.0)
    && own(n, rangeLb, lb, 1.0)
    && own(n, rangeUb, ub, 1.0)
    && own(n, keys, ks, 1.0)
    && AK.sorted_array_with_content(ks, l, kmap)
    && own(n, ptrs, chlds, 1.0)
    && AN.arr(chlds, cmap)
  }

  lemma nodeSepStar(n: Ref, c1: Set[K], c2: Set[K], i_n1: Flow_K, i_n2: Flow_K)
    requires node(n, c1, i_n1) && node(n, c2, i_n2)
    ensures false
  {
    unfold node(n, c1, i_n1);
    unfold node(n, c2, i_n2);
  }

  // Show that if query key k is in the keyset of node x than x must be a leaf.
  /*lemma keyset_implies_leaf(n: Ref, k: K, i: Int, 
                            implicit ghost cmap: , implicit ghost c: Set[K])
    exists l: Int, lb: KOption, ub: KOption, ks: AK.T, chlds: AN.T, kmap: Map[Int, K], cmap: Map[Int, Ref] ::
    node_cond(n, c, flow_int, l, lb, ub, ks, chlds, kmap, cmap)
    // Heap resources
    && own(n, len, l, 1.0)
    && own(n, rangeLb, lb, 1.0)
    && own(n, rangeUb, ub, 1.0)
    && own(n, keys, ks, 1.0)
    && AK.sorted_array_with_content(ks, l, kmap)
    && own(n, ptrs, chlds, 1.0)
    && AN.arr(chlds, cmap)
    requires int.inf[n][k] == 1 && (forall y: Node :: {int.out[y][k]} int.out[y][k] == 0)
    requires (i <= 0 || O.le(x.keys[i-1], k)) && 0 <= i <= x.len
    ensures node(x, Ix, C)
    ensures x.ptrs[0] == null  // x is a leaf
  {
    if (x.ptrs[0] != null) {
      if (i < x.len) {
        if (lt(k, x.keys[i])) {
          pure assert Ix.out[x.ptrs[i]][k] == 1;
        } else {
          keyset_implies_leaf(x, Ix, k, i + 1);
        }
      } else {
        pure assert Ix.out[x.ptrs[i]][k] == 1;
      }
    }
  }*/


  /*Initialize a new root node */
  proc createRoot() returns (r: Ref)
    ensures node(r, {||}, 
      Flow_K.int({| l: Ref :: l == r ? Multiset_K.fromSet(keyspace) : Multiset_K.id |}, zeroFlow, {| r |}))
  {
    var ka: AK.T;
    ka := AK.alloc(2*b, AK.default);
    var pa: AN.T;
    pa := AN.alloc(2*b, null);
    r := new(len: 0, rangeLb: none, rangeUb: none, keys: ka, ptrs: pa);
    
    val cmap: Map[Int, Ref] = {| i: Int :: 0 <= i < 2*b ? null : AN.default |};
    
    fold AK.sorted_array_with_content(ka, 0, AK.default_map);
    fold node(r, {||}, flow_int_of(r, 0, none, none, AK.default_map, cmap));
  }

  proc inRange(n: Ref, k: K, implicit ghost c: Set[K], implicit ghost i_n: Flow_K)
    returns (ret: Bool)
    requires node(n, c, i_n)
    ensures node(n, c, i_n) && (ret ==> k in inset(i_n, n))
  {
    unfold node(n, c, i_n);
    
    var lb: KOption := n.rangeLb;
    var ub: KOption := n.rangeUb;

    fold node(n, c, i_n);
    return le(lb, k) && lt(k, ub);
  }

  proc findNext(n: Ref, k: K, implicit ghost c: Set[K], implicit ghost i_n: Flow_K)
    returns (ret: Bool, n1: Ref)
    requires k in inset(i_n, n)
    requires node(n, c, i_n)
    ensures node(n, c, i_n) && 
      (ret ?   
        k in outset(i_n, n1) :
        k !in outsets(i_n))
  {
    unfold node(n, c, i_n);
    
    var n_len : Int := n.len;
    var n_ptrs : AN.T := n.ptrs;
    ghost var chlds: Map[Int, Ref];
    chlds :| AN.arr(n_ptrs, chlds);
    unfold AN.arr(n_ptrs, chlds);
    var chld0: Ref = AN.loc(n_ptrs, 0).AN.value;
    
    if (chld0 == null) {  // Leaf node
      fold AN.arr(n_ptrs, chlds);
      fold node(n, c, i_n);
      return false, null;
    }

    var n_keys : AK.T := n.keys;

    var found: Bool;
    var i: Int;
    found, i := AK.arr_find(n_keys, n_len, k);

    ghost var kmap: Map[Int, K];
    kmap :| AK.sorted_array_with_content(n_keys, n_len, kmap);
    unfold AK.sorted_array_with_content(n_keys, n_len, kmap);
    unfold AK.arr(n_keys, kmap);
    var n_keys_i: K := AK.loc(n_keys, i).AK.value;
    fold AK.arr(n_keys, kmap);

    if (i < n_len && k == n_keys_i) {  // arr_find finds upper bound, we want lower
      i := i + 1;
    }

    n1 := AN.loc(n_ptrs, i).AN.value;
    ret := true;

    fold AN.arr(n_ptrs, chlds);
    fold AK.sorted_array_with_content(n_keys, n_len, kmap);
    fold node(n, c, i_n);
  }


}
