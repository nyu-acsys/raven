include "give-up.rav"
include "../../arrays/ordered_array.rav"

interface BPlusTree[O: Library.OrderedType] : NodeImpl {

  module Spec : SearchStructureSpec {
    type K = O
    val keyspace: Set[K] = {| k: K :: true |}
  }

  import Spec._

  module KOption = Library.Option[O]

  import KOption.some
  import KOption.none

  import Flow_K._
  import Multiset_K.elem

  interface AK = OrderedArray[O]

  module RefType : Library.Type {
    rep type T = Ref
  }

  interface AN = Array[RefType]

  // Width parameter of the B-tree
  val b: Int

  auto axiom bValid() 
    ensures b > 0

  // Fields of a B-tree node
  field len: Int
  field rangeLb: KOption
  field rangeUb: KOption
  field keys: AK.T
  field ptrs: AN.T

  func le(ko: KOption, k: K) returns (res : Bool)
  {
    ko == none ? true : O.le(ko.KOption.value, k)
  }

  func lt(k: K, ko: KOption) returns (res : Bool)
  {
    ko == none ? true : O.lt(k, ko.KOption.value)
  }

  func flow_int_of(n: Ref, l: Int, lb: KOption, ub: KOption, kmap: Map[Int, K], cmap: Map[Int, Ref]) returns (flow_int: Flow_K)
  {
    Flow_K.int({| np: Ref :: np == n ? {| k: K :: le(lb, k) && lt(k, ub) ? 1 : 0 |} : Multiset_K.id |},
               {| np: Ref :: 0 <= AN.inverse(cmap, 0, l+1, np) <= l ? 
                 {| k: K :: cmap[0] != null && (0 < AN.inverse(cmap, 0, l+1, np) ==> O.le(kmap[AN.inverse(cmap, 0, l+1, np) - 1], k)) &&
                            (AN.inverse(cmap, 0, l+1, np) < l ==> O.lt(k, kmap[AN.inverse(cmap, 0, l+1, np)])) ? 1 : 0 |} : Multiset_K.id |},
               {| n |})
  }

  func node_cond(n: Ref, c: Set[K], flow_int: Flow_K, l: Int, lb: KOption, ub: KOption, ks: AK.T, chlds: AN.T, kmap: Map[Int, K], cmap: Map[Int, Ref]) returns (res: Bool) {
       0 <= l && l < 2*b 
    && AK.length(ks) == 2*b 
    && AN.length(chlds) == 2*b
    // Definition of flow interface
    && flow_int == flow_int_of(n, l, lb, ub, kmap, cmap)
    // Definition of contents
    && c == (cmap[0] == null ? /* Leaf */ AK.set_of_map(kmap, 0, l) : {||})
    // Keys are sorted
    && (forall i: Int, j: Int :: {kmap[i], kmap[j]} 0 <= i < j < l ==> O.lt(kmap[i], kmap[j]))
    // Keys are within range
    && (l > 0 ==> le(lb, kmap[0]) && lt(kmap[l-1], ub))
    // Consistency of cmap
    && (forall i: Int :: {cmap[i]} 0 <= i <= l ==> n != cmap[i])
    && AN.injective(cmap, 0, l+1)
    // Internal nodes don't point to null
    && (cmap[0] != null ==> (forall i: Int :: {cmap[i]} 0 <= i <= l ==> cmap[i] != null))    
  }

  pred node(n: Ref; c: Set[K], flow_int: Flow_K) {
    exists l: Int, lb: KOption, ub: KOption, ks: AK.T, chlds: AN.T, kmap: Map[Int, K], cmap: Map[Int, Ref] ::
    node_cond(n, c, flow_int, l, lb, ub, ks, chlds, kmap, cmap)
    // Heap resources
    && own(n, len, l, 1.0)
    && own(n, rangeLb, lb, 1.0)
    && own(n, rangeUb, ub, 1.0)
    && own(n, keys, ks, 1.0)
    && AK.sorted_array_with_content(ks, l, kmap)
    && own(n, ptrs, chlds, 1.0)
    && AN.arr(chlds, cmap)
  }

  lemma nodeSepStar(n: Ref, c1: Set[K], c2: Set[K], i_n1: Flow_K, i_n2: Flow_K)
    requires node(n, c1, i_n1) && node(n, c2, i_n2)
    ensures false
  {
    unfold node(n, c1, i_n1);
    unfold node(n, c2, i_n2);
  }

  /*Initialize a new root node */
  proc createRoot() returns (r: Ref)
    ensures node(r, {||}, 
      Flow_K.int({| l: Ref :: l == r ? Multiset_K.fromSet(keyspace) : Multiset_K.id |}, zeroFlow, {| r |}))
  {
    var ka: AK.T;
    ka := AK.alloc(2*b, AK.default);
    var pa: AN.T;
    pa := AN.alloc(2*b, null);
    r := new(len: 0, rangeLb: none, rangeUb: none, keys: ka, ptrs: pa);
    
    assert own(r, len, 0, 1.0);
    
    val cmap: Map[Int, Ref] = {| i: Int :: 0 <= i < 2*b ? null : AN.default |};
    val kmap: Map[Int, K] = AK.default_map;

    fold AK.sorted_array_with_content(ka, 0, AK.default_map);
    
    assert node_cond(r, {||}, flow_int_of(r, 0, none, none, AK.default_map, cmap),
                     0, none, none, ka, pa, AK.default_map, cmap)
      && own(r, len, 0, 1.0)
      && own(r, rangeLb, none, 1.0)
      && own(r, rangeUb, none, 1.0)
      && own(r, keys, ka, 1.0)
      && AK.sorted_array_with_content(ka, 0, AK.default_map)
      && own(r, ptrs, pa, 1.0)
      && AN.arr(pa, cmap);

    fold node(r, {||}, flow_int_of(r, 0, none, none, AK.default_map, cmap));
  }

  proc inRange(n: Ref, k: K, implicit ghost c: Set[K], implicit ghost i_n: Flow_K)
    returns (ret: Bool)
    requires node(n, c, i_n)
    ensures node(n, c, i_n) && (ret ==> k in inset(i_n, n))
  {
    unfold node(n, c, i_n);
    
    var lb: KOption := n.rangeLb;
    var ub: KOption := n.rangeUb;

    fold node(n, c, i_n);
    return le(lb, k) && lt(k, ub);

  }

}
