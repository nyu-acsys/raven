include "ccm.rav"

import Library.Type
// import Library.CancellativeResourceAlgebra

module Multiset[K: Type]: CCM {
  rep type T = Map[K, Int]

  val id: T := {| k: K :: 0 |}

  func comp(a:T, b:T) returns (ret:T)
  { 
    {| k: K :: a[k] + b[k] |} 
  }
  
  func frame(a:T, b:T) returns (ret:T)
  {  
    {| k: K :: a[k] - b[k] |}
  }

  func valid(a:T) returns (ret: Bool)
  {
    forall k: K :: {a[k]} a[k] >= 0
  }

  /*auto lemma idValid()
    ensures valid(id)
  {}

  auto lemma compAssoc()
    ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
  {}

  auto lemma compCommute()
    ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
  {}

  auto lemma compId()
    ensures forall a:T :: {comp(a, id)} {comp(id, a)} comp(a, id) == a
  {}

  auto lemma compValid()
    ensures forall a:T, b:T :: {comp(a,b)} valid(a) && valid(b) ==> valid(comp(a, b)) 
  {}

  auto lemma frameCompInv()
    ensures forall a:T, b:T:: {comp(a,b)} frame(comp(a, b), b) == a
  {}

  auto lemma compFrameInv()
   ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
  {}*/

  func fromSet(s: Set[K]) returns (ret:T)
  {
    {| k: K :: k in s ? 1 : 0 |}
  }

  func elem(m: T, k: K) returns (ret: Bool)
  {
    m[k] > 0
  }
}
