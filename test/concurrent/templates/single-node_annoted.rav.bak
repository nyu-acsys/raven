module Lock {

  field bit: Bool
  
  pred lock(l: Ref, b: Bool) {
    own(l.bit, b) 
  }

  proc create()
    returns (l: Ref)
    ensures lock(l, false)
  {
    l := new bit(false);
    
    {! 
      fold lock(l, false);
    !}
  }

  proc acquire(l: Ref, implicit ghost b: Bool)
    atomic requires lock(l, b)
    atomic ensures lock(l, true) && b == false
  {
		// {{ AU(v_phi, "acquire", l, None, not_open) }}
	
    val phi: Perm;

    {!
      phi := bindAU();

			// {{ AU(v_phi, "acquire", l, None, not_open) }} * {{ phi = v_phi }}

      val b: Bool;
      b := openAU(phi);

			// {{ AU(v_phi, "acquire", l, None, open(v_b)), lock(l, v_b) }} * 
			// {{ phi = v_phi, b = v_b }}

      unfold lock(l, b); 
      
			// {{ AU(v_phi, "acquire", l, None, open(v_b)), own(l.bit, b) }} * 
			// {{ phi = v_phi, b = v_b }}
      
    !}
    
    /* Need to add CAS  
   	
   	val res = cas(l.bit, false, true); 

		CAS_SUCC : 
		{{ AU(v_phi, "acquire", l, None, open(v_b)), own(l.bit, b') }} * 
		{{ phi = v_phi, b = v_b, b = false, b' = true, res = true }}   
		
		OR
		
		CAS_FAIL:
		{{ AU(v_phi, "acquire", l, None, open(v_b)), own(l.bit, b') }} * 
		{{ phi = v_id, b = v_b, b != false, b' = b, res = false }}

		CAS_SUCC
		--------
		
		{{ AU(v_phi, "acquire", l, None, open(v_b)), own(l.bit, b') }} * 
		{{ phi = v_phi, b = false, b' = true, res = true }}		
		
		*/
		
    {!
      if (res) {
      
				// {{ AU(v_phi, "acquire", l, None, open(v_b)), own(l.bit, b') }} * 
				// {{ phi = v_phi, b = false, b' = true, res = true }}		      	
      
        fold lock(l, true);
        
				// {{ AU(v_phi, "acquire", l, None, open(v_b)), lock(l, true) }} * 
				// {{ phi = v_phi, b = false, b' = true, res = true }}		      	
                
        commitAU(phi, ());
        
        /* 
        exhale post("acquire")
        exhale (lock(l, true) &*& v_b == false)
				*/
				
				// {{ AU(v_phi, "acquire", l, Some(()), not_open) }} * 
				// {{ phi = v_phi, b = false, b' = true, res = true }}
        
      } else {
        fold lock(l, false); 
        abortAU(phi);
      }	
    !}

		// CAS_FAIL
		// --------

		// {{ AU(v_phi, "acquire", l, None, open(v_b)), own(l.bit, b') }} * 
		// {{ phi = v_id, b = v_b, b != false, b' = b, res = false }}

    {!
      if (res) {
        fold lock(l, true);
        commitAU(phi, ());
      } else {				
			
				fold lock(l, true);

				// {{ AU(v_phi, "acquire", l, None, open(v_b)), lock(l, true) }} * 
				// {{ phi = v_id, b = v_b, b != false, b' = b, res = false }}
				
        abortAU(phi);
        /* 
        exhale pre("acquire") with current pseudo_quant variables (lock(l, v_b))
        exhale (lock(l, v_b))
				*/

				// {{ AU(v_phi, "acquire", l, None, not_open) }} * 
				// {{ phi = v_id, b = v_b, b != false, b' = b, res = false }}
      }	
    !}

    /* Check for unsoundness here */
    if (!res) {
				
			// {{ AU(v_phi, "acquire", l, None, not_open) }} * 
			// {{ phi = v_id, b = v_b, b != false, b' = b, res = false }}

      val b2: Bool;
      b2 := openAU(phi);

			// {{ AU(v_phi, "acquire", l, None, open(v_b2)), lock(l, v_b2) }} * 
			// {{ phi = v_phi, b = v_b2 }}
			
			acquire(l);
			
			/*
			exhale pre("acquire") with existential (exists b' :: lock(l, b'))
			inhale post("acquire") (lock(l, true) &*& b' = false)
			*/
			
			commit(phi)
			
    }	
  }

  proc release(l: Ref)
    atomic requires lock(l, true)
    atomic ensures lock(l, false)
  {
    val phi: Perm;
    {! 
      phi := bindAU();
      openAU(phi);
      unfold lock(l, true);
    !}
 
    l.(Lock.bit) := false;
    
    {!
      fold lock(l, true);
      commitAU(phi);
    !}
  }
}


interface Keyspace {
  rep type t

  val KS: Set[t]
}

module IntKeyspace : Keyspace {
  rep type t = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type Op = data { case searchOp ; case insertOp ; case deleteOp }

	pred opSpec(op: Op, k: K, c: Set[K], c': Set[K], res: Bool) {
		if (op == searchOp) {
    	C' == C && res == (k in C)
		} else if (op == insertOp) {
			C' == C ++ {|k|} && res == (k !in C)
		} else {
			C' == C -- {|k|} && res == (k in C)
		}
	}
}

interface NodeImpl[K: Keyspace] {

  /*import K.KS*/
  module Spec = SearchStructureSpec[K]
  import Spec

  rep type t

  pred nodeR(n: T, c: Set[K])

  proc create()
    returns (n: T)
    ensures nodeR(n, {||})

  proc decisiveOp(dop: Op, n: T, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
    requires k in ks && nodeR(n, c)
    ensures nodeR(n, c') && opSpec(dop, k, c, c', res)
}

interface SearchStructure[K: Keyspace] {
  /* import K.KS */
  module Spec = SearchStructureSpec[K]
  import Spec

	/* css or Ref? */
  type css

  pred cssR(r: css, c: Set[K])

  inv cssInv(r: css)

  proc create()
    returns (r: css)
    ensures cssInv(cssI, cssInv(r)) && cssR(r, {||})

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
    requires k in ks
    requires cssInv(r)
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c') && opSpec(dop, k, c, c', res)
}

module SingleNodeTemplate[K: Keyspace, Node: NodeImpl[K]] : SearchStructure[K] {
  /* import K.KS */
  import Node

  module FracSK = Frac[K.KS]
	module AgreeAD = Agree[Addresses]; 

  field lock: Ref;
  field lock_ag: AgreeAD; 
  field node: Ref;
  field node_ag: AgreeAD;
  field cont_lock: FracSK;
  field cont_spec: FracSK;
  
  pred nodePred(r: css) {
    exists c: Set[K] :: nodeR(r.node, c) && own(r.cont_lock, frac(1/2, c))
  }

  pred cssAuth(r: css, c: Set[K]) {
    own(r.cont_spec, frac(1/2, c))
  }

  pred cssR(r: css, c: Set[K]) {
    own(r.cont_spec, frac(1/2, c))
  }

  inv cssInv(r: css) {
    exists b: Bool, c: Set[K], l: Ref ::
      cssAuth(r, c)
      && own(r.cont_lock, frac(1/2, c))
      && own(r.lock, l)
      && Lock.lock(l, b) && (b ? true : nodePred(r))
  }

  proc create()
    returns (r: css)
    ensures cssR(r, {||}) &*& cssInv(r)
  {
    val l: Ref = Lock.create();
    val n: Node = Node.create();
    
    {{ Lock.lock(l, false), nodeR(n, {||}) }}
    
    val r: css;

    r.lock := l;
    r.node := n;
    r.cont_lock := frac(1, {||});
    r.cont_spec := frac(1, {||});

    {{ Lock.lock(l, false), nodeR(n, {||}), own(r.lock, l), own(r.node, n), 
    		own(r.cont_lock, frac(1, {||})), own(r.cont_spec, frac(1, {||})) }}
    
    {!          
      
      /* symb_exec first checks if frac(1/2, {||}) <= frac(1, {||}) */
      /* After, [ frame (frac(1, {||})) (frac(1/2, {||})) ] remains */
      fold(cssAuth(r, {||}));

    	{{ Lock.lock(l, false), nodeR(n, {||}, own(r.lock, l), own(r.node, n), 
    			own(r.cont_lock, frac(1, {||})), own(r.cont_spec, frac(1/2, {||})),
    			cssAuth(r, {||}) }}

			assert nodeR(r.node, {||}) &*& own(r.cont_lock, frac(1/2, {||}))

			fold nodePred(r)

    	{{ Lock.lock(l, false), own(r.lock, l), own(r.node, n), 
    			own(r.cont_lock, frac(1/2, {||})), own(r.cont_spec, frac(1/2, {||})),
    			cssAuth(r, {||}), nodePred(r) }}
			
			
      assert cssAuth(r, {||}) &*& own(r.cont_lock, frac(1/2, {||}))
        			&*& Lock.lock(r.lock, false) &*& (false ? true : nodePred(r));
      
      fold cssInv(r);

    	{{ cssInv(r), own(r.cont_spec, frac(1/2, {||})) }}

      fold cssR(r, {||});
      
     	{{ cssInv(r), cssR(r, {||}) }}
      
    !} 
  }

  proc cssOp(dop: Op, r: CSS, k: K, implicit ghost c: Set[K])
    returns (res: Bool, implicit ghost c': Set[K])
    requires k in ks
    requires cssInv(r)							
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c') &*& opSpec(dop, k, c, c', res)
  {
    {!
    
    	{{ cssInv(r) }}
    	
      openInv cssInv(r);

    	{{ cssAuth(r, v_c), own(r.cont_lock, frac(1/2, v_c)), 
    			own(r.lock, v_l), Lock.lock(v_l, v_b), (v_b ? true : nodePred(r)) }}
      
      var b0, c0, l :| cssAuth(r, c) &*& own(r.lock, l) &*& Lock.lock(l, b) 

    	{{ cssAuth(r, v_c), own(r.cont_lock, frac(1/2, v_c)), 
    			own(r.lock, v_l), Lock.lock(v_l, v_b), (v_b ? true : nodePred(r)) }} *
    	{{ b0 = v_b, c0 = v_c, l = v_l }}
                  
    !}
    
    var l = r.lock; 
    acquire(l);
    
  	{{ cssAuth(r, v_c), own(r.cont_lock, frac(1/2, v_c)), 
  			own(r.lock, v_l), Lock.lock(v_l, true), nodePred(r) }} *
  	{{ b0 = v_b, c0 = v_c, l = v_l }}
    
    {!

			assert cssAuth(r, c0) &*& own(r.lock, l) &*& Lock.lock(r.lock, true);
			
			closeInv cssInv(r);

	  	{{ nodePred(r) }}

			assert nodePred(r);
      unfold nodePred(r);
      
      {{ nodeR(r.node, v_c1), own(r.cont_lock, frac(1/2, v_c1)) }}
      
    !} 
    
    res, c1 := decisiveOp(dop, r.node, k);
    
    {{ nodeR(n, c1), own(r.cont_lock, frac(1/2, v_c1) }} * 
    {{ opSpec(dop, k, c1, v_c1, res) }}



    {!
      unfold cssI;
      /* unfold (b1, C1')cssInv(r); */
      unfold cssInv(r);

      /* lemma below asserts C0' = C1' 

      lemma frac_eq(l: loc, )

      */
      frac_eq((r.cont_lock), 1/2, 1/2, c0', c1');

      /* lemma below sums up fractional resources */
      frac_sum((r.cont_lock), 1/2, 1/2, c0');
      
      /* lemma frac_update l C C' : 
            own(l, frac(1, C)) ~~> own(l, frac(1, C')) */
      frac_update((r.cont_lock), c0', c1);

      /* fold (C1)nodePred(r) */
      fold nodePred(r);
      
      phi, c1'' := openAU;
      
      unfold cssAuth(r, c0');
      unfold cssR(r, c1'');
      frac_eq((r.cont_spec), 1/2, 1/2, c0', c1'');
      frac_sum((r.cont_spec), 1/2, 1/2, c0');
      frac_update((r.cont_spec), c0', c1);
      
      fold cssAuth(r, c1);
      fold cssR(r, c1);
      commit(phi);

      assert b1 == true;
      fold Lock.lock(r, true);
    !}

    release(r.lock);
    
    {!
      unfold Lock.lock(r, false);
      /* fold (false, C1)cssInv(r); */
      fold cssInv(r); 
      fold cssI;
    !}    
  }
}
  
