interface Keyspace {
  rep type T

  val ks: Set[T]
}

module IntKeyspace : Keyspace {
  rep type T = Int

  val ks: Set[T] = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type Op = data { case searchOp ; case insertOp ; case deleteOp }

	pred opSpec(op: Op, k: K, c: Set[K], c1: Set[K], res: Bool) {
    op == searchOp() ? 
      c1 == c && res == (k in c) :

    (op == insertOp() ? 
      c1 == c ++ {|k|} && res == (k !in c) :
      c1 == c -- {|k|} && res == (k in c)
    )

	}
}

interface Node {
  rep type T
}


module Flow [Node1: Node, Domain: Library.CancellativeResourceAlgebra] : Library.ResourceAlgebra {
  rep type T = data { 
    case flow_int(infl: Map[Node1, Domain], outfl: Map[Node1, Domain], dom: Set[Node1]);
    case int_undef //top elem
  }

  // in_inset
  // in_outset

  /* The zero flow */
  func zeroFlow() returns (ret: Map[Node1, Domain]) {
    {| n: Node1 :: Domain.id |}
  }
    
  /* The empty flow interface */
  func intEmp() returns (ret: T) {
    flow_int(zeroFlow(), zeroFlow(), {||})
  }

  func valid(intf: T) returns (ret: Bool) {
    // not undefined
      intf != int_undef()  
    &&
    // Inflow and outflow properly defined
      (forall n: Node1 :: intf.infl[n] != Domain.id ==> n in intf.dom)
    && (forall n: Node1 :: intf.outfl[n] != Domain.id ==> n !in intf.dom)
    // Inflow and outflow are valid
    && (forall n: Node1 :: n in intf.dom ==> Domain.valid(intf.infl[n]))
    && (forall n: Node1 :: n !in intf.dom ==> Domain.valid(intf.outfl[n]))
    // Empty domain ==> no outflow
    && (intf.dom == {||} ==> (forall n: Node1 :: intf.outfl[n] == Domain.id))

  }

  func intComposable(i1: T, i2: T) returns (ret: Bool) {
    valid(i1) && valid(i2) && i1.dom ** i2.dom == {||}
    && (forall n: Node1 :: n in i1.dom ==> i1.infl[n] == Domain.comp(i2.outfl[n], Domain.frame(i1.infl[n], i2.outfl[n])))
    && (forall n: Node1 :: n in i2.dom ==> i2.infl[n] == Domain.comp(i1.outfl[n], Domain.frame(i2.infl[n], i1.outfl[n])))
    && (forall n: Node1 :: n in i1.dom ==> Domain.valid(Domain.frame(i1.infl[n], i2.outfl[n])))
    && (forall n: Node1 :: n in i2.dom ==> Domain.valid(Domain.frame(i2.infl[n], i1.outfl[n])))
  }

  func comp(i1: T, i2: T) returns (ret: T) {
    intComposable(i1, i2) ?
      flow_int(
        {| n: Node1 :: n in i1.dom ? Domain.frame(i1.infl[n], i2.outfl[n]) :
          (n in i2.dom ? Domain.frame(i2.infl[n], i1.outfl[n]) :
          Domain.id) |},

        {| n: Node1 :: n !in i1.dom && n !in i2.dom ? Domain.comp(i1.outfl[n], i2.outfl[n]) : Domain.id |},

        i1.dom ++ i2.dom) :

      (i1 == intEmp ? i2 : (i2 == intEmp ? i1 : int_undef()))
  }

  func fpuAllowed(a:T, b:T) returns (ret:Bool) 
        // ensures forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))
    {
        // true
        forall c:T :: valid(a) && valid(comp(a,c)) ==> valid(comp(b,c))
    }



  auto lemma frameCompInv()
        ensures forall a:T, b:T:: valid(comp(a, b)) ==> frame(comp(a, b), b) == a
    {}

    auto lemma frameReflexive()
        ensures forall a:T :: valid(a) ==> frame(a, a) == id
    {}

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a:T, b:T :: comp(a, b) == comp(b, a)
    {}

    auto lemma compId()
        ensures forall a:T :: comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a:T, b:T :: valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a:T :: frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a:T, b:T :: valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    {}
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: ((fpuAllowed(a,b) && valid(a) && 
            // valid(b) && 
        valid(comp(a,c))) ==> valid(comp(b,c)))
    {}
    
    auto lemma fpuReflexive()
        ensures (forall a:T :: valid(a) ==> fpuAllowed(a,a))
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}

}


interface NodeImpl[K: Keyspace, Node: Node] {

  module Spec = SearchStructureSpec[K]
  // import Spec
  // assuming functions inset(I, n), outset(I, n)
  // assumes out(I) = ++_n outset(I, n)
  // assumes dom(I)

  module KeyMultiset = Lib.Multiset[K]
  module FlowInt = Flow[Node, KeyMultiset]


  pred nodeR(n: T, lk: Bool, i_n: FlowInt, c_n: Set[K])

  proc lockNode(n: T, ghost lk: Bool, ghost i_n: FlowInt, ghost  c_n: Set[K])
    atomic requires nodeR(n, lk, i_n, c_n)
    atomic ensures nodeR(n, true, i_n, c_n) && lk == false

  proc unlockNode(n: T, ghost i_n: FlowInt, ghost  c_n: Set[K])
    atomic requires nodeR(n, true, i_n, c_n)
    atomic ensures nodeR(n, false, i_n, c_n)

  proc allocRoot()
    returns (r: T, ghost i_r: FlowInt)
    ensures nodeR(r, false, i_r, {||})
    ensures inset(i_r, r) == ks && out(i_r) == {||}

	proc inRange(n: T, ghost lk: Bool, ghost i_n: FlowInt, ghost  c_n: Set[K], k: K)
		returns (res: Bool)
		requires nodeR(n, lk, i_n, c_n)
		ensures nodeR(n, lk, i_n, c_n)
		ensures res ==> k in inset(i_n, n)
			
	proc findNext(n: T, ghost lk: Bool, ghost i_n: FlowInt, ghost c_n: Set[K], k: K)
		returns (succ: Bool, nn: Node)
    requires k in ks 
		requires nodeR(n, lk, i_n, cn)
    requires k in inset(i_n, n)
		ensures nodeR(n, lk, i_n, cn)
		ensures !succ ==> k !in out(i_n)
		ensures succ ==> k in outset(i_n, nn) 

  // difference between ghost vs implicit ghost?
  proc decisiveOp(n: T, ghost lk: Bool, ghost i_n: FlowInt, ghost c_n: Set[K], dop: Op, k: K)
    returns (succ: Bool, res: Bool, implicit ghost c_n1: Set[K])
    requires nodeR(n, lk, i_n, c_n)
    requires k in inset(i_n) && k !in out(i_n)
    ensures nodeR(n, lk, i_n, c_n1)
    ensures succ ==> opSpec(dop, k, c_n, c_n1, res)
    ensures !succ ==> c_n == c_n1

  lemma keysetTheorem(dop: Op, k: K, c_n: Set[K], c_n1: Set[K], res: Bool) 
  requires opSpec(dop, k, c_n, c_n1, res)
  ensures opSpec(dop, k, c, c_1, res)
}



interface SearchStructure[K: Keyspace] {
  // /* import K.KS */
  // module Spec = SearchStructureSpec[K]
  // import Spec

  type Css

  pred cssR(r: CSS, c: Set[K])
  inv cssI(r: CSS)

  proc create()
    returns (r: CSS)
    // inv in ensures: needs special treatment
    ensures cssI(r) && cssR(r, {||})

  proc cssOp(r: CSS, ghost c: Set[K], dop: Op, k: K)
    returns (res: Bool, implicit ghost c1: Set[K])
    requires k in ks
    requires cssI(r)
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c1) && opSpec(dop, k, c, c1, res)
}

module GiveUpTemplate[K: Keyspace, Node: Node, NodeImpl: NodeImpl[K, Node]] : SearchStructure[K] {

  import Node

  module NodeSetRA = SetRA[Node]
  module FlowRA_MS_KS = FlowRA[MS_KS]
  module KeysetRA_KS = KeysetRA[KS]
  module Set_K : Library.Type { 
    rep type T = Set[K]
  }

  module AuthSetRA = Lib.Auth[NodeSetRA]
  module AuthFlowRA = Auth[FlowRA_MS_KS]
  module AuthKeysetRA = Auth[KeysetRA_KS]
  module FracContentsRA = Frac[Set_K]
  import AuthSetRA
  import AuthFlowRA
  import AuthKeysetRA
  import FracContentsRA

  field node: Node;
  field fp: AuthSetRA; /* footprint */
  field fl: AuthFlowRA; /* flow */
  field ks: AuthKeysetRA; /* keyset */
  field rp: FracContentsRA; /* representation */

  pred inFP(r: CSS, n: Node) {
  	own(r.fp, frag({| n |}))
  }

  lemma inFP_persistent(r: Ref,n: Node) 
    requires inFP(r,n)
    ensures inFP(r,n) && inFP(r,n)
  {}
  
  pred nodePred(r: CSS, n: Node, i_n: FlowInt, c_n: Set[K]) {
  	own(r.ks, frag(ksPair (keyset(i_n), c_n)))
    && own(r.fl, frag(i_n))
    && dom(i_n) == {| n |}
  }

  pred cssR(r: CSS, c: Set[K]) {
    own(r.rp, frac_chunk(c, 1/2))
  }

  pred globalinv(r: CSS, i: FlowInt) {true}

  pred globalRes(r:CSS, i: FlowInt, c: Set[K]) {
    own(r.fl, auth_frag(i, {||}))
    && own(r.ks, ksPair (ks, c))
    && own(r.fp, auth_frag(dom(i), {||}))
    && globalinv(r, i)
  }

  inv cssI(r: CSS, implicit ghost m_lk: Map[Node, Bool], implicit ghost m_In: Map[Node, FlowInt], implicit ghost m_Cn: Map[Node, Set[K]], implicit ghost i: FlowInt, implicit ghost c: Set[K], implicit ghost n: Node) {
      own(r.rp, frac_chunk(c, 1/2))
      && own(r.node, n, 1/2)
      && inFP(r, n)
      && globalRes(r, i, c)
      && (forall n:Node :: n in dom(i) ==> 
              nodeR(n, m_lk[n], m_In[n], m_Cn[n]))
      && (forall n:Node :: n in dom(i) && m_lk[n] ==>
        nodePred(r, n, m_In[n], m_Cn[n]))
  }



  proc traverse(r: CSS, n: Node, k: K, implicit ghost i_nn: FlowInt, implicit ghost c_nn: Set[K])
  /* existentials from returns as implicit ghosts in parameters? */
    returns (nn: Node) /* implicit ghost i_nn: FlowInt, implicit ghost c_nn: Set[K]) */
    requires cssI(r)
    requires inFP(r, n)
    atomic requires true
    atomic ensures nodeR(nn, true, i_nn, c_nn)
    atomic ensures nodePred(r, nn, i_nn, c_nn)
    atomic ensures k in inset(i_nn) && k !in out(i_nn)   
  { }

  proc cssOp(r: CSS, ghost c: Set[K], dop: Op, k: K)
    returns (res: Bool, implicit ghost c1: Set[K])
    requires k in ks && cssI(r)
    // requires 
    atomic requires cssR(r, c)
    atomic ensures cssR(r, c1) && opSpec(dop, k, c, c1, res)
  {
    var phi: AtomicToken;
    phi := bindAU();
    openInv cssI(r);

    // var m_lk: Map[Node, Bool], m_In: Map[Node, FlowInt], m_Cn: Map[Node, Set[K]], I: FlowInt, C: Set[K], n:Node :| cssI(r, m_lk, m_In, m_Cn, I, C, n);
    /* unfold cssI(r, m_lk, m_In, m_Cn, I, C, n); */

    var m_lk: Map[Node, Bool];
    var m_In: Map[Node, FlowInt];
    var m_Cn: Map[Node, Set[K]];
    var i: FlowInt;
    var c: Set[K];
    var n: Node;
    
    // :| cssI(r, m_lk, m_In, m_Cn, I, C, n);

    unfold cssI(r);

    // var m_lk, m_In, m_Cn :|  (forall n:Node :: n in dom(I) ==> 
    // nodeR(n, m_lk[n], m_In[n], m_Cn[n]))

    var v: Node = r.node;

    inFP_persistent(r, v);

    fold cssI(r);
    closeInv cssI(r);

    var n := traverse(r, v, k);

    var succ: Bool;
    var c_n1: Set[K];

    openInv cssI(r);
    openAU(phi);

    succ, res, c_n1 := decisiveOp(n, dop, k);

    
      if (succ) {
        keysetTheorem();
        commitAU();
        closeInv cssI(r);
      }

      else {
        abortAU();
        closeInv cssI(r);
      }
        
    if (succ) {
      unlockNode(n);
      return res;
    } else {
      unlockNode(n);
      cssOp(r, dop, k);
    }
  }
}
	
