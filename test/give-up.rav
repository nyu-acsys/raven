interface Keyspace {
  rep type t

  val KS: Set[t]
}

module IntKeyspace : Keyspace {
  rep type t = Int

  val KS = {| k: Int :: true |}
}

module SearchStructureSpec[K: Keyspace] {

  type op = data { case searchOp ; case insertOp ; case deleteOp }

	pred opSpec(op: Op, k: K, C: Set[K], C1: Set[K], res: Bool) {
		if (op == searchOp) {
    	C1 == C && res == (k in C)
		} else if (op == insertOp) {
			C1 == C ++ {|k|} && res == (k !in C)
		} else {
			C1 == C -- {|k|} && res == (k in C)
		}
	}
}

interface Node[K: Keyspace] {

  module Spec = SearchStructureSpec[K]
  import Spec
  // assuming predicates inset(I, n), outset(I, n)
  // assumes out(I) = ++_n outset(I, n)
  // assumes dom(I)
  import Flow

  rep type T

  pred nodeR(n: T, lk: Bool, In: FlowInt, Cn: Set[K])

  proc lockNode(n: T, ghost lk: Bool, ghost In: FlowInt, ghost  Cn: Set[K])
    atomic requires nodeR(n, lk, In, Cn)
    atomic ensures nodeR(n, true, In, Cn) && lk = false

  proc unlockNode(n: T, ghost In: FlowInt, ghost  Cn: Set[K])
    atomic requires nodeR(n, true, In, Cn)
    atomic ensures nodeR(n, false, In, Cn)

  proc allocRoot()
    returns (r: T, ghost Ir: FlowInt)
    ensures nodeR(r, false, Ir, {||})
    ensures inset(Ir, r) = KS && out(Ir) = {||}

	proc inRange(n: T, ghost lk: Bool, ghost In: FlowInt, ghost  Cn: Set[K], k: K)
		returns (res: Bool)
		requires nodeR(n, lk, In, Cn)
		ensures nodeR(n, lk, In, Cn)
		ensures res ==> k in inset(In, n)
			
	proc findNext(n: T, ghost lk: Bool, ghost In: FlowInt, ghost Cn: Set[K], k: K)
		returns (succ: Bool, nn: Node)
    requires k in KS 
		requires nodeR(n, lk, In, cn)
    requires k in inset(In, n)
		ensures nodeR(n, lk, In, cn)
		ensures !succ ==> k !in out(In)
		ensures succ ==> k in outset(In, nn) 

  // difference between ghost vs implicit ghost?
  proc decisiveOp(n: T, ghost lk: Bool, ghost In: FlowInt, ghost Cn: Set[K], dop: op, k: K)
    returns (succ: Bool, res: Bool, implicit ghost Cn1: Set[K])
    requires k in KS 
    requires nodeR(n, lk, In, Cn)
    requires k in inset(In, n) && k !in out(In)
    ensures nodeR(n, lk, In, Cn1)
    ensures succ ==> opSpec(dop, k, Cn, Cn1, res)
    ensures !succ ==> Cn = Cn1
}

interface SearchStructure[K: Keyspace] {
  /* import K.KS */
  module Spec = SearchStructureSpec[K]
  import Spec

	/* css or Ref? */
  type css

  pred cssR(r: css, C: Set[K])
  inv cssI(r: css)

  proc create()
    returns (r: css)
    // inv in ensures: needs special treatment
    ensures cssI(r) && cssR(r, {||})

  proc cssOp(r: css, ghost C: Set[K], dop: Op, k: K)
    returns (res: Bool, implicit ghost C1: Set[K])
    requires k in KS
    requires cssI(r)
    atomic requires cssR(r, C)
    atomic ensures cssR(r, C1) && opSpec(dop, k, C, C1, res)
}

module GiveUpTemplate[K: Keyspace, Node: NodeImpl[K]] : SearchStructure[K] {

  import Node

  module AuthSetRA = Auth[SetRA[Node]]
  module AuthFlowRA = Auth[FlowRA[MS_KS]]
  module AuthKeysetRA = Auth[KeysetRA[KS]]
  module FracContentsRA = Frac[Set[K]]
  import AuthSetRA
  import AuthFlowRA
  import AuthKeysetRA
  import FracContentsRA

  field node: Ref;
  field fp: AuthSetRA;
  field fl: AuthFlowRA;
  field ks: AuthKeysetRA;
  fiel rp: FracContentsRA;
  
  pred inFP(r: css, n: Node) {
  	own(r.fp, Frag {| n |})
  }
  
  pred nodePred(r:css, n: Node, In: FlowInt, Cn: Set[K]) {
  	own(r.ks, Frag (KSPair (keyset(In), Cn)))
    && own(r.fl, Frag In)
    && dom(In) = {| n |}
  }
  
  pred cssR(r, C) {
    own(r.rp, (1/2, C))
  }

  pred globalinv(r: css, I: FlowInt)

  pred globalRes(r:css, I: FlowInt, C: Set[K]) {
    own(r.fl, Auth I)
    && own(r.ks, KSPair (KS, C))
    && own(r.fp, Auth (dom(I)))
    && globalinv(r, I)
  }

  inv cssI(r: css) {
    exists I: FlowInt, C: Set[K] ::
      own(r.rp, (1/2, C))
      && globalRes(r, I, C)
      && (forall n:Node :: n in dom(I) ==> 
              exists lk: Bool, In: FlowInt, Cn: Set[K] :: nodeR(n, lk, In, Cn) && (lk ? nodePred(r, n, In, Cn) : True))
  }

  proc traverse(r: css, n: Node, k: K)
    returns (nn: Node, implicit ghost Inn: FlowInt, implicit ghost Cnn: Set[K])
    requires cssI(r)
    requires inFP(r, n)
    atomic requires True
    atomic ensures nodePred(r, nn, Inn, Cnn)
    atomic ensures k in inset(Inn) && k !in out(Inn)

  proc cssOp(r: css, ghost C: Set[K], dop: Op, k: K)
    returns (res: Bool, implicit ghost C1: Set[K])
    requires k in KS
    requires cssI(r)
    atomic requires cssR(r, C)
    atomic ensures cssR(r, C1) && opSpec(dop, k, C, C1, res)
  {
    var n := traverse(r, r.node, k)

    var succ: Bool, Cn1: Set[K];
    succ, res, Cn1 := decisiveOp(n, dop, k);
    if (succ) {
      unlockNode(n);
      return res
    } else {
      unlockNode(n);
      cssOp(r, dop, k)
    }
  }
}
	
