

field c: Bool
ghost field p: Proph

func nondet_bool() returns (ret: Bool) { true }

pred is_coin(coin: Ref, bs: List[Bool]) {
  exists b: Bool, bs': List[Bool], p': Proph ::
    own(coin.c, b) && own(coin.p, p') && 
    (bs == b :: bs' && Proph.prophecy(p', bs'))
}

proc new_clairvoyant_coin() returns (ret: Ref, implicit ghost bs: List[Bool]) 
  ensures is_coin(ret, bs)
{
  ghost var p1: Proph;
  var z: List[Bool];
  p1, z := Proph.new[Bool]; 

  var toss := nondet_bool();

  var x: Ref := new(c: toss, p: p1);

  fold is_coin(x, toss ::z);
  return x, toss :: z;
}

proc read_coin(coin: Ref, implicit ghost bs: List[Bool]) 
  returns (ret: Bool, implicit ghost bs': List[Bool]) 
  requires is_coin(coin, bs)
  ensures is_coin(coin, bs) && bs == ret :: bs'
{
  unfold is_coin(coin, bs);

  ret := coin.c;
  bs' := List.tl(bs);
  
  fold is_coin(coin, bs);
  return ret, bs';
}

proc toss_coin(coin: Ref, implicit ghost bs: List[Bool]) 
  returns (implicit ghost b: Bool, implicit ghost bs2: List[Bool])
  requires is_coin(coin, bs)
  ensures is_coin(coin, bs2) && bs == b :: bs2
{
  unfold is_coin(coin, bs);

  ghost var ret_bool := coin.c;
  ghost var proph_var := coin.p;

  var toss := nondet_bool();

  Proph.resolve(proph_var, toss);

  coin.c := toss;
  bs2 := List.tl(bs);

  fold is_coin(coin, bs2);
  return ret_bool, bs2;
}