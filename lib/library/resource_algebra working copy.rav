interface Type {
    rep type T
}

interface ResourceAlgebra {
    rep type T

    var id: T
    func comp(a:T, b:T) returns (ret:T)
    /* alias : a ∘ b = comp(a,b) ? */

    func frame(a:T, b:T) returns (ret:T)

    func valid(a:T) returns (ret: Bool)

    func fpuAllowed(a:T, b:T) returns (ret: Bool)
        // ensures ret ==> forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))
    // { forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))}

    lemma idValid()
        ensures valid(id)

    lemma compAssoc()
        ensures forall a:T, b:T, c:T :: (comp(comp(a, b), c) == comp(a, comp(b, c)))

    lemma compCommute()
        ensures forall a:T, b:T :: comp(a, b) == comp(b, a)
		
    // lemma fpu_app(l:T, a:T, b:T)
    //     requires own(l, a)
    //     requires fpu(a,b)
    //     ensures own(l, b)
    //     /* Should this be a lemma or something else? */

    lemma compId()
        ensures forall a:T :: comp(a, id) == a

    lemma compValid()
        ensures forall a:T, b:T :: valid(comp(a, b)) ==> valid(a) && valid(b)

    lemma frameId()
        ensures forall a:T :: frame(a, id) == a

    lemma frameCompInv()
        ensures forall a:T, b:T:: valid(comp(a, b)) ==> frame(comp(a, b), b) == a

    lemma compFrameInv()
        ensures forall a:T, b:T :: (valid(frame(a,b))) ==> comp(frame(a,b), b) == a

    lemma fpuValid()
        ensures (forall a:T, b:T, c:T :: fpuAllowed(a,b) && valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c)))

    lemma fpuReflexive()
        ensures (forall a:T :: valid(a) ==> fpuAllowed(a,a))
}

interface CancellativeResourceAlgebra : ResourceAlgebra {
    rep type T

    var id: T

    func comp(a:T, b:T) returns (ret:T)
    func frame(a:T, b:T) returns (ret:T)

    func valid(a:T) returns (ret: Bool)

    func fpuAllowed(a:T, b:T) returns (ret: Bool)

    lemma cancellative()
        ensures forall a:T, b:T, c:T :: (valid(comp(a, b)) && comp(a,b) == comp(c,b) ==> (a == c))

    // lemma frameValid()
    //     ensures forall a:T, b:T :: valid(b) && valid(frame(a,b)) ==> valid(a)

    lemma frameCompInv()
        ensures forall a:T, b:T:: valid(comp(a, b)) ==> frame(comp(a, b), b) == a

    lemma frameReflexive()
        ensures forall a:T :: valid(a) ==> frame(a, a) == id
}

interface LatticeResourceAlgebra : ResourceAlgebra {
    rep type T

    var id: T

    func comp(a:T, b:T) returns (ret:T)
    func frame(a:T, b:T) returns (ret:T)

    func valid(a:T) returns (ret: Bool)

    func fpuAllowed(a:T, b:T) returns (ret: Bool)
}

module Nat : CancellativeResourceAlgebra {
    rep type T = Int

    var id: T = 0

    func valid(n:T) returns (ret:Bool) { n >= 0 }

    func comp(a:T, b:T) returns (ret:T) { 
        (a == id ? 
            b : 
            (b == id ? 
                a :
                (valid(a) && valid(b) ? 
                    a+b : 
                    -1
                )
            ) 
        )
        // (valid(a) && valid(b)) ? a+b : -1
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == id ? 
            a :
        (valid(a) && valid(b) ?
            a-b : -1)

        // valid(a) && valid(b) ?
        //     a-b : -1
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) 
        // ensures forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))
    {
        // true
        forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))
    }
}

module Auth [M: ResourceAlgebra] : ResourceAlgebra {
    rep type T = data { 
        case frag(f_proj1: M);
        case auth_frag(af_proj1: M, af_proj2: M);
        case top
    }
    
    val id: T = frag(M.id);

    func valid(n:T) 
        returns (ret:Bool) 
    {
        (n == frag(n.f_proj1) ?
            M.valid(n.f_proj1) :
        (n == auth_frag(n.af_proj1, n.af_proj2) ? 
            M.valid(n.af_proj1) && M.valid(n.af_proj2) && M.valid(M.frame(n.af_proj1, n.af_proj2)) :
            false
        )
        )
    }

    func comp(a:T, b:T)
        returns (ret:T)
    {
        (a == frag(a.f_proj1) && b == frag(b.f_proj1)) ?
            (frag(M.comp(a.f_proj1, b.f_proj1))) :
        ((a == frag(a.f_proj1) && b == auth_frag(b.af_proj1, b.af_proj2)) ?
            auth_frag(b.af_proj1, M.comp(a.f_proj1, b.af_proj2)) :
        ((a == auth_frag(a.af_proj1, a.af_proj2) && b == frag(b.f_proj1)) ? 
            auth_frag(a.af_proj1, M.comp(b.f_proj1, a.af_proj2)) :
            top()))
    }

    func frame(a:T, b:T) returns (ret:T) {
        (a == frag(a.f_proj1) && b == frag(b.f_proj1)) ?
            (frag(M.frame(a.f_proj1, b.f_proj1))) :
        ((a == frag(a.f_proj1) && b == auth_frag(b.af_proj1, b.af_proj2)) ?
            top() :
        ((a == auth_frag(a.af_proj1, a.af_proj2) && b == frag(b.f_proj1)) ? 
            auth_frag(a.af_proj1, M.frame(a.af_proj2, b.f_proj1)) :
        ((a == auth_frag(a.af_proj1, a.af_proj2) && b == auth_frag(b.af_proj1, b.af_proj2) ? 
            (a.af_proj1 == b.af_proj1 ? frag(M.frame(a.af_proj2, b.af_proj2)) : top()) :
            top()
        ))))
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) 
        // ensures forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))    
    {
        // forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))

        a == b ? true :

        (a == auth_frag(a.af_proj1, a.af_proj2) && b == auth_frag(b.af_proj1, b.af_proj2) ?
            (M.valid(M.frame(b.af_proj1, a.af_proj1)) && 
            M.valid(M.frame(b.af_proj2, a.af_proj2)) && 
            M.valid(M.frame(M.frame(b.af_proj1, a.af_proj1), M.frame(b.af_proj2, a.af_proj2)))) :

            false)
        
    }
}

// Agree(X)
// Frac
// Frac-Agree(X)
// Map(X,M)
// SetRA


module Frac[X: Type] : ResourceAlgebra {
    rep type T = data {
        case frac_null;
        case frac_chunk(frac_proj1: X, frac_proj2: Int);
        case frac_top
    }

    val id: T = frac_null()

    func valid(n:T) 
        returns (ret:Bool) 
    {
        (n == frac_chunk(n.frac_proj1, n.frac_proj2) ?
            (n.frac_proj2 > 0 && n.frac_proj2 <= 1) : 
            (n == frac_null() ? true : 
                false
            )
        )
    }

    func comp(a:T, b:T)
        returns (ret:T)
    {
        a == frac_null() ? b :
        (b == frac_null() ? a :
        (valid(a) && valid(b) ? 
            (a.frac_proj1 == b.frac_proj1 ? frac_chunk(a.frac_proj1, a.frac_proj2 + b.frac_proj2) : frac_top()) : 
            frac_top()
        )
        )

        // valid(a) && valid(b) ?
        //     (a == frac_null() ? b :
        //     (b == frac_null() ? a :
        //     (a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_chunk(b.frac_proj1, b.frac_proj2) ? 
        //         (a.frac_proj1 == b.frac_proj1 ? frac_chunk(a.frac_proj1, a.frac_proj2 + b.frac_proj2) : frac_top()) :
        //         frac_top()
        //     )
        //     )
        //     ) :
        //     frac_top()
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == frac_null() ? a :

        (a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_chunk(b.frac_proj1, b.frac_proj2) && valid(a) && valid(b) ? 
            (a.frac_proj1 == b.frac_proj1 ? 
                (a.frac_proj2 == b.frac_proj2 ? frac_null() : frac_chunk(a.frac_proj1, a.frac_proj2 - b.frac_proj2)) : 
                frac_top()
            ) : 
            frac_top()
        )
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) 
        // ensures forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))    
    {
        a == b ? true : 
        (a == frac_chunk(a.frac_proj1, a.frac_proj2) ?
            a.frac_proj2 == 1 :
        (a == frac_top() ? true : false))
    }
}

// module KeySetRA[X] : ResourceAlgebra {
//     type T1 = Set[X]
//     rep type = data {
//         case ksBot;
//         case ksPair(ks_proj1: T1, ks_proj2: T2);
//         case ksTop
//     }

//     var id: T = ksBot

//     func comp(a:T, b:T) returns (ret:T) {
//         a == ksBot() ? b :
//         (b == ksBot() ? a :
//         (a == ksPair(a.ks_proj1, a.ks_proj2) && b == ksPair(b.ks_proj1, b.ks_proj2) ?
//             (valid(a) && valid(b) && (a.ks_proj1 ** b.ks_pro1 == {||}) ?
//                 ksPair(a.ks_proj1 ++ b.ks_proj1, a.ks_proj2 ++ b.ks_proj2) : 
//                 ksTop()
//             ) :
//             ksTop()
//         )
//         )
//     }

//     func frame(a:T, b:T) returns (ret:T) {

//     }

//     func valid(a:T) returns (ret: Bool)

//     func fpu(a:T, b:T) returns (ret: Bool)

//     /* alias : a ∘ b = comp(a,b) ? */
// }


// interface LatticeResourceAlgebra : ResourceAlgebra {

// }

// interface CancellativeResourceAlgebra : Resource_algebra {
//     lemma cancellative()
//         ensures (forall a:T, b:T, c:T :: (valid(comp(a, b) && comp(a,b) == comp(c,b))) ==> (a == c))

    
// }
