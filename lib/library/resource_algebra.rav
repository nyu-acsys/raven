interface Type {
    rep type T
}

interface ResourceAlgebra : Type {
    rep type T

    val id: T
    func comp(a:T, b:T) returns (ret:T)
    /* alias : a âˆ˜ b = comp(a,b) ? */

    func frame(a:T, b:T) returns (ret:T)

    func valid(a:T) returns (ret: Bool)

    func fpuAllowed(a:T, b:T) returns (ret: Bool)

    auto axiom idValid()
        ensures valid(id)

    auto axiom compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))

    auto axiom compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)

    auto axiom compId()
        ensures forall a:T :: {comp(a, id)} {comp(id, a)} comp(a, id) == a

    auto axiom compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)

    auto axiom frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a

    auto axiom compFrameInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a

    auto axiom fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))

    auto axiom fpuReflexive()
        ensures (forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a))

    auto axiom frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)

    auto axiom weak_frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))

}

interface CancellativeResourceAlgebra : ResourceAlgebra {
    auto axiom frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == a

    lemma frameReflexive()
        ensures forall a:T :: {frame(a,a)} valid(a) ==> frame(a, a) == id
    {
        assert forall a:T, b:T, c:T :: valid(a) ==> frame(a, a) == id with {
            if (valid(a)) {
                assert valid(comp(id, a));
            }
        }
    }

    lemma cancellative()
      ensures forall a:T, b:T, c:T :: {comp(a,b),comp(c,b)} (valid(comp(a, b)) && comp(a,b) == comp(c,b) ==> (a == c))
    {
      //frameCompInv();
      assert forall a:T, b:T, c:T :: (valid(comp(a, b)) && comp(a,b) == comp(c,b) ==> (a == c)) with {
        if (valid(comp(a, b)) && comp(a,b) == comp(c,b)) {
            assert frame(comp(a, b), b) == a;
            //assert frame(comp(c, b), b) == c;
        }
      }
    }
}

interface LatticeResourceAlgebra : ResourceAlgebra {
    auto axiom frameCompInv()
        ensures forall a:T, b:T :: valid(frame(a, b)) ==> frame(a, b) == a

    auto axiom frameCompInv0()
        ensures forall a:T, b:T :: valid(comp(a, b)) ==> frame(comp(a, b), b) == comp(a, b)

    auto axiom frameCompInv2()
        ensures forall a:T, b:T :: comp(a, b) == a && valid(a) ==> frame(a, b) == a

    auto axiom frame_comp_inv()
        ensures forall a:T, b:T, c:T :: {frame(a, comp(b,c))} {frame(frame(a, b), c)} frame(a, comp(b,c)) == frame(frame(a, b), c)
}

module Nat : CancellativeResourceAlgebra {
    rep type T = Int

    val id: T = 0

    func valid(n:T)
      returns (ret:Bool)
      { n >= 0 }

    func comp(a:T, b:T) returns (ret:T) { 
        (a == id ? 
            b : 
            (b == id ? 
                a :
                (valid(a) && valid(b) ? 
                    a+b : 
                    -1
                )
            ) 
        )
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == id ? 
            a :
        (valid(a) && valid(b) ?
            a-b : -1)
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) {
        forall c:T :: valid(a) && valid(comp(a,c)) ==> valid(comp(b,c))
    }

    lemma idValid()
        ensures valid(id)
    {}

    lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} 
            (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {}

    lemma compId()
        ensures forall a:T :: {comp(a, id)} comp(a, id) == a
    {}
 
    lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}
    
    lemma compFrameInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    {}
    
    lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    lemma fpuReflexive()
        ensures (forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a))
    {}
    
    lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}

    lemma frameCompInv()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == a
    {}

    //lemma frameReflexive()
    //    ensures forall a:T :: {frame(a,a)} valid(a) ==> frame(a, a) == id
    //{}
}

module Auth[M: ResourceAlgebra] : ResourceAlgebra {
    rep type T = data { 
        case frag(f_proj1: M)
        case auth_frag(af_proj1: M, af_proj2: M)
        case top
    }
    
    val id: T = frag(M.id)

    func valid(n:T) returns (ret:Bool) {
        (n == frag(n.f_proj1) ?
            M.valid(n.f_proj1) :
        (n == auth_frag(n.af_proj1, n.af_proj2) ? 
            M.valid(n.af_proj1) && M.valid(n.af_proj2) && M.valid(M.frame(n.af_proj1, n.af_proj2)) :
            false
        )
        )
    }

    func comp(a:T, b:T) returns (ret:T) {
        (a == frag(a.f_proj1) && b == frag(b.f_proj1)) ?
            (frag(M.comp(a.f_proj1, b.f_proj1))) :
        ((a == frag(a.f_proj1) && b == auth_frag(b.af_proj1, b.af_proj2)) ?
            auth_frag(b.af_proj1, M.comp(a.f_proj1, b.af_proj2)) :
        ((a == auth_frag(a.af_proj1, a.af_proj2) && b == frag(b.f_proj1)) ? 
            auth_frag(a.af_proj1, M.comp(b.f_proj1, a.af_proj2)) :
            top))
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == id ? a : 
        ((a == frag(a.f_proj1) && b == frag(b.f_proj1)) ?
            (frag(M.frame(a.f_proj1, b.f_proj1))) :
        ((a == frag(a.f_proj1) && b == auth_frag(b.af_proj1, b.af_proj2)) ?
            top :
        ((a == auth_frag(a.af_proj1, a.af_proj2) && valid(a) && b == frag(b.f_proj1)) ? 
            auth_frag(a.af_proj1, M.frame(a.af_proj2, b.f_proj1)) :
        ((a == auth_frag(a.af_proj1, a.af_proj2) && valid(a) && b == auth_frag(b.af_proj1, b.af_proj2) ? 
            (a.af_proj1 == b.af_proj1 ? frag(M.frame(a.af_proj2, b.af_proj2)) : top) :
            top
        )))))
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) {
        a == b ? true :

        (
            a == auth_frag(a.af_proj1, a.af_proj2) && 
            b == auth_frag(b.af_proj1, b.af_proj2) && 
            valid(a) && valid(b) && 
            (forall c: M :: a.af_proj1 == M.comp(a.af_proj2, c) ==> b.af_proj1 == M.comp(b.af_proj2, c))
        )
    }

    func auth(a:M) returns (ret: T) {
        auth_frag(a, M.id)
    }

    auto lemma idValid()
        ensures valid(id)
    { M.idValid(); }

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    { M.compCommute(); M.compAssoc(); }

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    { M.compCommute(); }

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} {comp(id, a)} comp(a, id) == a
    { M.compCommute(); M.compId(); }

    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    { 
        M.compValid(); M.compAssoc(); M.compFrameInv(); 
        M.weak_frameCompInv();


    }

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}

    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    { 
        M.compCommute(); 
        M.compId(); 
        M.compValid(); 
        M.compFrameInv();
    }
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    { 
        M.idValid(); M.compAssoc(); M.compCommute(); M.compId(); M.compValid(); M.frameId(); M.compFrameInv();
        M.fpuValid(); M.fpuReflexive(); M.frameValid(); M.weak_frameCompInv();

        assert forall a:T, b:T, c:T :: 
            ( a == auth_frag(a.af_proj1, a.af_proj2) && b == auth_frag(b.af_proj1, b.af_proj2) && c == frag(c.f_proj1)) ==>
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c));

        

    }
    
    
    auto lemma fpuReflexive()
        ensures forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {
        M.idValid(); M.compAssoc(); M.compCommute(); M.compId(); M.compValid(); M.frameId(); M.compFrameInv();
        M.fpuValid(); M.fpuReflexive(); M.frameValid(); M.weak_frameCompInv();

    }
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {
        M.idValid(); M.compAssoc(); M.compCommute(); M.compId(); M.compValid(); M.frameId(); M.compFrameInv();
        M.fpuValid(); M.fpuReflexive(); M.frameValid(); M.weak_frameCompInv();
    }

}

module Frac[X: Type] : CancellativeResourceAlgebra {
    rep type T = data {
        case frac_null;
        case frac_chunk(frac_proj1: X, frac_proj2: Real);
        case frac_top
    }

    val id: T = frac_null()

    func valid(n:T) 
        returns (ret:Bool) 
    {
        (n == frac_chunk(n.frac_proj1, n.frac_proj2) ?
            (n.frac_proj2 > 0.0 && n.frac_proj2 <= 1.0) : 
            (n == frac_null() ? true : 
                false
            )
        )
    }

    func comp(a:T, b:T) returns (ret:T) {
        a == frac_null() ? b :
        (b == frac_null() ? a :
        (valid(a) && valid(b) ? 
            (a.frac_proj1 == b.frac_proj1 && a.frac_proj2 + b.frac_proj2 > 0.0 && a.frac_proj2 + b.frac_proj2 <= 1.0 ? 
                frac_chunk(a.frac_proj1, a.frac_proj2 + b.frac_proj2) :
                frac_top()) : 
            frac_top()
        )
        )
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == frac_null() ? a :

        (a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_chunk(b.frac_proj1, b.frac_proj2) && valid(a) && valid(b) ? 
            (a.frac_proj1 == b.frac_proj1 ? 
                (a.frac_proj2 == b.frac_proj2 ? frac_null() : frac_chunk(a.frac_proj1, a.frac_proj2 - b.frac_proj2)) : 
                frac_top()
            ) : 
            frac_top()
        )
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) {
        a == b ? true : 
        (a == frac_chunk(a.frac_proj1, a.frac_proj2) ?
            a.frac_proj2 == 1.0 && valid(b) :
        (a == frac_top() ? true : false))
    }

    auto lemma frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == a
    {}

    //auto lemma frameReflexive()
    //    ensures forall a:T :: {frame(a,a)} valid(a) ==> frame(a, a) == id
    //{}

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {}

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} {comp(id, a)} comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    {}
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    auto lemma fpuReflexive()
        ensures forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}
}

module AgreeRA[X: Type] : LatticeResourceAlgebra {
    rep type T = data {
        case agree_null;
        case agree_constr(agree_proj1: X);
        case agree_top
    }

    val id: T = agree_null

    func valid(n:T) returns (ret:Bool) {
        n != agree_top
    }

    func comp(a:T, b:T) returns (ret: T) {
        a == id ? b :
        (b == id ? a :
        (a == agree_constr(a.agree_proj1) && b == a ? a : agree_top))
    }

    func frame(a:T, b:T) returns (ret: T) {
        b == agree_null ? a :

        (a == b ? a : agree_top)
        // (a == agree_constr(a.agree_proj1) && b == agree_constr(b.agree_proj1) ? 
        //     (a.agree_proj1 == b.agree_proj1 ? 
        //         agree_constr(a.agree_proj1) : 
        //         agree_top()
        //     ) : 
        //     agree_top()
        // )
    }

    func fpuAllowed(a:T, b:T) returns (ret: Bool) {
        a == b ? true : false
    }

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a: T, b: T, c: T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a: T, b: T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {
    }

    auto lemma compId()
        ensures forall a: T :: {comp(a, id)} comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a: T, b: T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a: T :: {frame(a,id)} frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a: T, b: T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    { 
        assert forall a: T :: (a == agree_null() || a == agree_constr(a.agree_proj1) || a == agree_top()) ;
    }
    
    auto lemma fpuValid()
        ensures forall a: T, b: T, c: T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    auto lemma fpuReflexive()
        ensures forall a: T :: {valid(a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a: T, b: T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a: T, b: T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}

    auto lemma frameCompInv()
        ensures forall a: T, b: T :: {frame(a,b)} valid(frame(a, b)) ==> frame(a, b) == a
    {}
    
    auto lemma frameCompInv0()
        ensures forall a: T, b: T :: {frame(comp(a, b), b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == comp(a, b)
    {}
    
    auto lemma frameCompInv2()
        ensures forall a: T, b: T :: {comp(a,b), frame(a,b)} comp(a, b) == a && valid(a) ==> frame(a, b) == a
    {}
    
    auto lemma frame_comp_inv()
        ensures forall a: T, b: T, c: T :: {frame(a, comp(b,c))} {frame(frame(a, b), c)} frame(a, comp(b,c)) == frame(frame(a, b), c)
    { 
        assert forall a: T :: (a == agree_null() || a == agree_constr(a.agree_proj1) || a == agree_top()) ;
    }

}

module CountAgreeRA[X: Type] : CancellativeResourceAlgebra {
    rep type T = data {
        case count_null;
        case count_cons(count: Int, value: X);
        case count_top
    }

    val id: T = count_null()

    func valid(n:T) returns (ret:Bool) {
        n == count_null() || (n == count_cons(n.count, n.value) && n.count > 0)
    }

    func comp(a: T, b: T) returns (ret:T) {
        a == count_null() ? b :
        (b == count_null() ? a :
        (a == count_cons(a.count, a.value) && b == count_cons(b.count, b.value) && valid(a) && valid(b) ? 
            (a.value == b.value ? count_cons(a.count + b.count, a.value) : count_top()) :
            count_top()
        )
        )
    }

    func frame(a: T, b: T) returns (ret:T) {
        b == count_null() ? a :

        (a == count_cons(a.count, a.value) && b == count_cons(b.count, b.value) && valid(a) && valid(b) ? 
            (a.value == b.value ? 
                (a.count == b.count ? count_null() : count_cons(a.count - b.count, a.value)) : 
                count_top()
            ) :
            count_top()
        )
    }

    func fpuAllowed(a: T, b: T) returns (ret:Bool) {
        a == b ? true : 

        (a == count_cons(a.count, a.value) && b == count_cons(b.count, b.value) && valid(a) && valid(b) ? 
            (a.value == b.value) :
            false
        )
    }

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {}

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {comp(frame(a, b), b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    {}
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    auto lemma fpuReflexive()
        ensures forall a:T :: {fpuAllowed(a,a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {frame(comp(a, b), b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}

    auto lemma frameCompInv()
        ensures forall a:T, b:T:: {frame(comp(a, b), b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == a
    { 
        assert forall a:T, b:T ::  (a == count_cons(a.count, a.value) && b == count_cons(b.count, b.value)) ==>  (valid(comp(a, b)) ==> a.value == b.value);
        assert forall a:T, b:T ::  (a == count_cons(a.count, a.value) && b == count_cons(b.count, b.value)) ==>  (valid(comp(a, b)) ==> frame(comp(a, b), b) == a); 
    }

    //auto lemma frameReflexive()
    //    ensures forall a:T :: {frame(a,a)} {valid(a)} valid(a) ==> frame(a, a) == id
    //{}

}

module SetRA[X: Type] : LatticeResourceAlgebra {
    rep type T = data {
        case set_constr(set_proj1: Set[X]);
        case set_top
    }

    val id: T = set_constr({||})

    func valid(n:T) returns (ret:Bool) {
        n == set_constr(n.set_proj1)
    }

    func comp(a:T, b:T) returns (ret:T) {
        a == set_constr(a.set_proj1) && b == set_constr(b.set_proj1) ? 
            set_constr(a.set_proj1 ++ b.set_proj1) :
            set_top()
    }

    func frame(a:T, b:T) returns (ret:T) {
        a == set_constr(a.set_proj1) && b == set_constr(b.set_proj1) ?
            (b.set_proj1 subseteq a.set_proj1 ? a : set_top()) :
            set_top()
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) {
        a == set_constr(a.set_proj1) && b == set_constr(b.set_proj1) ?
            a.set_proj1 subseteq b.set_proj1 :
        (a == set_top() && b == set_top() ? 
            true :
            false
        )
    }

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {}

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    {}
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    auto lemma fpuReflexive()
        ensures forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}

    auto lemma frameCompInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> frame(a, b) == a
    {}
    
    auto lemma frameCompInv0()
        ensures forall a:T, b:T :: {frame(comp(a, b), b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == comp(a, b)
    {}
    
    auto lemma frameCompInv2()
        ensures forall a:T, b:T :: {comp(a,b), frame(a,b)} comp(a, b) == a && valid(a) ==> frame(a, b) == a
    {}
    
    auto lemma frame_comp_inv()
        ensures forall a:T, b:T, c:T :: {frame(a, comp(b,c))} {frame(frame(a, b), c)} frame(a, comp(b,c)) == frame(frame(a, b), c)
    {}
}

// TW: not sure this belongs in the standard library
module KeysetRA[X: Type] : CancellativeResourceAlgebra {
    rep type T = data {
        case ksPair(keyset: Set[X], contents: Set[X]);
        case ksTop
    }

    val id: T = ksPair({||}, {||})

    func valid(n:T) returns (ret: Bool) {
        n == ksPair(n.keyset, n.contents) ? 
            n.contents subseteq n.keyset : 
            false 
    }

    func comp(a:T, b:T) returns (ret:T) {
        a == id ? b :
        (b == id ? a :
        (valid(a) && valid(b) && (a.keyset ** b.keyset == {||}) ?
                ksPair(a.keyset ++ b.keyset, a.contents ++ b.contents) : 
                ksTop
            )
        )
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == id ? a :
        (valid(a) && valid(b) && b.keyset subseteq a.keyset && b.contents subseteq a.contents ?
            ksPair(a.keyset -- b.keyset, a.contents -- b.contents) :
            ksTop
        )
    }

    func fpuAllowed(a:T, b:T) returns (ret: Bool) {
        a == b ? true :
        (a == ksPair(a.keyset, a.contents) && b == ksPair(b.keyset, b.contents) ? 
            valid(a) && valid(b) && b.keyset subseteq a.keyset : false
        )
    }

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {}

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {comp(frame(a, b), b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    { 
        //assert forall a:T, b:T ::  (a == ksPair(a.keyset, a.contents) && b == ksPair(b.keyset, b.contents)) ==>  (valid(frame(a, b)) ==> comp(frame(a, b), b) == a); 
    }
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    auto lemma fpuReflexive()
        ensures forall a:T :: {fpuAllowed(a,a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {frame(comp(a, b), b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}

    auto lemma frameCompInv()
        ensures forall a:T, b:T:: {frame(comp(a, b), b)} valid(comp(a, b)) ==> frame(comp(a, b), b) == a
    {
      assert forall a:T, b:T:: valid(comp(a, b)) ==> frame(comp(a, b), b) == a with {
        if (valid(comp(a, b))) {
          assert comp(a,b).keyset == a.keyset ++ b.keyset;
          assert comp(a,b).contents == a.contents ++ b.contents;
        }
      }
    }

    //auto lemma frameReflexive()
    //    ensures forall a:T :: {frame(a,a)} {valid(a)} valid(a) ==> frame(a, a) == id
    //{}

}

module Prod[M1: ResourceAlgebra, M2: ResourceAlgebra] : ResourceAlgebra {
    rep type T = data {
        case prod(proj1: M1, proj2: M2)
    }

    val id: T = prod(M1.id, M2.id)

    func valid(n:T) returns (ret:Bool) {
        n == prod(n.proj1, n.proj2) ? M1.valid(n.proj1) && M2.valid(n.proj2) : false
    }

    func comp(a:T, b:T) returns (ret:T) {
        a == prod(a.proj1, a.proj2) && b == prod(b.proj1, b.proj2) ? 
            prod(M1.comp(a.proj1, b.proj1), M2.comp(a.proj2, b.proj2)) : 
            prod(M1.id, M2.id)
    }

    func frame(a:T, b:T) returns (ret:T) {
        b == id ? a : 
        (a == prod(a.proj1, a.proj2) && b == prod(b.proj1, b.proj2) ? 
            prod(M1.frame(a.proj1, b.proj1), M2.frame(a.proj2, b.proj2)) : 
            prod(M1.id, M2.id)
        )
    }

    func fpuAllowed(a:T, b:T) returns (ret:Bool) {
        a == b ? true : 
        (a == prod(a.proj1, a.proj2) && b == prod(b.proj1, b.proj2) ? 
            M1.fpuAllowed(a.proj1, b.proj1) && M2.fpuAllowed(a.proj2, b.proj2) : 
            false
        )
    }

    auto lemma idValid()
        ensures valid(id)
    { M1.idValid(); M2.idValid(); }

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    { M1.compAssoc(); M2.compAssoc(); }

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    { M1.compCommute(); M2.compCommute(); }

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} {comp(id, a)} comp(a, id) == a
    { M1.compId(); M2.compId(); }

    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    { M1.compValid(); M2.compValid(); }

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    { M1.frameId(); M2.frameId(); }

    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    { M1.compFrameInv(); M2.compFrameInv(); }

    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    { M1.fpuValid(); M2.fpuValid(); }

    auto lemma fpuReflexive()
        ensures forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a)
    { M1.fpuReflexive(); M2.fpuReflexive(); }

    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    { M1.frameValid(); M2.frameValid(); }

    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    { M1.weak_frameCompInv(); M2.weak_frameCompInv(); }
}

module AtomicTokenRA[InArg: Type, RetArg: Type] : ResourceAlgebra {
    rep type T = data {
        case au_null;
        case au_uncommitted(au_uncommit_proj1: InArg);
        case au_committed(au_commit_proj1: InArg, au_commit_proj2: RetArg);
        case au_top
    }

    val id: T = au_null

    func comp(a:T, b:T) returns (ret:T) {
        a == id ? b :
        (b == id ? a :
            (a == au_uncommitted(a.au_uncommit_proj1) ? au_top :
                (b == au_uncommitted(b.au_uncommit_proj1) ? au_top :
                    (a == au_committed(a.au_commit_proj1, a.au_commit_proj2) && b == a ? a : au_top)
                        // a == b ? a : au_top()
                )
            )
        )
    }
    

    func frame(a:T, b:T) returns (ret:T) {
        b == id ? a :
        (a == au_uncommitted(a.au_uncommit_proj1) && b == au_uncommitted(b.au_uncommit_proj1) ? 
            (a.au_uncommit_proj1 == b.au_uncommit_proj1 ? id : au_top) :
            (a == b ? a : au_top)
        )
    }

    func valid(a:T) returns (ret: Bool) {
        a != au_top
        //a == au_uncommitted(a.au_uncommit_proj1) || a == au_committed(a.au_commit_proj1, a.au_commit_proj2) || a == au_null()
    }


    func fpuAllowed(a:T, b:T) returns (ret: Bool) {
        a == b ? true : 
        (a == au_uncommitted(a.au_uncommit_proj1) && b == au_committed(b.au_commit_proj1, b.au_commit_proj2) ? 
            a.au_uncommit_proj1 == b.au_commit_proj1 : 
            false
        )
    }

    auto lemma idValid()
        ensures valid(id)
    {}

    auto lemma compAssoc()
        ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
    {}

    auto lemma compCommute()
        ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
    {}

    auto lemma compId()
        ensures forall a:T :: {comp(a, id)} comp(a, id) == a
    {}
 
    auto lemma compValid()
        ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
    {}

    auto lemma frameId()
        ensures forall a:T :: {frame(a,id)} frame(a, id) == a
    {}
    
    auto lemma compFrameInv()
        ensures forall a:T, b:T :: {comp(frame(a, b), b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
    {
        assert forall a:T, b:T :: {comp(frame(a, b), b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a with {
            if (valid(frame(a,b))) { 
              assert a != au_top && b != au_top;
            }
        }
    }
    
    auto lemma fpuValid()
        ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
            (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
    {}
    
    auto lemma fpuReflexive()
        ensures forall a:T :: {fpuAllowed(a,a)} valid(a) ==> fpuAllowed(a,a)
    {}
    
    auto lemma frameValid()
        ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
    {}
    
    auto lemma weak_frameCompInv()
        ensures forall a:T, b:T:: {frame(comp(a, b), b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
    {}
}

// module InvRA[X: Type] : ResourceAlgebra {
//     rep type T = data {
//         case inv_null;
//         case inv_closed(inv_closed_proj1: X);
//         case inv_open(inv_open_proj1: X);
//         case inv_top
//     }

//     val id: T = inv_null()

//     func valid(n:T) 
//         returns (ret:Bool) 
//     {
//         n == inv_closed(n.inv_closed_proj1) || n == inv_open(n.inv_open_proj1) || n == inv_null()
//     }

//     func comp(a:T, b:T) returns (ret:T) {
//         a == id ? b :
//         (b == id ? a :
//         (a == inv_closed(a.inv_closed_proj1) && b == a ? a :
//         (a == inv_closed(a.inv_closed_proj1) && b == inv_open(a.inv_closed_proj1) ? b :
//         (a == inv_open(a.inv_open_proj1) && b == inv_closed(a.inv_open_proj1) ? a : inv_top))))
//     }

//     func frame(a:T, b:T) returns (ret:T) {
//         b == id ? a :
//         (a == inv_closed(a.inv_closed_proj1) && a == b ? a :
//         (a == inv_open(a.inv_open_proj1) && a == b ? id :
//         (a == inv_open(a.inv_open_proj1) && b == inv_closed(a.inv_open_proj1) ? 
//             inv_open(a.inv_open_proj1) : inv_top())))
//     }

//     func fpuAllowed(a:T, b:T) returns (ret: Bool) {
//         a == b ? true : 
//         (a == inv_open(a.inv_open_proj1) && b == inv_closed(b.inv_closed_proj1) ? 
//             a.inv_open_proj1 == b.inv_closed_proj1 : 
//             false
//         )
    
//     }    

//     auto lemma idValid()
//         ensures valid(id)
//     {}

//     auto lemma compAssoc()
//         ensures forall a:T, b:T, c:T :: {comp(comp(a, b), c)} {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
//     {}

//     auto lemma compCommute()
//         ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
//     { assert forall a:T, b:T :: (a == inv_closed(a.inv_closed_proj1)) ==> (comp(a, b) == comp(b, a)); }

//     auto lemma compId()
//         ensures forall a:T :: {comp(a, id)} comp(a, id) == a
//     {}
 
//     auto lemma compValid()
//         ensures forall a:T, b:T :: {comp(a,b)} valid(comp(a, b)) ==> valid(a) && valid(b)
//     {}

//     auto lemma frameId()
//         ensures forall a:T :: {frame(a,id)} frame(a, id) == a
//     {}
    
//     auto lemma compFrameInv()
//         ensures forall a:T, b:T :: {comp(frame(a, b), b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
//     {}
    
//     auto lemma fpuValid()
//         ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} 
//             (fpuAllowed(a,b) && valid(a) && valid(comp(a,c))) ==> valid(comp(b,c))
//     {}
    
//     auto lemma fpuReflexive()
//         ensures (forall a:T :: {fpuAllowed(a,a)} valid(a) ==> fpuAllowed(a,a))
//     {}
    
//     auto lemma frameValid()
//         ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a,b)) ==> valid(a) && valid(b)
//     {}
    
//     auto lemma weak_frameCompInv()
//         ensures forall a:T, b:T:: {frame(comp(a, b), b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
//     { assert forall a:T, b:T:: (a == inv_closed(a.inv_closed_proj1)) ==> (valid(comp(a, b)) ==> valid(frame(comp(a, b), b))); }
// }



// module FracPers[X: Type] : ResourceAlgebra {
//     rep type T = data {
//         case frac_null;
//         case frac_chunk(frac_proj1: X, frac_proj2: Real);
//         case frac_pers(frac_pers_proj1: X);
//         case frac_top
//     }

//     val id: T = frac_null()

//     func valid(n:T) 
//         returns (ret:Bool) 
//     {
//         (n == frac_chunk(n.frac_proj1, n.frac_proj2) ?
//             (n.frac_proj2 > 0.0 && n.frac_proj2 <= 1.0) : 
//             (n == frac_null() ? true : 
//                 (n == frac_pers(n.frac_pers_proj1) ? true :
//                 false)
//             )
//         )
//     }

//     func comp(a:T, b:T)
//         returns (ret:T)
//     {
//         a == frac_null() ? b :
//         (b == frac_null() ? a :
//         (valid(a) && valid(b) ?

//         (
            
//             (a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_chunk(b.frac_proj1, b.frac_proj2)) ?

//                 (a.frac_proj1 == b.frac_proj1 && a.frac_proj2 + b.frac_proj2 > 0.0 && a.frac_proj2 + b.frac_proj2 <= 1.0 ? 
//                 frac_chunk(a.frac_proj1, a.frac_proj2 + b.frac_proj2) :
//                 frac_top()) :

//             ((a == frac_pers(a.frac_pers_proj1) && b == frac_pers(b.frac_pers_proj1)) ?
//                 (a.frac_pers_proj1 == b.frac_pers_proj1 ? a : frac_top()) :
                
//             ((a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_pers(b.frac_pers_proj1)) ?
//                    (a.frac_proj1 == b.frac_pers_proj1 && a.frac_proj2 < 1.0 ? 
//                     b : frac_top()) :

//             ((a == frac_pers(a.frac_pers_proj1) && b == frac_chunk(b.frac_proj1, b.frac_proj2)) ?
//                 (a.frac_pers_proj1 == b.frac_proj1 && b.frac_proj2 < 1.0 ? 
//                     a : frac_top()) :
//                 frac_top()
//             )
//             )
                
//             )
            
//             ) : 
            
//         frac_top()) 
            
//         )
        
//     }

//     func frame(a:T, b:T) returns (ret:T) {
//         b == frac_null() ? a :

//         (valid(a) && valid(b) ?
//         ((a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_chunk(b.frac_proj1, b.frac_proj2)) ?
//                 (a.frac_proj1 == b.frac_proj1 ?
//                     (a.frac_proj2 == b.frac_proj2 ? frac_null() : frac_chunk(a.frac_proj1, a.frac_proj2 - b.frac_proj2)) : 
//                     frac_top()
//                 ) :

//             (a == frac_pers(a.frac_pers_proj1) && b == frac_pers(b.frac_pers_proj1) ?
//                 (a.frac_pers_proj1 == b.frac_pers_proj1 ? a : frac_top()) :
                
//             (a == frac_chunk(a.frac_proj1, a.frac_proj2) && b == frac_pers(b.frac_pers_proj1) ?
//                    (a.frac_proj1 == b.frac_pers_proj1 && a.frac_proj2 < 1.0 ? 
//                     b : frac_top()) :

//             (a == frac_pers(a.frac_pers_proj1) && b == frac_chunk(b.frac_proj1, b.frac_proj2) ?
//                 (a.frac_pers_proj1 == b.frac_proj1 && b.frac_proj2 < 1.0 ? 
//                     a : frac_top()) :
//                 frac_top()
//             )
//             )
                
//             )
            
//             ): frac_top())
//     }

//     func fpuAllowed(a:T, b:T) returns (ret:Bool) 
//         // ensures forall c:T :: valid(a) && valid(b) && valid(comp(a,c)) ==> valid(comp(b,c))    
//     {
//         a == b ? true : 
//         (a == frac_chunk(a.frac_proj1, a.frac_proj2) ?
//             a.frac_proj2 == 1.0 && valid(b) :
//         (a == frac_top() ? true : false))
//     }

//     auto lemma idValid()
//         ensures valid(id)
//     {}

//     auto lemma compAssoc()
//         ensures forall a:T, b:T, c:T :: { comp(comp(a, b), c) } {comp(a, comp(b, c))} (comp(comp(a, b), c) == comp(a, comp(b, c)))
//     {}

//     auto lemma compCommute()
//         ensures forall a:T, b:T :: {comp(a,b)} {comp(b,a)} comp(a, b) == comp(b, a)
//     {}

//     auto lemma compId()
//         ensures forall a:T :: {comp(a, id)} comp(a, id) == a
//     {}
 
//     auto lemma compValid()
//         ensures forall a:T, b:T :: {comp(a,b)} {valid(a), valid(b)} valid(comp(a, b)) ==> valid(a) && valid(b)
//     {}

//     auto lemma frameId()
//         ensures forall a:T :: {frame(a,id)} frame(a, id) == a
//     {}
    
//     auto lemma compFrameInv()
//         ensures forall a:T, b:T :: {frame(a,b)} valid(frame(a, b)) ==> comp(frame(a, b), b) == a
//     {}
    
//     auto lemma fpuValid()
//         ensures forall a:T, b:T, c:T :: {fpuAllowed(a,b), comp(a,c)} {fpuAllowed(a,b), comp(b,c)} ((fpuAllowed(a,b) && valid(a) && 
//             // valid(b) && 
//         valid(comp(a,c))) ==> valid(comp(b,c)))
//     {}
    
//     auto lemma fpuReflexive()
//         ensures forall a:T :: {valid(a)} valid(a) ==> fpuAllowed(a,a)
//     {}
    
//     auto lemma frameValid()
//         ensures forall a:T, b:T :: {frame(a,b)} {valid(a), valid(b)} valid(frame(a,b)) ==> valid(a) && valid(b)
//     {}
    
//     auto lemma weak_frameCompInv()
//         ensures forall a:T, b:T:: {comp(a,b)} valid(comp(a, b)) ==> valid(frame(comp(a, b), b))
//     {}
// }
