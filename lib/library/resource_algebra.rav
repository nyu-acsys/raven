interface ResourceAlgebra {
    rep type T

    val id: T
    func comp(a:T, b:T) returns (ret:T)
    func frame(a:T, b:T) returns (ret:T)

    func valid(a:T) returns (ret: Bool)

    func fpu(a:T, b:T) returns (ret: Bool)

    /* alias : a âˆ˜ b = comp(a,b) ? */

    lemma idValid()
        ensures valid(id)

    lemma compAssoc()
        ensures forall a:T, b:T, c:T :: (comp(comp(a, b), c) == comp(a, comp(b, c)))

    lemma compCommute()
        ensures forall a:T, b:T :: comp(a, b) == comp(b, a)
		
    // lemma fpu_app(l:T, a:T, b:T)
    //     requires own(l, a)
    //     requires fpu(a,b)
    //     ensures own(l, b)
    //     /* Should this be a lemma or something else? */

    lemma fpu_valid(a:T, b:T)
        requires fpu(a,b) && valid(a) && valid(b)
        ensures (forall c:T :: (valid(comp(a, c)) ==> valid(comp(b, c))))
}

module Nat : resource_algebra {
    rep type T = Int

    val id: T = 0

    func comp(a:T, b:T) returns (ret:T) { a+b }
    func valid(n:T) returns (ret:Bool) { n >= 0 ? true : false }


    lemma idValid()
        ensures valid(id)
    {}

    lemma compAssoc(a:T, b:T, c:T)
        ensures comp(comp(a, b), c) == comp(a, comp(b, c))
    {}
}

/*
module Frac : resource_algebra {
    rep type t = Frac

    val id = 0
    func comp(a: Frac, b: Frac) returns { ret := a + b }
}

*/

module Auth [M: ResourceAlgebra] : ResourceAlgebra {
    rep type T = data { 
        case frac(m:M); 
        case auth_frac(n1:M, n2:M);
        case top
    }
    
    val id = frac(M.id);

    func comp(a:T, b:T)
        returns (ret:T)
    {
        /* Probably best to just implement case-matching. */
        /* But with case-matching the following code will look much worse. */

        (a == frac(a.m) && b == frac(b.m)) ?
            (frac(M.comp(a.m,b.m))) :
        ((a == frac(a.m) && b == auth_frac(b.n1, b.n2)) ?
            auth_frac(b.n1, M.comp(a.m, b.n2)) :
        (a == auth_frac(a.n1, a.n2) && b == frac(b.m)) ? 
            auth_frac(a.n1, M.comp(b.m, a.n2)) :
            top)
    }

    func valid(n:T) {
        !(n == top)
    }

    lemma idValid()
        ensures valid(id)
    { }

    lemma compAssoc()
        ensures forall a:T, b:T, c:T :: (comp(comp(a, b), c) == comp(a, comp(b, c)))
    { }

    lemma compCommute(a:T, b:T)
        ensures forall a:T, b:T :: comp(a, b) == comp(b, a)
    { }
		
    lemma fpu_(l:T, a:T, b:T)
        requires own(l, a)
        requires valid(a) && valid(b)
        requires (forall c:T :: (valid(comp(a, c)) ==> valid(comp(b, c))))
        ensures own(l, b)
    {

    }
    
    lemma own_sep(l:Ref, f:T, a:T, b:T)
        requires own(l.f, comp(a, b))
        ensures own(l.f, a) && own(l.f, b)
    {
        
    }

}

interface LatticeResourceAlgebra : ResourceAlgebra {

}

interface CancellativeResourceAlgebra : Resource_algebra {
    lemma cancellative()
        ensures (forall a:T, b:T, c:T :: (valid(comp(a, b) && comp(a,b) == comp(c,b))) ==> (a == c))

    
}
