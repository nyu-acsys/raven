/lib/frontend/resolve_namespaces.ml

Entry-point: 
`start_disambiguate : Module.t -> SymbolTbl.t -> Module.t * SymbolTbl.t`

## Purpose

Implements the following functionality:
- takes as input an AST of the source code generated by the parser. The source code is stored in a global module called `$Program`.
- Renames every variable, callable and module to have globally unique identifiers. This lets us not worry about variable overloading and scoping in the rest of the program.
- Replace every instance of a callable with its fully quantified name.
- Replace every non-local variable with its fully quantified name.
   
  %%[[Raven Questions]] Should this also be done for all local variables as well? Figure out how the distinction is being made in the first place.%%
  
  For example the following source code
```
  module Lock {
	  var x = true;
	  proc create() 
		  returns (x : Bool) 
	  {
		  var x : Bool = false;
	  }

	proc acquire() {
		var x = create();
	}
  }
```

becomes:

```
module $Program
{
  module Lock
  {
    var x = true
    
    proc create()
      returns (x#1: Bool)
     {
       var x#2 : Bool = false
     }
    
    proc acquire()
     {
       var x#3 : Any = $Program.Lock.create()
     }
  }
}
```
#RavenToDos the return variable is being treated like a new variable. Fix it.
#RavenToDos callable return types are not being used by type checker. Fix it.


- In the AST received from the parser, several fields in module declarations and callable declarations are not populated yet.
  
  For modules:
  We go over `module.mod_def` member list to collect the required information and populate the following fields in the module declaration for easier access later.
	- `module.mod_decl.mod_decl_rep`
	- `module.mod_decl.fields`
	- `module.mod_decl.mod_defs`
	- `module.mod_decl.mod_decl_mod_aliases`
	- `module.mod_decl.mod_decl_types`
	- `module.mod_decl.mod_decl_callables`
	- `module.mod_decl.mod_decl_vars`

  For callables:
  For procedures, we go over the body of the procedure to collect and populate the following field.
	- `proc.proc_decl.call_decl_locals`
	[[Raven Questions]] Does this mean for functions the locals field must be empty? 


### Layout

The file is laid out in a similar structure to [[Raven AST]]. There is a data-structure called SymbolTbl which is implemented at the beginning of this file. After that, there are 7 modules which correspond to the 7 language constructs in the AST, namely:
1. IdentDisambiguate
2. QualIdentDisambiguate
3. TypeDisambiguate
4. ExprDisambiguate
5. StmtDisambiguate
6. CallableDisambiguate
7. ModuleDisambiguate

And internally, for almost all types, there is a corresponding disambiguate function. This is to make disambiguation calls as uniform as possible. Typically, since most types are records, a lot of wrapping/unwrapping needs to happen. So a lot of these disambiguate functions simply unwrap the object, call disambiguate function on each member, and wrap up the object again. Where extra information needs to be added or stored, that is done separately.


#### SymbolTbl
The necessary information required for disambiguation is carried in the `tbl` variable that is passed as an argument to every disambiguate function. `tbl` is of type `SymbolTbl`, which is a stack of maps. Each map is a map from qualified identifiers to qualified identifiers. The stack represents the scopes in the source code. Each element in this stack (ie each map) is henceforth referred to as a "frame". A frame in the stack can have an optional Ident as a "label". For instance the frame corresponding to the module "Lock" will store the label "Lock". These labels are used to generate fully quantified names for idents. Many frames don't have labels for example if-else blocks, or procedures, since their local variables cannot be accessed from outside.

Each frame represents the specific mapping for the variables in that scope. Each variable is mapped to a fully quantified name (except for variables in "unlabelled" frames). Note that when a variable is added to a frame, it is also added to added to all its parent frames (while pre-pending the "labels" to the idents). For instance if the symbolTbl is as follows:
```
Lock :: [
  ]
$Program :: [ 
  ]
__ :: [ 
  ]
```

and we add the mapping `acquire -> acquire#1` to the top frame, we get:

```
Lock :: [ acquire -> $Program.Lock.acquire#1
  ]
$Program :: [ Lock.acquire -> $Program.Lock.acquire#1
  ]
__ :: [ $Program.Lock.acquire -> $Program.Lock.acquire#1
  ]
```

Note that the identifier `acquire#1` is first resolved to its fully quantified version (`$Program.Lock.acquire#1`), and then it is added to the Lock frame, and each subsequent frame by pre-pending the label of its frame. So, in the $Program frame, `acquire` becomes `Lock.acquire` since in the $Program scope, the variable `acquire` can be referenced to as `Lock.acquire`, etc.


##### IdentDisambiguate
For idents, we make a distinction between *old_ident*'s which are looked up in the `SymbolTbl` and re-written to their mapped values, and new_idents for which a fresh ident is generated and the mapping is added to the `SymbolTbl`

##### QualIdentDisambiguate
This simply looks up the qualIdent in the `tbl` and replaces the original qual_ident with the new one. It raises a failure if the qualIdent is not found.

##### TypeDisambiguate
Makes sure all idents in types are unique. Does some unwrapping and disambiguating member objects. Leaves all basic type constructors alone.

%% #RavenToDos: have distinct var_decl_disambiguate for old vs new? I believe the same var_decl_disambiguate may be used for the same variable at multiple places.
[[Raven Questions]]
%%

##### ExprDisambiguate
ExprDisambiguate also essentially calls the disambiguate functions on each member object.

##### StmtDisambiguate
StmtDisambiguate also calls disambiguate functions on each member object. However, it does a few things differently.

- stmt disambiguate also collects a list of local variables used in a sequence of statements. This is used to populate the `proc.proc_decl.call_decl_locals` field for procedures.

- It goes over all statements and replaces calls to `openAU()`, `commitAU()`, `bindAU()` and `abortAU()` functions into special AST constructs to store these commands which manipulate atomic update tokens. In doing so, it also ensures that these commands are being called with the correct number of arguments of the right types and so on.

##### CallableDisambiguate
CallableDisambiguate collects the local variables and calls the disambiguate functions on all other member objects.

##### ModuleDisambiguate
ModuleDisambiguate first goes over every member definition in a module and disambiguates them. Then it calls `extract_members` on the list of member definitions to extract the different member objects like types, callables etc, and stores them in the mod_decl.


#RavenToDos Disambiguation is generating spurious frames in the symbolTbl. Figure out what's happening.