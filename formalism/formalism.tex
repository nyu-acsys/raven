\documentclass{article}

\usepackage[margin=0.5in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{enumitem} 

\usepackage{listings}

%\lstset{
%	basicstyle=,
%	columns=flexible
%	xleftmargin=3em,
%	literate={->}{$::=$}{2}
%	{α}{$\alpha$}{1}
%	{δ}{$\delta$}{1}
%}
\usepackage{syntax}


\setlist[itemize]{noitemsep,nolistsep} %makes lists compact

\begin{document}
	\title{Formal specification for RAVEN}
	\date{}
	
	\maketitle

	\section{Type System}
	We have the following built-in types:
	\begin{enumerate}
		\item Ref
		\item Bool
		\item Int
		\item Set[T] for a type T.
		\item List[T] for a type T.
		\item Multiset[T] for a type T.
	\end{enumerate}

	\noindent New types can be defined as follows:
	\begin{enumerate}
		\item Sum types.
		\item Modules.
	\end{enumerate}
	
	
	\section{Grammar}

	\begin{grammar}
	\let\syntleft\relax
	\let\syntright\relax

		
	<\textit{prog}> ::= $\overline{decl}$
	
	<\textit{decl}> ::= \textit{proc\_decl} | \textit{at\_proc\_decl} | \textit{func\_decl} | \textit{intf\_decl} | \textit{module\_decl} | \textit{module\_inst} | \textit{pred\_decl}
	
	<\textit{proc\_decl}> ::=  proc \textit{proc}($\overline{x : T}$) \\
		requires \textit{a} \\
		ensures \textit{a} \\
		\{\textit{stmt}\}
		
	<\textit{at\_proc\_decl}> ::= atomic proc \textit{proc}($\overline{x : T}$) \\
	requires \textit{a} \\
	ensures \textit{a} \\
	\{\textit{stmt}\}
	
	<\textit{func\_decl}> ::= function \textit{func}($\overline{x : T}$) : T\\
	requires \textit{a} \\
	ensures \textit{a} \\
	\{\textit{stmt}\}
	
	<\textit{intf\_decl}> ::= interface \textit{intf}[$\overline{z : I}$] 
	
	<\textit{module\_decl}> ::= module \textit{mod}[$\overline{z : I}$] : $\overline{\textit{intf}}$ \{e\}
	
	<\textit{module\_inst}> ::= module \textit{mod} = \textit{mod}[$\overline{z : I}$]
	
	<\textit{pred\_decl}> ::= predicate \textit{pred}($\overline{x : T}$) \{a\}
	
	<\textit{stmt}> ::= \textit{stmt}; \textit{stmt} | var x:T | x := e | x := new($\overline{f}$) | $\overline{x}$ := proc($\overline{e}$) | x.f := e | assert \textit{a} | if (\textit{e}) \{\textit{stmt}\} else \{\textit{stmt}\} | while (\textit{e}) invariant \textit{a} \{\textit{stmt}\} | import \textit{intf} | inhale/exhale/label/goto/fold/unfold
		
\end{grammar}

\section{Semantics}
Raven uses symbolic execution to do specification-based modular verification. Each method is verified with respect to its given specification, by starting from a symbolic state which represents the precondition and symbolically executing each statement to ensure that the postconditions hold at the final state.

Raven uses an SMT solver as the back end to discharge proof obligations. Like Smallfoot and Viper, Raven splits the symbolic state into \textit{path conditions} which store pure assertions expressed in first order logic, and a \textit{symbolic heap} which assigns symbolic values to locations.

The symbolic state consists of:
\begin{itemize}
	\item A \textit{store} $\gamma$ which maps local variables to their symbolic values.
	\item A \textit{path condition stack} $\pi$ that stores triples $(\textit{Id}, \textit{V}, \textit{Set}[V])$ of a unique scope identifier, a branch condition, and a set of path conditions.
	\item A symbolic heap $h$, which is a multiset of heap chunks of the shape $id(\overline{v};\overline{w})$. For instance for a field $f$, $f(r;v,p)$ denotes that $r.f$ has the symbolic value $v$ and permission $p$.
	\item A \textit{ghost symbolic heap} $g$, which stores the values of the ghost locations.
	\item A \textit{labelled heaps} map $lbh$ that maps identifiers to symbolic heaps.
\end{itemize}


\iffalse
- Grammar needs to be styled properly, specially wrt multi line declarations for procs/funcs/etc.
- How to represent optional parameters, for example the arguments for interfaces and modules.
- monospace font for the keywords
\fi


\end{document} 
