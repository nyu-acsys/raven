Raven:
------

stmt := var x: T | x := e | x := new (f...) | x.f := e | stmt; stmt
				inhale a | exhale a | assert a |
				{ stmt } □ { stmt } // non-deterministic choice.
				
a := bex | e.f ↦[p] e | a ∗ a | a ∧ a | a ∨ a | ∃ x': e.f ↦[p] x'

# TODO: What to do about: | a → a 

e := x | null | n (base_values)

bex := e = e | bool_op(e...)

==> Concrete execution
----------------------

Program state ρ (∈ Σ) either:
- ERROR
- (H, γ), where:
		1) H: Obj_id x Field_id → Val x Perm
		2) γ: Var → Val

==> Operational rules for concrete execution (relation CE ⊆ Σₛ x Prog x Σₛ)
-------------------------------------------

Execution of statements :

We define the semantics in a continuous passing style as a relation between tuples of program state and continuation (σ, κ) where:
	
	κ is continuation: either DONE or EXEC(stmt, κ) 

1) (H, γ, EXEC(var x: T, κ)) → (H, γ[x ↦ _], κ)


2)				   			H, γ, e ↑ c               
	 ------------------------------------------------------------------
	 (H, γ, EXEC(x := e, κ)) → (H, γ[x ↦ c], κ) 


3)							i ∉ first_proj(dom(H))
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x := new(f...), κ)) → (H[(i,f) ↦ (_, 1), ...] , γ[x ↦ i], κ) 


4)			(γ(x), f) ∈ dom(H)     H(γ(x), f) = (_, 1)      H, γ, e ↑ c   
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x.f := e, κ)) → (H[(γ(x),f) ↦ (c,1)], γ, κ) 


5)				(γ(x), f) ∉ dom(H) 		∨ 		H(γ(x), f) ≠ (_, 1)
	 ------------------------------------------------------------------						
	 						(H, γ, EXEC(x.f := e, κ)) → ERROR 


6a)			(H, γ, EXEC({stmt1}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 (H, γ, EXEC({ stmt1 } □ { stmt2 }, κ)) → (H', γ', κ) 


6b)			(H, γ, EXEC({stmt2}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 (H, γ, EXEC({ stmt1 } □ { stmt2 }, κ)) → (H', γ', κ)

7) 				H_1, γ ⊨ a 		∧		H' = H ∘ H_1
	-------------------------------------------------------------------
				(H, γ, EXEC(inhale a, κ)) → (H', γ, κ)

8)								H, γ ⊨ a
	-------------------------------------------------------------------
		(H, γ, EXEC(assert a, κ)) → (H, γ, κ)

9)								H, γ ⊭ a
	-------------------------------------------------------------------
		(H, γ, EXEC(assert a, κ)) → ERROR

10)		H_1, γ ⊨ a	∧	∀ H" ⊂ H_1 : H", γ ⊭ a	∧	H = H' ∘ H_1
	-------------------------------------------------------------------
			(H, γ, EXEC(exhale a, κ)) → (H', γ, κ)


Evaluation of expressions:

1) 				γ(x) = c
			---------------
				H, γ, x ↑ c

2) H, γ, null ↑ null         H, γ, n ↑ n

3) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 = c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ true

4) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 ≠ c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ false
		   
5) 		H, γ, e ↑ c  ...   bool_op(c,...) = b
			--------------------------------------
		          H, γ, bool_op(e...) ↑ b


Interpretation of assertions over concrete states (⊨)

(H, γ) ⊨ e1 = e2				iff [e1]γ = [e2]γ.
(H, γ) ⊨ bool_op(e...)			iff bool_op([e]γ...) holds.
(H, γ) ⊨ e1.f ↦[p] e2			iff p ≤ H([e1]γ, f).2 and H([e1]γ, f).1 = [e2]γ.  
(H, γ) ⊨ a0 ∗ a1				iff exists H0, H1. H = H0 ∗ H1 and (H0, γ, κ) ⊨ a0 and (H1, γ, κ) ⊨ a1.
(H, γ) ⊨ a0 ∧ a1				iff (H, γ, κ) ⊨ a0 and (H, γ, κ) ⊨ a1.
(H, γ) ⊨ a0 ∨ a1				iff (H, γ, κ) ⊨ a0 or (H, γ, κ) ⊨ a1.
(H, γ) ⊨ a0 → a1				iff forall H', H' ⊥ H and (H' ∗ H, γ, κ) ⊨ a0 implies (H' ∗ H, γ, κ) ⊨ a1.
(H, γ) ⊨ ∃x': e.f ↦[p] x'		iff there exists c such that (H, γ[x ↦ c], κ) ⊨ a.  

//TODO: Have to find a way to make the existential stick with the rest of the assertion.

Validity of Hoare triples:

(H, γ) ⊨ { P } C { Q } iff (H, γ) ⊨ P and CE((H, γ), C, (H', γ')) 
											implies (H', γ') ⊨ Q.

⊨ { P } C { Q } iff ∀ H, γ. (H, γ) ⊨ { P } C { Q }



Symbolic Execution

Symbolic state σₛ of the form (h, π, γ) where:
	1) h: multiset of heap chunks - f(r,v,p); f - field, r - symbolic objects, v - symbolic value, p - symbolic permission value 
	2) π: path condition stack - collection of formulas from many-sorted first-order logic.
	3) γ: Var → SymbVal

	
Interpretation of assertions over symbolic states (⊢)

(h, γ, π) ⊢ e1 = e2					iff π ⊢ [e1]γ = [e2]γ.
(h, γ, π) ⊢ bool_op(e...)			iff π ⊢ bool_op([e]γ...) holds.
(h, γ, π) ⊢ e1.f ↦[p] e2			iff p ≤ + { p' | f(r, v, p') ∈ h ∧ [r]γ = [e1]γ ∧ v = [e2]γ } 
(h, γ, π) ⊢ a0 ∗ a1					iff exists h0, h1. h = h0 ∗ h1 (disjoint union) and 
													(h0, γ, π) ⊢ a0 and (h1, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∧ a1					iff (h, γ, π) ⊢ a0 and (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∨ a1					iff (h, γ, π) ⊢ a0 or (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 → a1					iff forall h', h' ⊥ h and (h' ∗ h, γ, π) ⊢ a0 implies (h' ∗ h, γ, π) ⊢ a1.
(h, γ, π) ⊢ ∃x': e.f ↦[p] x'		iff there exists c s.t. (h' ∗ h, γ[x ↦ c], π) ⊢ a.  


Symbolic execution, denoted by relation SE ⊆ Σₛ x Prog x Σₛ     

Execution of statements :

1) (h, γ, π, EXEC(var x: T, κ)) → (h, γ[x ↦ v_x], κ) where v_x is a fresh SVar.

2)				v_x': fresh SVar		∧		h, γ, π, e ↑ c
	 ------------------------------------------------------------------  	[Assign new SVar to x]
	 (h, γ, π, EXEC(x := e, κ)) → (h, γ[x → v_x'], π ++ (v_x' = c) κ) 


3)						         r_x fresh SVar   
	------------------------------------------------------------------						
	 (h, γ, π, EXEC(x := new(f...), κ)) → (h ++ f(r_x, _, 1) ...] , γ[x ↦ r_x], κ) 

4)	 γ(x) = r_x		∧	v_x' fresh SVar	∧	f(r_x, v, 1) ∈ h	∧	h, γ, π, e ↑ c   
	-----------------------------------------------------------		[Update chunk with fresh SVar]
		(h, γ, π, EXEC(x.f := e, κ)) → (h \ f(r_x,v,1) ++ f(r_x,v_x',1), γ, π ++ (v_x' = c), κ) 

5)		γ(x) = r_x     ∧     f(r_x, v, p) ∈ h; p < 1
	 ------------------------------------------------------------------
	 					(h, γ, π, EXEC(x.f := e, κ)) → ERROR 

6a)				(h, γ, π, EXEC({stmt1}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 		(h, γ, π, EXEC({ stmt1 } □ { stmt2 }, κ)) → (h, γ, π, κ) 

6b)				(h, γ, π, EXEC({stmt2}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 		(h, γ, π, EXEC({ stmt1 } □ { stmt2 }, κ)) → (h, γ, π, κ) 

7a)   		a == e1.f ↦[p] e2	∧	(h, γ, π) ⊢ e1 = r_x 	∧	(h, γ, π) ⊢ e2 = c
	 ------------------------------------------------------------------		[v_x fresh SVar]
	 		(h, γ, π, EXEC(inhale a, k)) → (h ++ f(r_x, v_x, p), γ ++ (v_x = c), π, k)

//TODO: Here what if no such r_x exists in the the heap? Is that even allowed?

7b)			a == a1 * a2 	∨	a == a1 ∧ a2
	-------------------------------------------------------------------
			(h, γ, π, EXEC(inhale a, κ)) → (h, γ, π, EXEC(inhale a1, EXEC(inhale a2, k)))

//TODO: Handling separation star completely wrong. 

7c)			a == a1 ∨ a2			∨			a == a2 ∨ a1
	-------------------------------------------------------------------
			(h, γ, π, EXEC(inhale a1 ∨ a2)) → (h, γ, π, EXEC(inhale a1))

7d) 		a == bool_op(e1, e2, ...)
	--------------------------------------------------------------------
		(h, γ, π, EXEC(inhale a, κ)) → (h, γ, π ++ bool_op(e1', e2', ...), k)
		where e1' = e1[x \ γ(x) ] etc

7e)			a == ∃x' : e.f ↦[p] x'	∧	(h, γ, π) ⊢ e = r_z
	---------------------------------------------------------------------	[v_z fresh SVar]
		(h, γ, π, EXEC(inhale a, κ)) → (h ++ f(r_z, v_z, p), γ, π ++ (v_z = x), κ)

8a)   		a == e1.f ↦[p] e2	∧	(h, γ, π) ⊢ e1 = r_x	∧	f(r_x, v_x, p') ∈ h, p' >= p	∧	(h, γ, π) ⊢ v_x = e2
	 ------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, k)) → (h \ f(r_x, v_x, p') ++ f(r_x, v_x, p'-p), γ, π, k)

8b)			a == a1 * a2 	∨	a == a1 ∧ a2
	-------------------------------------------------------------------
			(h, γ, π, EXEC(exhale a, κ)) → (h, γ, π, EXEC(exhale a1, EXEC(exhale a2, k)))

8c)			a == a1 ∨ a2			∨			a == a2 ∨ a1
	-------------------------------------------------------------------
			(h, γ, π, EXEC(exhale a1 ∨ a2)) → (h, γ, π, EXEC(exhale a1))

8d) 		a == bool_op(e1, e2, ...)	∧	h, γ, π ⊢ a
	--------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, κ)) → (h, γ, π, k)
		[Should we have an error state for the alternative?]

	//TODO: Are we sure we don't want to add 'a' to the path conditions here?

8e)			a == ∃x' : e.f ↦[p] x'	∧	(h, γ, π) ⊢ e = r_z	∧	f(r_z, v_z, p') ∈ h, p' >= p
	---------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, κ)) → (h \ f(r_z, v_z, p') ++ f(r_z, v_z, p'-p), γ, π ++ (v_z = x), κ); x fresh SVar

9)			(h, γ, π, EXEC(exhale a, DONE)) → (h', γ', π', DONE)
	--------------------------------------------------------------------
			(h, γ, π, EXEC(assert a, k)) → (h, γ, π', k)	


Validity of Hoare triples:

(h, γ, π) ⊢ { P } C { Q } iff (h, γ, π) ⊢ P and 
								SE((h, γ, π), C, (h', γ', π')) implies (h', γ', π') ⊢ Q.

⊢ { P } C { Q } iff ∀ h, γ, π. (h, γ, π) ⊢ { P } C { Q }


State Consolidation:

Between every step, we run a state consolidation step, described as follows:

Given a state (h, γ, π),
For every pair of heap chunks f(r1,v1,p1) and f(r2,v2,p2) ∈ h, non deterministically either:
1. (h, γ, π) → (h, γ, π ++ (r1 ≠ r2)); or
2. (h, γ, π) → (h ++ f(r1,v1,p1+p2)) \ (f(r1,v1,p1), f(r2,v2,p2)), γ[r2 / r1], π ++ (r1 == r2, v1 == v2, p1 + p2 ≤ 1))

Suppose after state consolidation gets completed, we get (h, γ, π) → (h', γ', π'). If (h', γ', π') ⊢ UNSAT, then discard.



Completeness

To prove: ⊨ { P } C { Q }	→	⊢ { P } C { Q }


Outline:

For a symbolic state σ, we call it consolidated if ∃ σ' such that σ' -SC→ σ.

We define a function on consolidated states which returns a set of concrete states as follows:

Concrete(σ) = { ρ | ρ.H has a heap chunk for every fragment in σ.h, with the variables and heap locations designated a satisfying assisgnment returned by the SMT solver.}

⊨ {P} C {Q}		→	⊢ {P} C {Q}
∀ ρ, ρ' : ρ ⊨ P ∧ CE(ρ, C, ρ') → ρ' ⊨ Q		→	∀ σ, σ' : σ ⊢ P ∧ SE(σ, C, σ') → σ' ⊢ Q

We are given: 

	1. ∀ ρ, ρ' : ρ ⊨ P ∧ CE(ρ, C, ρ') → ρ' ⊨ Q.		(⊨ {P} C {Q})
	2. σ, σ'.
	3. σ ⊢ P
	4. SE(σ, C, σ')


To Prove: 		σ' ⊢ Q


SE(σ, C, σ') :

σ = σ₀ -SC→ σ₀' -SE(c₁)→ σ₁ -SC→ σ₁' -SE(c₂)→ σ₂ -SC→ σ₂' → ... → σₙ -SC→ σₙ' = σ'
			^					 ^					  ^	  			  	  ^ 
			|					 |					  |		  			  |
			|					 |					  |		  			  |
		Conc(σ₀')			 Conc(σ₁')			  Conc(σ₂')			  Conc(σₙ')


Lemma 0: For a consolidated state σ, assertion P, and concrete state ρ such that ρ ∈ Concrete(σ), σ ⊢ P	→	ρ ⊨ P.
(proof by induction on P?)
--------------------------------

Lemma 1: For a consolidated state σ and an assertion P, if for all ρ ∈ Concrete(σ) ρ ⊨ P holds, then σ ⊢ P.
(This is sort of the core of the proof. Not sure how to prove this, I suspect will have to reduce to classical first order logic or something. Or maybe simply inducting on P works??)
--------------------------------

Lemma 2: If σ -SC→ σ', then:
σ ⊢ P	→	σ' ⊢ P.
(proof by induction on P)
--------------------------------

Lemma 3: If σ₀ is a consolidated state, and σ₀ -SE(s)→ σ' -SC→ σ₁, then for any concrete state ρ₁ ∈ Concrete(σ₁), there exists a concrete state ρ₀ ∈ Concrete(σ₀) such that ρ₀ -CE(s)→ ρ₁.
(proof by induction on s)
--------------------------------


Since σ₀ ⊢ P, by Lemma 2 we have that σ₀' ⊢ P. 
Therefore we have by Lemma 0 that for any ρ₀ ∈ Conc(σ₀'), we have that ρ₀ ⊨ P.
Now for any arbitrary ρₙ ∈ Conc(σₙ'), we can use Lemma 3 inductively to construct a run:
	ρ₀ -CE(c₁)→ ρ₁ -CE(c₂)→ ρ₂ → ... → CE(cₙ)→ ρₙ such that each ρᵢ ∈ Conc(σᵢ').

Therefore we can use assertion 1 (⊨ {P} C {Q}) to conclude that ρₙ ⊨ Q.
Since for all ρₙ ∈ Conc(σₙ'), ρₙ ⊨ Q holds, therefor by Lemma 1, σ' ⊢ Q holds.

Hence Proved.



----------------------------------------------

Proof of Lemma 1: For a consolidated state σ and an assertion P, if for all ρ ∈ Concrete(σ) ρ ⊨ P holds, then σ ⊢ P.

	a := bex | e.f ↦[p] e | a ∗ a | a ∧ a | a ∨ a | ∃ x': e.f ↦[p] x'
	bex := e = e | bool_op(e...)

Induction on assertion P.

1. P = bex
Suppose π ¬⊢ [P]γ. By completeness of first order logic, there is a valuation for symbolic variables which don't satisfy [P]γ. This valuation for symbolic variables can be used to construct a concrete valuation ρ ∈ Concrete(π) such that ρ ¬⊨ P. Contradiction.

2. P = e1.f ↦[p] e2
Let [e1]γ = r and let f(r,v,p') be the corresponding heap chunk in σ. If p' < p then no ρ ∈ Concrete(σ) can satisfy ρ ⊨ P either. Therefore we can assume that p' >= p. If π ¬⊢ [e2]γ = v, then by completeness of first order logic there exists a valuation for symbolic variables which don't satisfy P. This can be used to construct a concrete valuation ρ ∈ Concrete(π) such that ρ ¬⊨ P. Contradiction.


3. P = a1 ∗ a2
Pick a ρ ∈ Concrete(σ). Since ρ ⊨ a1 ∗ a2, there exists two sub-heaps H1, H2 such that ρ.H = H1 ∗ H2, and (H1, ρ.γ) ⊨ a1 and (H2, ρ.γ) ⊨ a2. Consider the corresponding sub-heaps h1 and h2 of σ.h such that σ.h = h1 ∗ h2.

	Claim: Consider σ1 = (h1, σ.γ, σ.π). Then for all ρ1 ∈ Concrete(σ1), ρ1 ⊨ a1.

	Pf: Suppose ρ1 ¬⊨ a1. The symbolic variable valuation can be extended to the entire heap to get a concrete state ρ' ∈ Concrete(σ). Since ρ' ⊨ a1 * a2, there exists some sub-heaps H1' and H2' which satisfy the properties for ∗. Then we claim that H1, H2 satisfy this, which can be seen as follows:

	If a1,a2 are pure, then the heap doesn't matter so H1,H2 should still satisfy. If they are not pure then since (H1, ρ.γ) ⊨ a1 and (H2, ρ.γ) ⊨ a2, therefore (H1, ρ'.γ) ⊨ a1 and (H2, ρ'.γ) ⊨ a2.

Now, we can use induction on the smaller assertion a1 to conclude that (h1, σ.γ, σ.π) ⊢ a1. Similarly, (h2, σ.γ, σ.π) ⊢ a2. Therefore σ ⊢ a1 ∗ a2.


4. P = a1 ∧ a2
If σ ¬⊢ a1 ∧ a2, then either σ ¬⊢ a1 or σ ¬⊢ a2. In either case, we have that for all ρ ∈ Concrete(σ), ρ ⊨ a1 and ρ ⊨ a2. By induction we can assume that the Lemma holds for a1 and a2. Hence contraction.


5. P = a1 ∨ a2
Suppose σ ¬⊢ a1 ∨ a2. We have that for all ρ ∈ Conc(σ), ρ ⊨ a1 ∨ a2.
Case 1: for all ρ ∈ Conc(σ), ρ ⊨ a1.
In this case, we can use the inductive hypothesis on a1 to conclude that σ ⊢ a1, hence σ ⊢ a1 ∨ a2.

Case 2: for all ρ ∈ Conc(σ), ρ ⊨ a2.
In this case, we can use the inductive hypothesis on a2 to conclude that σ ⊢ a2, hence σ ⊢ a1 ∨ a2.

Case 3: some ρ ∈ Conc(σ) satisfy ρ ⊨ a1, ρ ¬⊨ a2 and some ρ ∈ Conc(σ) satisfy ρ ¬⊨ a1, ρ ⊨ a2.


6. P = ∃ x': e.f ↦[p] x'
Since this is simply binding, this case is trivial.



----------------------------------------------

Proof of Lemma 3: If σ₀ is a consolidated state, and σ₀ -SE(s)→ σ' -SC→ σ₁, then for any concrete state ρ₁ ∈ Concrete(σ₁), there exists a concrete state ρ₀ ∈ Concrete(σ₀) such that ρ₀ -CE(s)→ ρ₁.

	stmt := var x: T | x := e | x := new (f...) | x.f := e | stmt; stmt
				inhale a | exhale a | assert a |
				{ stmt } □ { stmt } // non-deterministic choice.
				
	a := bex | e.f ↦[p] e | a ∗ a | a ∧ a | a ∨ a | ∃ x': e.f ↦[p] x'

	e := x | null | n (base_values)

	bex := e = e | bool_op(e...)

Induction on stmt s.

1. var x: T


2. x := e


3. x := new (f...)


4. x.f := e


5. stmt; stmt


6. inhale a


7. exhale a


8. assert a


9. { stmt } □ { stmt } // non-deterministic choice.
























--------------------------------------------------------
Scratch:
-------------------------------------------------------

Outline:
	
First we define a relation ■ ∈ ( concrete states x symbolic states ) as follows:
ρ ■ σ if		∀ P: σ ⊢ P → ρ ⊨ P ∧ |σ.h| = |ρ.H|


We define another relation ▷ ∈ ( concrete states x symbolic states ) as follows:
ρ ▷ σ if		∀ P: σ ⊢ P → ρ ⊨ P.



We use σ -SC→ σ' to denote that σ' is a state that can be obtained by doing state-consolidation on σ.

Lemma 1: For a symbolic state σ, if σ -SC→ σ', then there exists a concrete state ρ such that ρ ■ σ'. Moreover, ρ ▷ σ.
// Lemma 1 is essentially some kind of a statement of completeness for the state-consolidation algo.


Lemma 1.1: If σ -SC→ σ', then for any assertion P, σ ⊢ P → σ' ⊢ P. (by induction on P)


Lemma 2: If σ₀ -SC→ σ₁ -SE(s)→ σ₂ -SC→ σ₃, and ρ ■ σ₃ then there exists a concrete state ρ' such that ρ' ■ σ₁ and ρ -CE(s)→ ρ₃.


Proof of Lemma 1:
Let σₛ = (h, γ, π), σₛ' = (h', γ', π'). Since (h', γ', π') ¬⊢ UNSAT, therefore the SMT solver must be able to return a valuation that satisfies the path conditions in π'. Define the concrete state by instantiating a pointer for every heap chunk in h' (all heap chunks in h' are already consolidated), and assigning the satisfying assignment from the SAT solver. Call it H. Same for γ', replace all symbolic variables with their satisfying assignment values.

Therefore (H, γ) ■ σₛ'. (to be proved by induction on structure of assertions).

We can prove another 

This will directly imply that (H, γ) ▷ σₛ.


Proof of Lemma 2:
Induction on s.

-----------------------------------------------------

Explanation:

⊢ { 1 ≤ x ≤ 10 } empty {x = 5}

⊨ {P} C {Q}		→	⊢ {P} C {Q}
∀ ρ, ρ' : ρ ⊨ P ∧ CE(ρ, C, ρ') → ρ' ⊨ Q		→	∀ σ, σ' : σ ⊢ P ∧ SE(σ, C, σ') → σ' ⊢ Q

We are given: 

1. ∀ ρ, ρ' : σ ⊨ P ∧ CE(ρ, C, ρ') → ρ' ⊨ Q.		(⊨ {P} C {Q})
2. σ, σ'.
3. σ ⊢ P
4. SE(σ, C, σ')


To Prove: 		σ' ⊢ Q


SE(σ, C, σ') :

σ -SC→ σ' -C_1→ σ₁ -SC→ σ₁' -C_2→ σ₂ -SC→ σ₂' → ... → σₙ -SC→ σₙ' = σ'
															  ^ 
															  |
															  |
															  ρₙ

Use lemma 1 to get such a concrete state ρₙ.
Use Lemma 2 to build backwards to create a concrete run which satisfies all the assumptions of given (1).












h = { acc(x, 0.5) && acc(y, 0.5) }
π = { x == y }

h = { acc(x, 1) } 





-----------------------------------------------------
If ρ' ▷ σ', and for a stmt C, if SE(σ, C, σ'), then there exists a concrete state ρ such that CE(ρ, C, ρ')

Lemma 3: If σ -SC→ σ', and 


Lemma 1: If ρ ■ σ, then there exists some symbolic state σ' such that σ -SC→ σ' such that ρ ■ σ'.

Lemma 2: For a symbolic state σ, if there exists some symbolic state σ' such that σ -SC→ σ', then there exists some concrete state ρ' such that ρ' ■ σ' and ρ' ■ σ.

Lemma 3: If ρ ■ σ, then for any stmt C, if SE(σ, C, σ'), then there exists a concrete state ρ' such that CE(ρ, C, ρ').
-----------------------------------------------------



-------------
1 ≤ x ≤ 10 emptystmt x=1

0. {x=1} ⊨ 1 ≤ x ≤ 10
1. CE({x=1}, empytstmt, {x=1})
2. σ, σ'
3. σ ⊢ 1 ≤ x ≤ 10
4. SE(σ, emptystmt, σ')
5. {x=1} ⊨ x=1

To prove: σ' ⊢ x=1
