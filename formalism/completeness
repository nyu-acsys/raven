Raven:
------

stmt := var x: T | x := e | x := new (f...) | x.f := e | stmt; stmt
				inhale a | exhale a | assert a | 
				if (bex) { stmt }  else { stmt }
				
a := bex | e.f ↦[p] e | a ∗ a | a ∧ a | a ∨ a | a → a | ∃x.a

e := x | null | n (base_values)

bex := e = e | bool_op(e...)

==> Concrete execution
----------------------

Program state σ (∈ Σ) either:
- ERROR
- (H, γ, κ), where:
		1) H: Obj_id x Field_id → Val x Perm
		2) γ: Var → Val 
		3) κ is continuation: either DONE or EXEC(stmt, κ) 


==> Operational rules for concrete execution (relation CE ⊆ Σₛ x Prog x Σₛ)
-------------------------------------------

Execution of statements :

1) (H, γ, EXEC(var x: T; stmt, κ)) → (H, γ[x ↦ _], EXEC(stmt, κ))

2)				   									H, γ, e ↑ c               
	 ------------------------------------------------------------------
	 (H, γ, EXEC(x := e; stmt, κ)) → (H, γ[x ↦ c], EXEC(stmt, κ)) 


3)						             i ∉ first_proj(dom(H))
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x := new(f...); stmt, κ)) → (H[(i,f) ↦ (_, 1), ...] , γ[x ↦ i], EXEC(stmt, κ)) 

4)			(γ(x), f) ∈ dom(H)     H(γ(x), f) = (_, 1)      H, γ, e ↑ c   
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x.f := e; stmt, κ)) → (H[(γ(x),f) ↦ (c,1)], γ, EXEC(stmt, κ)) 

5)												(γ(x), f) ∉ dom(H)
	 ------------------------------------------------------------------						
	 						(H, γ, EXEC(x.f := e; stmt, κ)) → ERROR 


6)						  					H, γ, bex ↑ true
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(if (bex) { stmt1 }  else { stmt2 }; stmt, κ)) → (H, γ, EXEC(stmt1; stmt, κ)) 

7)						  						H, γ, bex ↑ false
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(if (bex) { stmt1 }  else { stmt2 }; stmt, κ)) → (H, γ, EXEC(stmt2; stmt, κ)) 


Evaluation of expressions:

1) 				γ(x) = c
			---------------
				H, γ, x ↑ c

2) H, γ, null ↑ null         H, γ, n ↑ n

3) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 = c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ true

4) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 ≠ c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ false
		   
5) 		H, γ, e ↑ c  ...   bool_op(c,...) = b
			--------------------------------------
		          H, γ, bool_op(e...) ↑ b


Interpretation of assertions over concrete states (⊨)

(H, γ, κ) ⊨ e1 = e2                  iff [e1]γ = [e2]γ.
(H, γ, κ) ⊨ bool_op(e...)            iff bool_op([e]γ...) holds.
(H, γ, κ) ⊨ e1.f ↦[p] e2             iff p ≤ H([e1]γ, f).2 and H([e1]γ, f).1 = [e2]γ.  
(H, γ, κ) ⊨ a0 ∗ a1           			 iff exists H0, H1. H = H0 ∗ H1 and (H0, γ, κ) ⊨ a0 and (H1, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ a0 ∧ a1                  iff (H, γ, κ) ⊨ a0 and (H, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ a0 ∨ a1                  iff (H, γ, κ) ⊨ a0 or (H, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ a0 → a1                  iff forall H', H' ⊥ H and (H' ∗ H, γ, κ) ⊨ a0 implies (H' ∗ H, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ ∃x. a										 iff there exists c s.t. (H, γ[x ↦ c], κ) ⊨ a.  

Validity of Hoare triples:

(H, A, γ, κ) ⊨ { P } C { Q } iff (H, A, γ, κ) ⊨ P and CE((H, A, γ, κ), C, (H', A', γ', DONE)) 
																	implies (H', A', γ', DONE) ⊨ Q.
																		
⊨ { P } C { Q } iff ∀ H, A, γ, κ. (H, A, γ, κ) ⊨ { P } C { Q } 																		    


Symbolic Execution

Symbolic state σₛ of the form (h, π, γ) where:
	1) h: multiset of heap chunks - f(r,v,p); f - field, r - symbolic objects, v - symbolic value, p - symbolic permission value 
	2) π: path condition stack - collection of formulas from many-sorted first-order logic.
	3) γ: Var → SymbVal

	
Interpretation of assertions over symbolic states (⊢)

(h, γ, π) ⊢ e1 = e2                  iff [e1]γ = [e2]γ.
(h, γ, π) ⊢ bool_op(e...)            iff bool_op([e]γ...) holds.
(h, γ, π) ⊢ e1.f ↦[p] e2             iff p ≤ + { p' | f(r, v, p') ∈ h ∧ [r]γ ~ [e1]γ ∧ v = [e2]γ } 
(h, γ, π) ⊢ a0 ∗ a1           			  iff exists h0, h1. h = h0 ∗ h1 (disjoint union) and 
													(h0, γ, π) ⊢ a0 and (h1, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∧ a1                  iff (h, γ, π) ⊢ a0 and (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∨ a1                  iff (h, γ, π) ⊢ a0 or (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 → a1                  iff forall h', h' ⊥ h and (h' ∗ h, γ, π) ⊢ a0 implies (h' ∗ h, γ, π) ⊢ a1.
(h, γ, π) ⊢ ∃x. a								    iff there exists c s.t. (h' ∗ h, γ[x ↦ c], π) ⊢ a.  


Symbolic execution, denoted by relation SE ⊆ Σₛ x Prog x Σₛ     

Execution of statements :

1) (h, γ, π, EXEC(var x: T; stmt, κ)) → (h, γ[x ↦ v_x], EXEC(stmt, κ)) where v_x is a fresh symbolic variable.

2)				   									h, γ, π, e ↑ c               
	 ------------------------------------------------------------------
	 (h, γ, π, EXEC(x := e; stmt, κ)) → (h, γ, π ++ (v_x = c) EXEC(stmt, κ)) 


3)						         r_x fresh var   
	------------------------------------------------------------------						
	 (h, γ, π, EXEC(x := new(f...); stmt, κ)) → (h ++ f(r_x, _, 1) ...] , γ[x ↦ r_x], EXEC(stmt, κ)) 

4)			(γ(x) = r_x)     ∧     + { p | f(r_x, v, p) ∈ h} = 1   ∧   h, γ, π, e ↑ c   
	------------------------------------------------------------------	  
	 (h, γ, π, EXEC(x.f := e; stmt, κ)) → (h, γ, π ++ (v = c),  EXEC(stmt, κ)) 

	//TODO different chunks can (will) have different symbolic values!


5)		(γ(x) = r_x)     ∧     + { p | f(r_x, v, p) ∈ h} < 1
	 ------------------------------------------------------------------
	 						(H, γ, EXEC(x.f := e; stmt, κ)) → ERROR 

	 //TODO for sure aliasing will cause problems here.


6)						  					h, γ, π, bex ↑ true
	 ------------------------------------------------------------------						
	 (h, γ, π, EXEC(if (bex) { stmt1 }  else { stmt2 }; stmt, κ)) → (h, γ, π, EXEC(stmt1; stmt, κ)) 

7)						  						h, γ, π, bex ↑ false
	 ------------------------------------------------------------------						
	 (h, γ, π, EXEC(if (bex) { stmt1 }  else { stmt2 }; stmt, κ)) → (H, γ, π, EXEC(stmt2; stmt, κ)) 



Validity of Hoare triples:

(H, A, γ, κ) ⊨ { P } C { Q } iff (H, A, γ, κ) ⊨ P and 
																		CE((H, A, γ, κ), C, (H', A', γ', DONE)) implies (H', A', γ', DONE) ⊨ Q.
																		
⊢ { P } C { Q } iff ∀ H, A, γ, κ. (H, A, γ, κ) ⊨ { P } C { Q } 																		    

Completeness

⊨ { P } C { Q } → ⊢ { P } C { Q }
	








Scratch:


h = { acc(x, 0.5) && acc(y, 0.5) }
π = { x == y }

h = { acc(x, 1) } 


















