Raven:
------

stmt := var x: T | x := e | x := new (f...) | x.f := e | stmt; stmt
				inhale a | exhale a | assert a |
				{ stmt } □ { stmt } // non-deterministic choice.
				
a := bex | e.f ↦[p] e | a ∗ a | a ∧ a | a ∨ a | ∃ x': e.f ↦[p] x'

# TODO: What to do about: | a → a 

e := x | null | n (base_values)

bex := e = e | bool_op(e...)

==> Concrete execution
----------------------

Program state σ (∈ Σ) either:
- ERROR
- (H, γ), where:
		1) H: Obj_id x Field_id → Val x Perm
		2) γ: Var → Val

==> Operational rules for concrete execution (relation CE ⊆ Σₛ x Prog x Σₛ)
-------------------------------------------

Execution of statements :

We define the semantics in a continuous passing style as a relation between tuples of program state and continuation (σ, κ) where:
	
	κ is continuation: either DONE or EXEC(stmt, κ) 

1) (H, γ, EXEC(var x: T, κ)) → (H, γ[x ↦ _], κ)


2)				   			H, γ, e ↑ c               
	 ------------------------------------------------------------------
	 (H, γ, EXEC(x := e, κ)) → (H, γ[x ↦ c], κ) 


3)							i ∉ first_proj(dom(H))
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x := new(f...), κ)) → (H[(i,f) ↦ (_, 1), ...] , γ[x ↦ i], κ) 


4)			(γ(x), f) ∈ dom(H)     H(γ(x), f) = (_, 1)      H, γ, e ↑ c   
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x.f := e, κ)) → (H[(γ(x),f) ↦ (c,1)], γ, κ) 


5)				(γ(x), f) ∉ dom(H) 		∨ 		H(γ(x), f) ≠ (_, 1)
	 ------------------------------------------------------------------						
	 						(H, γ, EXEC(x.f := e, κ)) → ERROR 


6a)			(H, γ, EXEC({stmt1}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 (H, γ, EXEC({ stmt1 } □ { stmt2 }, κ)) → (H', γ', κ) 


6b)			(H, γ, EXEC({stmt2}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 (H, γ, EXEC({ stmt1 } □ { stmt2 }, κ)) → (H', γ', κ)

7) 				H_1, γ ⊨ a 		∧		H' = H ∘ H_1
	-------------------------------------------------------------------
				(H, γ, EXEC(inhale a, κ)) → (H', γ, κ)

8)								H, γ ⊨ a
	-------------------------------------------------------------------
		(H, γ, EXEC(assert a, κ)) → (H, γ, κ)

9)								H, γ ⊭ a
	-------------------------------------------------------------------
		(H, γ, EXEC(assert a, κ)) → ERROR

10)		H_1, γ ⊨ a	∧	∀ H" ⊂ H_1 : H", γ ⊭ a	∧	H = H' ∘ H_1
	-------------------------------------------------------------------
			(H, γ, EXEC(exhale a, κ)) → (H', γ, κ)


Evaluation of expressions:

1) 				γ(x) = c
			---------------
				H, γ, x ↑ c

2) H, γ, null ↑ null         H, γ, n ↑ n

3) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 = c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ true

4) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 ≠ c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ false
		   
5) 		H, γ, e ↑ c  ...   bool_op(c,...) = b
			--------------------------------------
		          H, γ, bool_op(e...) ↑ b


Interpretation of assertions over concrete states (⊨)

(H, γ) ⊨ e1 = e2				iff [e1]γ = [e2]γ.
(H, γ) ⊨ bool_op(e...)			iff bool_op([e]γ...) holds.
(H, γ) ⊨ e1.f ↦[p] e2			iff p ≤ H([e1]γ, f).2 and H([e1]γ, f).1 = [e2]γ.  
(H, γ) ⊨ a0 ∗ a1				iff exists H0, H1. H = H0 ∗ H1 and (H0, γ, κ) ⊨ a0 and (H1, γ, κ) ⊨ a1.
(H, γ) ⊨ a0 ∧ a1				iff (H, γ, κ) ⊨ a0 and (H, γ, κ) ⊨ a1.
(H, γ) ⊨ a0 ∨ a1				iff (H, γ, κ) ⊨ a0 or (H, γ, κ) ⊨ a1.
(H, γ) ⊨ a0 → a1				iff forall H', H' ⊥ H and (H' ∗ H, γ, κ) ⊨ a0 implies (H' ∗ H, γ, κ) ⊨ a1.
(H, γ) ⊨ ∃x': e.f ↦[p] x'		iff there exists c s.t. (H, γ[x ↦ c], κ) ⊨ a.  

//TODO: Have to find a way to make the existential stick with the rest of the assertion.

Validity of Hoare triples:

(H, γ) ⊨ { P } C { Q } iff (H, γ) ⊨ P and CE((H, γ), C, (H', γ')) 
											implies (H', γ') ⊨ Q.

⊨ { P } C { Q } iff ∀ H, γ. (H, γ) ⊨ { P } C { Q }



Symbolic Execution

Symbolic state σₛ of the form (h, π, γ) where:
	1) h: multiset of heap chunks - f(r,v,p); f - field, r - symbolic objects, v - symbolic value, p - symbolic permission value 
	2) π: path condition stack - collection of formulas from many-sorted first-order logic.
	3) γ: Var → SymbVal

	
Interpretation of assertions over symbolic states (⊢)

(h, γ, π) ⊢ e1 = e2					iff [e1]γ = [e2]γ.
(h, γ, π) ⊢ bool_op(e...)			iff bool_op([e]γ...) holds.
(h, γ, π) ⊢ e1.f ↦[p] e2			iff p ≤ + { p' | f(r, v, p') ∈ h ∧ [r]γ ~ [e1]γ ∧ v = [e2]γ } 
(h, γ, π) ⊢ a0 ∗ a1					iff exists h0, h1. h = h0 ∗ h1 (disjoint union) and 
													(h0, γ, π) ⊢ a0 and (h1, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∧ a1					iff (h, γ, π) ⊢ a0 and (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∨ a1					iff (h, γ, π) ⊢ a0 or (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 → a1					iff forall h', h' ⊥ h and (h' ∗ h, γ, π) ⊢ a0 implies (h' ∗ h, γ, π) ⊢ a1.
(h, γ, π) ⊢ ∃x': e.f ↦[p] x'		iff there exists c s.t. (h' ∗ h, γ[x ↦ c], π) ⊢ a.  


Symbolic execution, denoted by relation SE ⊆ Σₛ x Prog x Σₛ     

Execution of statements :

1) (h, γ, π, EXEC(var x: T, κ)) → (h, γ[x ↦ v_x], κ) where v_x is a fresh SVar.

2)				v_x': fresh SVar		∧		h, γ, π, e ↑ c
	 ------------------------------------------------------------------  	[Assign new SVar to x]
	 (h, γ, π, EXEC(x := e, κ)) → (h, γ[x → v_x'], π ++ (v_x' = c) κ) 


3)						         r_x fresh SVar   
	------------------------------------------------------------------						
	 (h, γ, π, EXEC(x := new(f...), κ)) → (h ++ f(r_x, _, 1) ...] , γ[x ↦ r_x], κ) 

4)	 γ(x) = r_x		∧	v_x' fresh SVar	∧	f(r_x, v, 1) ∈ h	∧	h, γ, π, e ↑ c   
	-----------------------------------------------------------		[Update chunk with fresh SVar]
		(h, γ, π, EXEC(x.f := e, κ)) → (h \ f(r_x,v,1) ++ f(r_x,v_x',1), γ, π ++ (v_x' = c), κ) 

5)		γ(x) = r_x     ∧     f(r_x, v, p) ∈ h; p < 1
	 ------------------------------------------------------------------
	 					(h, γ, π, EXEC(x.f := e, κ)) → ERROR 

6a)				(h, γ, π, EXEC({stmt1}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 		(h, γ, π, EXEC({ stmt1 } □ { stmt2 }, κ)) → (h, γ, π, κ) 

6b)				(h, γ, π, EXEC({stmt2}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 		(h, γ, π, EXEC({ stmt1 } □ { stmt2 }, κ)) → (h, γ, π, κ) 

7a)   		a == e1.f ↦[p] e2	∧	(h, γ, π) ⊢ e1 = r_x 	∧	(h, γ, π) ⊢ e2 = c
	 ------------------------------------------------------------------		[v_x fresh SVar]
	 		(h, γ, π, EXEC(inhale a, k)) → (h ++ f(r_x, v_x, p), γ ++ (v_x = c), π, k)

//TODO: Here what if no such r_x exists in the the heap? Is that even allowed?

7b)			a == a1 * a2 	∨	a == a1 ∧ a2
	-------------------------------------------------------------------
			(h, γ, π, EXEC(inhale a, κ)) → (h, γ, π, EXEC(inhale a1, EXEC(inhale a2, k)))

7c)			a == a1 ∨ a2			∨			a == a2 ∨ a1
	-------------------------------------------------------------------
			(h, γ, π, EXEC(inhale a1 ∨ a2)) → (h, γ, π, EXEC(inhale a1))

7d) 		a == bool_op(e1, e2, ...)
	--------------------------------------------------------------------
		(h, γ, π, EXEC(inhale a, κ)) → (h, γ, π ++ bool_op(e1', e2', ...), k)
		where e1' = e1[x \ γ(x) ] etc

7e)			a == ∃x' : e.f ↦[p] x'	∧	(h, γ, π) ⊢ e = r_z
	---------------------------------------------------------------------	[v_z fresh SVar]
		(h, γ, π, EXEC(inhale a, κ)) → (h ++ f(r_z, v_z, p), γ, π ++ (v_z = x), κ)

8a)   		a == e1.f ↦[p] e2	∧	(h, γ, π) ⊢ e1 = r_x	∧	f(r_x, v_x, p') ∈ h, p' >= p	∧	(h, γ, π) ⊢ v_x = e2
	 ------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, k)) → (h \ f(r_x, v_x, p') ++ f(r_x, v_x, p'-p), γ, π, k)

8b)			a == a1 * a2 	∨	a == a1 ∧ a2
	-------------------------------------------------------------------
			(h, γ, π, EXEC(exhale a, κ)) → (h, γ, π, EXEC(exhale a1, EXEC(exhale a2, k)))

8c)			a == a1 ∨ a2			∨			a == a2 ∨ a1
	-------------------------------------------------------------------
			(h, γ, π, EXEC(exhale a1 ∨ a2)) → (h, γ, π, EXEC(exhale a1))

8d) 		a == bool_op(e1, e2, ...)	∧	h, γ, π ⊢ a
	--------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, κ)) → (h, γ, π, k)
		[Should we have an error state for the alternative?]

	//TODO: Are we sure we don't want to add 'a' to the path conditions here?

8e)			a == ∃x' : e.f ↦[p] x'	∧	(h, γ, π) ⊢ e = r_z	∧	f(r_z, v_z, p') ∈ h, p' >= p
	---------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, κ)) → (h \ f(r_z, v_z, p') ++ f(r_z, v_z, p'-p), γ, π ++ (v_z = x), κ); x fresh SVar

9)			(h, γ, π, EXEC(exhale a, DONE)) → (h', γ', π', DONE)
	--------------------------------------------------------------------
			(h, γ, π, EXEC(assert a, k)) → (h, γ, π', k)	


Validity of Hoare triples:

(H, γ, π) ⊢ { P } C { Q } iff (H, γ, π) ⊢ P and 
								CE((H, γ, π), C, (H', γ', π')) implies (H', γ', π') ⊢ Q.

⊢ { P } C { Q } iff ∀ H, γ, π. (H, γ, π) ⊢ { P } C { Q }


State Consolidation:

Between every step, we run a state consolidation step, described as follows:

Given a state (h, γ, π),
For every pair of heap chunks f(r1,v1,p1) and f(r2,v2,p2) ∈ h, non deterministically either:
1. (h, γ, π) → (h, γ, π ++ (r1 ≠ r2)); or
2. (h, γ, π) → (h ++ f(r1,v1,p1+p2)) \ (f(r1,v1,p1), f(r2,v2,p2)), γ[r2 <- r1], π ++ (r1 == r2, v1 == v2, p1 + p2 ≤ 1))

Suppose after state consolidation gets completed, we get (h, γ, π) → (h', γ', π'). If (h', γ', π') ⊢ UNSAT, then discard.



Completeness

To prove: ⊨ { P } C { Q }	→	⊢ { P } C { Q }



Outline:
	
First we define a relation ■ ∈ (concrete states x symbolic states ) as follows:
σ ■ σₛ if		∀ P: σ ⊨ P iff σₛ ⊢ P.

We define another relation ▷ ∈ (concrete states x symbolic states ) as follows:
σ ▷ σₛ if		∀ P: σₛ ⊢ P → σ ⊨ P.

We use σₛ -SC→ σₛ' to denote that σₛ' is a state that can be obtained by doing state-consolidation on σₛ.

Lemma 1: For a symbolic state σₛ, if σₛ -SC→ σₛ', there there exists a concrete state σ' such that σ' ■ σₛ'. Moreover, σ' ▷ σₛ.
// Lemma 1 is essentially some kind of a statement of completeness for the state-consolidation algo.


Lemma 2: If σₛ -SC→ σₛ' -s→ σₛ" -SC→ σₛ"', and σ"' ■ σₛ"' then there exists a concrete state σ' such that σ' ■ σₛ' and σ' -s→ σ"'.





Proof of Lemma 1:
Let σₛ = (h, γ, π), σₛ' = (h', γ', π'). Since (h', γ', π') ¬⊢ UNSAT, therefore the SMT solver must be able to return a valuation that satisfies the path conditions in π'. Define the concrete state by instantiating a pointer for every heap chunk in h' (all heap chunks in h' are already consolidated), and assigning the satisfying assignment from the SAT solver. Call it H. Same for γ', replace all symbolic variables with their satisfying assignment values.

Therefore (H, γ) ■ σₛ'. (to be proved by induction on structure of assertions).

We can prove another Lemma 1.1: If σₛ -SC→ σₛ', then for any assertion P, σₛ ⊢ P → σₛ' ⊢ P. (by induction on P)

This will directly imply that (H, γ) ▷ σₛ.


Proof of Lemma 2:
Induction on s.



-----------------------------------------------------

Explanation:

⊨ {P} C {Q}		→	⊢ {P} C {Q}
∀ σ, σ' : σ ⊨ P ∧ CE(σ, C, σ') → σ' ⊨ Q		→	∀ σₛ, σₛ' : σₛ ⊢ P ∧ CE(σₛ, C, σₛ') → σₛ' ⊢ Q

We are given: 

1. ∀ σ, σ' : σ ⊨ P ∧ CE(σ, C, σ') → σ' ⊨ Q.		(⊨ {P} C {Q})
2. σₛ, σₛ'.
3. σₛ ⊢ P
4. CE(σₛ, C, σₛ')

To Prove: 		σₛ' ⊢ Q




CE(σₛ, C, σₛ') :

σₛ -SC→ σₛ' -C_1→ σₛ₁ -SC→ σₛ₁' -C_2→ σₛ₂ -SC→σₛ₂' → ... → σₛₙ -SC→ σₛₙ' = σ'
																	^ 
																	|
																	|
																	σₙ


Use lemma 1 to get such a concrete state σₙ'.
Use Lemma 2 to build backwards to create a concrete run which satisfies all the assumptions of given (1).












Scratch:


h = { acc(x, 0.5) && acc(y, 0.5) }
π = { x == y }

h = { acc(x, 1) } 





-----------------------------------------------------
If σ' ▷ σₛ', and for a stmt C, if SE(σₛ, C, σₛ'), then there exists a concrete state σ such that CE(σ, C, σ')

Lemma 3: If σₛ -SC→ σₛ', and 


Lemma 1: If σ ■ σₛ, then there exists some symbolic state σₛ' such that σₛ -SC→ σₛ' such that σ ■ σₛ'.

Lemma 2: For a symbolic state σₛ, if there exists some symbolic state σₛ' such that σₛ -SC→ σₛ', then there exists some concrete state σ' such that σ' ■ σₛ' and σ' ■ σₛ.

Lemma 3: If σ ■ σₛ, then for any stmt C, if SE(σₛ, C, σₛ'), then there exists a concrete state σ' such that CE(σ, C, σ').
-----------------------------------------------------

