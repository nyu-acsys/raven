Raven:
------

stmt := var x: T | x := e | x := new (f...) | x.f := e | stmt; stmt
				inhale a | exhale a | assert a |
				{ stmt } □ { stmt } // non-deterministic choice.
				
a := bex | e.f ↦[p] e | a ∗ a | a ∧ a | a ∨ a | ∃x : e.f ↦[p] x
# What to do about these: | a → a 

e := x | null | n (base_values)

bex := e = e | bool_op(e...)

==> Concrete execution
----------------------

Program state σ (∈ Σ) either:
- ERROR
- (H, γ, κ), where:
		1) H: Obj_id x Field_id → Val x Perm
		2) γ: Var → Val 
		3) κ is continuation: either DONE or EXEC(stmt, κ) 


==> Operational rules for concrete execution (relation CE ⊆ Σₛ x Prog x Σₛ)
-------------------------------------------

Execution of statements :

1) (H, γ, EXEC(var x: T, κ)) → (H, γ[x ↦ _], κ)


2)				   			H, γ, e ↑ c               
	 ------------------------------------------------------------------
	 (H, γ, EXEC(x := e, κ)) → (H, γ[x ↦ c], κ) 


3)							i ∉ first_proj(dom(H))
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x := new(f...), κ)) → (H[(i,f) ↦ (_, 1), ...] , γ[x ↦ i], κ) 


4)			(γ(x), f) ∈ dom(H)     H(γ(x), f) = (_, 1)      H, γ, e ↑ c   
	 ------------------------------------------------------------------						
	 (H, γ, EXEC(x.f := e, κ)) → (H[(γ(x),f) ↦ (c,1)], γ, κ) 


5)				(γ(x), f) ∉ dom(H) 		∨ 		H(γ(x), f) ≠ (_, 1)
	 ------------------------------------------------------------------						
	 						(H, γ, EXEC(x.f := e, κ)) → ERROR 


6a)			(H, γ, EXEC({stmt1}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 (H, γ, EXEC({ stmt1 } □ { stmt2 }, κ)) → (H', γ', κ) 


6b)			(H, γ, EXEC({stmt2}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 (H, γ, EXEC({ stmt1 } □ { stmt2 }, κ)) → (H', γ', κ)

7) 				H_1, γ ⊨ a 		∧		H' = H ∘ H_1
	-------------------------------------------------------------------
				(H, γ, EXEC(inhale a, κ)) → (H', γ, κ)

8)								H, γ ⊨ a
	-------------------------------------------------------------------
		(H, γ, EXEC(assert a, κ)) → (H, γ, κ)

9)								H, γ ⊭ a
	-------------------------------------------------------------------
		(H, γ, EXEC(assert a, κ)) → ERROR

10)		H_1, γ ⊨ a	∧	∀ H" ⊂ H_1 : H", γ ⊭ a	∧	H = H' ∘ H_1
	-------------------------------------------------------------------
			(H, γ, EXEC(exhale a, κ)) → (H', γ, κ)


Evaluation of expressions:

1) 				γ(x) = c
			---------------
				H, γ, x ↑ c

2) H, γ, null ↑ null         H, γ, n ↑ n

3) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 = c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ true

4) 		 H, γ, e1 ↑ c1      H, γ, e2 ↑ c2      c1 ≠ c2
			-----------------------------------------------
		                  H, γ, e1 = e2 ↑ false
		   
5) 		H, γ, e ↑ c  ...   bool_op(c,...) = b
			--------------------------------------
		          H, γ, bool_op(e...) ↑ b


Interpretation of assertions over concrete states (⊨)

(H, γ, κ) ⊨ e1 = e2                  iff [e1]γ = [e2]γ.
(H, γ, κ) ⊨ bool_op(e...)            iff bool_op([e]γ...) holds.
(H, γ, κ) ⊨ e1.f ↦[p] e2             iff p ≤ H([e1]γ, f).2 and H([e1]γ, f).1 = [e2]γ.  
(H, γ, κ) ⊨ a0 ∗ a1           			 iff exists H0, H1. H = H0 ∗ H1 and (H0, γ, κ) ⊨ a0 and (H1, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ a0 ∧ a1                  iff (H, γ, κ) ⊨ a0 and (H, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ a0 ∨ a1                  iff (H, γ, κ) ⊨ a0 or (H, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ a0 → a1                  iff forall H', H' ⊥ H and (H' ∗ H, γ, κ) ⊨ a0 implies (H' ∗ H, γ, κ) ⊨ a1.
(H, γ, κ) ⊨ ∃x. a										 iff there exists c s.t. (H, γ[x ↦ c], κ) ⊨ a.  

Validity of Hoare triples:

(H, A, γ, κ) ⊨ { P } C { Q } iff (H, A, γ, κ) ⊨ P and CE((H, A, γ, κ), C, (H', A', γ', DONE)) 
																	implies (H', A', γ', DONE) ⊨ Q.
																		
⊨ { P } C { Q } iff ∀ H, A, γ, κ. (H, A, γ, κ) ⊨ { P } C { Q } 																		    


Symbolic Execution

Symbolic state σₛ of the form (h, π, γ) where:
	1) h: multiset of heap chunks - f(r,v,p); f - field, r - symbolic objects, v - symbolic value, p - symbolic permission value 
	2) π: path condition stack - collection of formulas from many-sorted first-order logic.
	3) γ: Var → SymbVal

	
Interpretation of assertions over symbolic states (⊢)

(h, γ, π) ⊢ e1 = e2                  iff [e1]γ = [e2]γ.
(h, γ, π) ⊢ bool_op(e...)            iff bool_op([e]γ...) holds.
(h, γ, π) ⊢ e1.f ↦[p] e2            iff p ≤ + { p' | f(r, v, p') ∈ h ∧ [r]γ ~ [e1]γ ∧ v = [e2]γ } 
(h, γ, π) ⊢ a0 ∗ a1           		 iff exists h0, h1. h = h0 ∗ h1 (disjoint union) and 
													(h0, γ, π) ⊢ a0 and (h1, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∧ a1                  iff (h, γ, π) ⊢ a0 and (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 ∨ a1                  iff (h, γ, π) ⊢ a0 or (h, γ, π) ⊢ a1.
(h, γ, π) ⊢ a0 → a1                  iff forall h', h' ⊥ h and (h' ∗ h, γ, π) ⊢ a0 implies (h' ∗ h, γ, π) ⊢ a1.
(h, γ, π) ⊢ ∃x. a					 iff there exists c s.t. (h' ∗ h, γ[x ↦ c], π) ⊢ a.  


Symbolic execution, denoted by relation SE ⊆ Σₛ x Prog x Σₛ     

Execution of statements :

1) (h, γ, π, EXEC(var x: T, κ)) → (h, γ[x ↦ v_x], κ) where v_x is a fresh symbolic variable.

2)				v_x' fresh SVar		∧		h, γ, π, e ↑ c               
	 ------------------------------------------------------------------  	[Assign new SVar to x]
	 (h, γ, π, EXEC(x := e, κ)) → (h, γ[x → v_x'], π ++ (v_x' = c) κ) 


3)						         r_x fresh SVar   
	------------------------------------------------------------------						
	 (h, γ, π, EXEC(x := new(f...), κ)) → (h ++ f(r_x, _, 1) ...] , γ[x ↦ r_x], κ) 

4)	 γ(x) = r_x		∧	v_x' fresh SVar	∧	+ { p | f(r_x, v, p) ∈ h} = 1	∧	h, γ, π, e ↑ c   
	-----------------------------------------------------------	[Update all chunks with fresh SVar]
		(h, γ, π, EXEC(x.f := e, κ)) → (h[f(r_x,v_x',p) \ f(r_x,v,p)], γ, π ++ (v_x' = c), κ) 


5)		(γ(x) = r_x)     ∧     + { p | f(r_x, v, p) ∈ h} < 1
	 ------------------------------------------------------------------
	 						(h, γ, π, EXEC(x.f := e, κ)) → ERROR 

	 //TODO for sure aliasing will cause problems here.


6a)				(h, γ, π, EXEC({stmt1}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 		(h, γ, π, EXEC({ stmt1 } □ { stmt2 }, κ)) → (h, γ, π, κ) 

6b)				(h, γ, π, EXEC({stmt2}, κ)) → (H', γ', κ)
	 ------------------------------------------------------------------						
	 		(h, γ, π, EXEC({ stmt1 } □ { stmt2 }, κ)) → (h, γ, π, κ) 

7a)   		a == e1.f ↦[p] e2	∧	e1 ↑ x 	∧	e2 ↑ c	∧	γ(x) = r_x, v_x fresh SVar
	 ------------------------------------------------------------------
	 		(h, γ, π, EXEC(exhale a, k)) → (h ++ f(r_x, v_x, p), γ ++ (v_x = c), π, k)

7b)			a == a1 * a2 	∨	a == a1 ∧ a2
	-------------------------------------------------------------------
			(h, γ, π, EXEC(inhale a, κ)) → (h, γ, π, EXEC(inhale a1, EXEC(inhale a2, k)))

7c)			a == a1 ∨ a2			∨			a == a2 ∨ a1
	-------------------------------------------------------------------
			(h, γ, π, EXEC(inhale a1 ∨ a2)) → (h, γ, π, EXEC(inhale a1))

7d) 		a == bool_op(e1, e2, ...)
	--------------------------------------------------------------------
		(h, γ, π, EXEC(inhale a, κ)) → (h, γ, π ++ bool_op(e1', e2', ...), k)
		where e1' = e1[x \ γ(x) ] etc

7e)			a == ∃x : e.f ↦[p] x	∧	e ↑ z	∧	γ(z) = r_z	∧	v_z fresh SVar
	---------------------------------------------------------------------
		(h, γ, π, EXEC(inhale a, κ)) → (h ++ f(r_z, v_z, p), γ, π ++ (v_z = x), κ)

//TODO
8a)   		a == e1.f ↦[p] e2	∧	e1 ↑ x 	∧	e2 ↑ c	∧	γ(x) = r_x, v_x fresh SVar
	 ------------------------------------------------------------------
	 		(h, γ, π, EXEC(exhale a, k)) → (h ++ f(r_x, v_x, p), γ ++ (v_x = c, π, k)
	 		[What does e2 mean in exhale?]

8b)			a == a1 * a2 	∨	a == a1 ∧ a2
	-------------------------------------------------------------------
			(h, γ, π, EXEC(exhale a, κ)) → (h, γ, π, EXEC(exhale a1, EXEC(exhale a2, k)))

8c)			a == a1 ∨ a2			∨			a == a2 ∨ a1
	-------------------------------------------------------------------
			(h, γ, π, EXEC(exhale a1 ∨ a2)) → (h, γ, π, EXEC(exhale a1))

8d) 		a == bool_op(e1, e2, ...)	∧	h, γ, π ⊢ a
	--------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, κ)) → (h, γ, π, k)
		[Should we have an error state for the alternative?]

//TODO
8e)			a == ∃x : e.f ↦[p] x	∧	e ↑ z	∧	γ(z) = r_z	∧	v_z fresh SVar	∧	
	---------------------------------------------------------------------
		(h, γ, π, EXEC(exhale a, κ)) → (h ++ f(r_z, v_z, p), γ, π ++ (v_z = x), κ)


[Ambiguity in assertions between existentially quantified variables and variables in the code.]



//TODO: inhale, exhale, assert
 



Validity of Hoare triples:

(H, A, γ, κ) ⊨ { P } C { Q } iff (H, A, γ, κ) ⊨ P and 
																		CE((H, A, γ, κ), C, (H', A', γ', DONE)) implies (H', A', γ', DONE) ⊨ Q.
																		
⊢ { P } C { Q } iff ∀ H, A, γ, κ. (H, A, γ, κ) ⊨ { P } C { Q } 																		    

Completeness

⊨ { P } C { Q } 	→	 ⊢ { P } C { Q }
	








Scratch:


h = { acc(x, 0.5) && acc(y, 0.5) }
π = { x == y }

h = { acc(x, 1) } 